/** Possible progress states. */
export const PROGRESS = {
    /** The socket is connecting. */
    CONNECTING: 0,
    /** The socket is successfully connected. */
    CONNECTED: 1,
    /** All objects are loaded. */
    OBJECTS_LOADED: 2,
    /** All states are loaded. */
    STATES_LOADED: 3,
    /** The socket is ready for use. */
    READY: 4,
};
const PERMISSION_ERROR = 'permissionError';
const NOT_CONNECTED = 'notConnectedError';
export const ERRORS = {
    PERMISSION_ERROR,
    NOT_CONNECTED,
};
/** Converts ioB pattern into regex */
export function pattern2RegEx(pattern) {
    pattern = (pattern || '').toString();
    const startsWithWildcard = pattern[0] === '*';
    const endsWithWildcard = pattern[pattern.length - 1] === '*';
    pattern = pattern.replace(/[-/\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*');
    return (startsWithWildcard ? '' : '^') + pattern + (endsWithWildcard ? '' : '$');
}
export class LegacyConnection {
    // Do not define it as null, else we must check for null everywhere
    _socket;
    _authTimer;
    systemLang = 'en';
    _waitForFirstConnection;
    _waitForFirstConnectionResolve = null;
    _promises = {};
    _instanceSubscriptions;
    props;
    doNotLoadAllObjects;
    doNotLoadACL;
    states = {};
    objects = null;
    scriptLoadCounter;
    acl = null;
    firstConnect = true;
    waitForRestart = false;
    connected = false;
    statesSubscribes = {};
    objectsSubscribes = {};
    filesSubscribes = {};
    onConnectionHandlers = [];
    onLogHandlers = [];
    onProgress;
    onError;
    loaded = false;
    loadTimer = null;
    loadCounter = 0;
    ignoreState = '';
    simStates = {};
    autoSubscribes;
    autoSubscribeLog;
    subscribed;
    isSecure;
    onCmdStdoutHandler;
    onCmdStderrHandler;
    onCmdExitHandler;
    systemConfig = null;
    objectViewCached;
    constructor(props) {
        props ||= { protocol: window.location.protocol, host: window.location.hostname };
        this.props = props;
        this.autoSubscribes = this.props.autoSubscribes || [];
        this.autoSubscribeLog = this.props.autoSubscribeLog || false;
        this.props.protocol ||= window.location.protocol;
        this.props.host ||= window.location.hostname;
        this.props.port ||=
            window.location.port === '3000' ? (LegacyConnection.isWeb() ? 8082 : 8081) : window.location.port;
        this.props.ioTimeout = Math.max(this.props.ioTimeout || 20000, 20000);
        this.props.cmdTimeout = Math.max(this.props.cmdTimeout || 5000, 5000);
        this._instanceSubscriptions = {};
        // breaking change. Do not load all objects by default is true
        this.doNotLoadAllObjects = this.props.doNotLoadAllObjects === undefined ? true : this.props.doNotLoadAllObjects;
        this.doNotLoadACL = this.props.doNotLoadACL === undefined ? true : this.props.doNotLoadACL;
        this.states = {};
        this._waitForFirstConnection = new Promise(resolve => {
            this._waitForFirstConnectionResolve = resolve;
        });
        this.onProgress = this.props.onProgress || (() => { });
        this.onError =
            this.props.onError ||
                ((err) => console.error(err));
        this.startSocket();
    }
    /**
     * Checks if this connection is running in a web adapter and not in an admin.
     *
     * @returns True if running in a web adapter or in a socketio adapter.
     */
    static isWeb() {
        const adapterName = window.adapterName;
        return (adapterName === 'material' ||
            adapterName === 'vis' ||
            adapterName?.startsWith('vis-') ||
            adapterName === 'echarts-show' ||
            window.socketUrl !== undefined);
    }
    /**
     * Starts the socket.io connection.
     */
    startSocket() {
        // if socket io is not yet loaded
        if (typeof window.io === 'undefined' && typeof window.iob === 'undefined') {
            // if in index.html the onLoad function not defined
            if (typeof window.registerSocketOnLoad !== 'function') {
                // poll if loaded
                this.scriptLoadCounter ||= 0;
                this.scriptLoadCounter++;
                if (this.scriptLoadCounter < 30) {
                    // wait till the script loaded
                    setTimeout(() => this.startSocket(), 100);
                    return;
                }
                window.alert('Cannot load socket.io.js!');
            }
            else {
                // register on load
                window.registerSocketOnLoad(() => this.startSocket());
            }
            return;
        }
        if (this._socket) {
            // socket was initialized, do not repeat
            return;
        }
        let host = this.props.host;
        let port = this.props.port;
        let protocol = this.props.protocol.replace(':', '');
        let path = window.location.pathname;
        if (window.location.hostname === 'iobroker.net' || window.location.hostname === 'iobroker.pro') {
            path = '';
        }
        else {
            // if web adapter, socket io could be on another port or even host
            if (window.socketUrl) {
                const parsed = new URL(window.socketUrl);
                host = parsed.hostname;
                port = parsed.port;
                protocol = parsed.protocol.replace(':', '');
            }
            // get a current path
            const pos = path.lastIndexOf('/');
            if (pos !== -1) {
                path = path.substring(0, pos + 1);
            }
            if (LegacyConnection.isWeb()) {
                // remove one level, like echarts, vis, .... We have here: '/echarts/'
                const parts = path.split('/');
                if (parts.length > 2) {
                    parts.pop();
                    // if it is a version, like in material, so remove it too
                    if (parts[parts.length - 1].match(/\d+\.\d+\.\d+/)) {
                        parts.pop();
                    }
                    parts.pop();
                    path = parts.join('/');
                    if (!path.endsWith('/')) {
                        path += '/';
                    }
                }
            }
        }
        const url = port ? `${protocol}://${host}:${port}${path}` : `${protocol}://${host}${path}`;
        this._socket = (window.io || window.iob).connect(url, {
            path: path.endsWith('/') ? `${path}socket.io` : `${path}/socket.io`,
            query: 'ws=true',
            name: this.props.name,
            timeout: this.props.ioTimeout,
            uuid: this.props.uuid,
        });
        this._socket.on('connect', (noTimeout) => {
            // If the user is not admin, it takes some time to install the handlers, because all rights must be checked
            if (noTimeout !== true) {
                setTimeout(() => this.getVersion().then(info => {
                    const [major, minor, patch] = info.version.split('.');
                    const v = parseInt(major, 10) * 10000 + parseInt(minor, 10) * 100 + parseInt(patch, 10);
                    if (v < 40102) {
                        this._authTimer = null;
                        // possible this is an old version of admin
                        this.onPreConnect(false, false);
                    }
                    else {
                        this._socket.emit('authenticate', (isOk, isSecure) => this.onPreConnect(isOk, isSecure));
                    }
                }), 500);
            }
            else {
                // iobroker websocket waits, till all handlers are installed
                this._socket.emit('authenticate', (isOk, isSecure) => this.onPreConnect(isOk, isSecure));
            }
        });
        this._socket.on('reconnect', () => {
            this.onProgress(PROGRESS.READY);
            this.connected = true;
            if (this.waitForRestart) {
                window.location.reload();
            }
            else {
                this._subscribe(true);
                this.onConnectionHandlers.forEach(cb => cb(true));
            }
        });
        this._socket.on('disconnect', () => {
            this.connected = false;
            this.subscribed = false;
            this.onProgress(PROGRESS.CONNECTING);
            this.onConnectionHandlers.forEach(cb => cb(false));
        });
        this._socket.on('reauthenticate', () => LegacyConnection.authenticate());
        this._socket.on('log', message => {
            this.props.onLog?.(message);
            this.onLogHandlers.forEach(cb => cb(message));
        });
        this._socket.on('error', (err) => {
            let _err = err || '';
            if (typeof _err.toString !== 'function') {
                _err = JSON.stringify(_err);
                console.error(`Received strange error: ${_err}`);
            }
            _err = _err.toString();
            if (_err.includes('User not authorized')) {
                LegacyConnection.authenticate();
            }
            else {
                window.alert(`Socket Error: ${err}`);
            }
        });
        this._socket.on('connect_error', (err) => console.error(`Connect error: ${err}`));
        this._socket.on('permissionError', (err) => this.onError({
            message: 'no permission',
            operation: err.operation,
            type: err.type,
            id: err.id || '',
        }));
        this._socket.on('objectChange', (id, obj) => setTimeout(() => this.objectChange(id, obj), 0));
        this._socket.on('stateChange', (id, state) => setTimeout(() => this.stateChange(id, state), 0));
        this._socket.on('im', (messageType, from, data) => setTimeout(() => this.instanceMessage(messageType, from, data), 0));
        this._socket.on('fileChange', (id, fileName, size) => setTimeout(() => this.fileChange(id, fileName, size), 0));
        this._socket.on('cmdStdout', (id, text) => this.onCmdStdoutHandler?.(id, text));
        this._socket.on('cmdStderr', (id, text) => this.onCmdStderrHandler?.(id, text));
        this._socket.on('cmdExit', (id, exitCode) => this.onCmdExitHandler?.(id, exitCode));
    }
    /**
     * Called internally.
     */
    onPreConnect(_isOk, isSecure) {
        if (this._authTimer) {
            clearTimeout(this._authTimer);
            this._authTimer = null;
        }
        this.connected = true;
        this.isSecure = isSecure;
        if (this.waitForRestart) {
            window.location.reload();
        }
        else {
            if (this.firstConnect) {
                // retry strategy
                this.loadTimer = setTimeout(() => {
                    this.loadTimer = null;
                    this.loadCounter++;
                    if (this.loadCounter < 10) {
                        void this.onConnect().catch(e => this.onError(e));
                    }
                }, 1000);
                if (!this.loaded) {
                    void this.onConnect().catch(e => this.onError(e));
                }
            }
            else {
                this.onProgress(PROGRESS.READY);
            }
            this._subscribe(true);
            this.onConnectionHandlers.forEach(cb => cb(true));
        }
        if (this._waitForFirstConnectionResolve) {
            this._waitForFirstConnectionResolve();
            this._waitForFirstConnectionResolve = null;
        }
    }
    /**
     * Checks if running in ioBroker cloud
     */
    static isCloud() {
        if (window.location.hostname.includes('amazonaws.com') || window.location.hostname.includes('iobroker.in')) {
            return true;
        }
        if (typeof window.socketUrl === 'undefined') {
            return false;
        }
        return window.socketUrl.includes('iobroker.in') || window.socketUrl.includes('amazonaws');
    }
    /**
     * Checks if the socket is connected.
     */
    isConnected() {
        return this.connected;
    }
    /**
     * Checks if the socket is connected.
     * Promise resolves if once connected.
     */
    waitForFirstConnection() {
        return this._waitForFirstConnection;
    }
    /**
     * Called internally.
     */
    async _getUserPermissions() {
        if (this.doNotLoadACL) {
            return null;
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getUserPermissions', (err, acl) => err ? reject(new Error(err)) : resolve(acl));
        });
    }
    /**
     * Called internally.
     */
    async onConnect() {
        let acl;
        try {
            acl = await this._getUserPermissions();
        }
        catch (e) {
            const knownError = e;
            this.onError(`Cannot read user permissions: ${knownError.message}`);
            return;
        }
        if (!this.doNotLoadACL) {
            if (this.loaded) {
                return;
            }
            this.loaded = true;
            if (this.loadTimer) {
                clearTimeout(this.loadTimer);
                this.loadTimer = null;
            }
            this.onProgress(PROGRESS.CONNECTED);
            this.firstConnect = false;
            this.acl = acl;
        }
        // Read system configuration
        let systemConfig;
        try {
            systemConfig = await this.getSystemConfig();
            if (this.doNotLoadACL) {
                if (this.loaded) {
                    return;
                }
                this.loaded = true;
                if (this.loadTimer) {
                    clearTimeout(this.loadTimer);
                    this.loadTimer = null;
                }
                this.onProgress(PROGRESS.CONNECTED);
                this.firstConnect = false;
            }
            this.systemConfig = systemConfig;
            if (this.systemConfig?.common) {
                this.systemLang = this.systemConfig.common.language;
            }
            else {
                // @ts-expect-error userLanguage is not standard
                this.systemLang = window.navigator.userLanguage || window.navigator.language;
                if (/^(en|de|ru|pt|nl|fr|it|es|pl|uk)-?/.test(this.systemLang)) {
                    this.systemLang = this.systemLang.substr(0, 2);
                }
                else if (!/^(en|de|ru|pt|nl|fr|it|es|pl|uk|zh-cn)$/.test(this.systemLang)) {
                    this.systemLang = 'en';
                }
            }
            this.props.onLanguage?.(this.systemLang);
            if (!this.doNotLoadAllObjects) {
                await this.getObjects();
                this.onProgress(PROGRESS.READY);
                if (this.props.onReady && this.objects) {
                    this.props.onReady(this.objects);
                }
            }
            else {
                this.objects = { 'system.config': systemConfig };
                this.onProgress(PROGRESS.READY);
                this.props.onReady?.(this.objects);
            }
        }
        catch (e) {
            this.onError(`Cannot read system config: ${e}`);
        }
    }
    /**
     * Called internally.
     */
    static authenticate() {
        if (window.location.search.includes('&href=')) {
            window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;
        }
        else {
            window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}?login&href=${window.location.search}${window.location.hash}`;
        }
    }
    /**
     * Subscribe to changes of the given state.
     *
     * @param id The ioBroker state ID or array of states
     * @param binary Set to true if the given state is binary and requires Base64 decoding
     * @param cb The callback
     */
    async subscribeState(id, binary, cb) {
        if (typeof binary === 'function') {
            cb = binary;
            binary = false;
        }
        let ids;
        if (!Array.isArray(id)) {
            ids = [id];
        }
        else {
            ids = id;
        }
        if (!cb) {
            console.error('No callback found for subscribeState');
            return Promise.reject(new Error('No callback found for subscribeState'));
        }
        const toSubscribe = [];
        for (let i = 0; i < ids.length; i++) {
            const _id = ids[i];
            if (!this.statesSubscribes[_id]) {
                let reg = _id
                    .replace(/\./g, '\\.')
                    .replace(/\*/g, '.*')
                    .replace(/\(/g, '\\(')
                    .replace(/\)/g, '\\)')
                    .replace(/\+/g, '\\+')
                    .replace(/\[/g, '\\[');
                if (!reg.includes('*')) {
                    reg += '$';
                }
                this.statesSubscribes[_id] = { reg: new RegExp(reg), cbs: [cb] };
                if (_id !== this.ignoreState) {
                    toSubscribe.push(_id);
                }
            }
            else {
                !this.statesSubscribes[_id].cbs.includes(cb) && this.statesSubscribes[_id].cbs.push(cb);
            }
        }
        if (!this.connected) {
            return;
        }
        if (toSubscribe.length) {
            // no answer from server required
            this._socket.emit('subscribe', toSubscribe);
        }
        if (binary) {
            let base64;
            for (let i = 0; i < ids.length; i++) {
                try {
                    // deprecated, but we still support it
                    base64 = await this.getBinaryState(ids[i]);
                }
                catch (e) {
                    console.error(`Cannot getBinaryState "${ids[i]}": ${JSON.stringify(e)}`);
                    base64 = undefined;
                }
                if (base64 !== undefined && cb) {
                    cb(ids[i], base64);
                }
            }
        }
        else {
            return new Promise((resolve, reject) => {
                this._socket.emit(LegacyConnection.isWeb() ? 'getStates' : 'getForeignStates', ids, (err, states) => {
                    if (err) {
                        console.error(`Cannot getForeignStates "${id}": ${JSON.stringify(err)}`);
                        reject(new Error(err));
                    }
                    else {
                        if (states) {
                            Object.keys(states).forEach(_id => cb(_id, states[_id]));
                        }
                        resolve();
                    }
                });
            });
        }
    }
    /**
     * Subscribe to changes of the given state.
     */
    subscribeStateAsync(
    /** The ioBroker state ID or array of states */
    id, 
    /** The callback. */
    cb) {
        let ids;
        if (!Array.isArray(id)) {
            ids = [id];
        }
        else {
            ids = id;
        }
        const toSubscribe = [];
        for (let i = 0; i < ids.length; i++) {
            const _id = ids[i];
            if (!this.statesSubscribes[_id]) {
                let reg = _id
                    .replace(/\./g, '\\.')
                    .replace(/\*/g, '.*')
                    .replace(/\(/g, '\\(')
                    .replace(/\)/g, '\\)')
                    .replace(/\+/g, '\\+')
                    .replace(/\[/g, '\\[');
                if (!reg.includes('*')) {
                    reg += '$';
                }
                this.statesSubscribes[_id] = { reg: new RegExp(reg), cbs: [] };
                this.statesSubscribes[_id].cbs.push(cb);
                if (_id !== this.ignoreState) {
                    // no answer from server required
                    toSubscribe.push(_id);
                }
            }
            else {
                !this.statesSubscribes[_id].cbs.includes(cb) && this.statesSubscribes[_id].cbs.push(cb);
            }
        }
        if (toSubscribe.length && this.connected) {
            // no answer from server required
            this._socket.emit('subscribe', toSubscribe);
        }
        return new Promise((resolve, reject) => {
            if (typeof cb === 'function' && this.connected) {
                this._socket.emit(LegacyConnection.isWeb() ? 'getStates' : 'getForeignStates', id, (err, states) => {
                    err && console.error(`Cannot getForeignStates "${id}": ${JSON.stringify(err)}`);
                    states && Object.keys(states).forEach(_id => cb(_id, states[_id]));
                    states
                        ? resolve()
                        : reject(new Error(`Cannot getForeignStates "${id}": ${JSON.stringify(err)}`));
                });
            }
            else {
                this.connected ? reject(new Error('callback is not a function')) : reject(new Error('not connected'));
            }
        });
    }
    /**
     * Unsubscribes all or the given callback from changes of the given state.
     */
    unsubscribeState(
    /** The ioBroker state ID or array of states */
    id, 
    /** The callback. */
    cb) {
        let ids;
        if (!Array.isArray(id)) {
            ids = [id];
        }
        else {
            ids = id;
        }
        const toUnsubscribe = [];
        for (let i = 0; i < ids.length; i++) {
            const _id = ids[i];
            if (this.statesSubscribes[_id]) {
                if (cb) {
                    const pos = this.statesSubscribes[_id].cbs.indexOf(cb);
                    if (pos !== -1) {
                        this.statesSubscribes[_id].cbs.splice(pos, 1);
                    }
                }
                else {
                    this.statesSubscribes[_id].cbs = [];
                }
                if (!this.statesSubscribes[_id].cbs || !this.statesSubscribes[_id].cbs.length) {
                    delete this.statesSubscribes[_id];
                    if (_id !== this.ignoreState) {
                        toUnsubscribe.push(_id);
                    }
                }
            }
        }
        if (toUnsubscribe.length && this.connected) {
            // no answer from server required
            this._socket.emit('unsubscribe', toUnsubscribe);
        }
    }
    /**
     * Subscribe to changes of the given object.
     *
     * @param id The ioBroker object ID or array of objects
     * @param cb The callback
     */
    subscribeObject(id, cb) {
        let ids;
        if (!Array.isArray(id)) {
            ids = [id];
        }
        else {
            ids = id;
        }
        const toSubscribe = [];
        for (let i = 0; i < ids.length; i++) {
            const _id = ids[i];
            if (!this.objectsSubscribes[_id]) {
                let reg = _id.replace(/\./g, '\\.').replace(/\*/g, '.*');
                if (!reg.includes('*')) {
                    reg += '$';
                }
                this.objectsSubscribes[_id] = { reg: new RegExp(reg), cbs: [cb] };
                toSubscribe.push(_id);
            }
            else {
                !this.objectsSubscribes[_id].cbs.includes(cb) && this.objectsSubscribes[_id].cbs.push(cb);
            }
        }
        if (this.connected && toSubscribe.length) {
            this._socket.emit('subscribeObjects', toSubscribe);
        }
        return Promise.resolve();
    }
    /**
     * Unsubscribes all or the given callback from changes of the given object.
     *
     * @param id The ioBroker object ID or array of objects
     * @param cb The callback
     */
    unsubscribeObject(id, cb) {
        let ids;
        if (!Array.isArray(id)) {
            ids = [id];
        }
        else {
            ids = id;
        }
        const toUnsubscribe = [];
        for (let i = 0; i < ids.length; i++) {
            const _id = ids[i];
            if (this.objectsSubscribes[_id]) {
                if (cb) {
                    const pos = this.objectsSubscribes[_id].cbs.indexOf(cb);
                    pos !== -1 && this.objectsSubscribes[_id].cbs.splice(pos, 1);
                }
                else {
                    this.objectsSubscribes[_id].cbs = [];
                }
                if (this.connected && (!this.objectsSubscribes[_id].cbs || !this.objectsSubscribes[_id].cbs.length)) {
                    delete this.objectsSubscribes[_id];
                    toUnsubscribe.push(_id);
                }
            }
        }
        if (this.connected && toUnsubscribe.length) {
            this._socket.emit('unsubscribeObjects', toUnsubscribe);
        }
        return Promise.resolve();
    }
    /**
     * Called internally.
     */
    fileChange(id, fileName, size) {
        for (const sub of Object.values(this.filesSubscribes)) {
            if (sub.regId.test(id) && sub.regFilePattern.test(fileName)) {
                for (const cb of sub.cbs) {
                    try {
                        cb(id, fileName, size);
                    }
                    catch (e) {
                        console.error(`Error by callback of fileChange: ${e}`);
                    }
                }
            }
        }
    }
    /**
     * Subscribe to changes of the files.
     *
     * @param id The ioBroker state ID for meta-object. Could be a pattern
     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
     * @param cb The callback.
     */
    async subscribeFiles(
    /** The ioBroker state ID for meta-object. Could be a pattern */
    id, 
    /** Pattern or file name, like 'main/*' or 'main/visViews.json` */
    filePattern, 
    /** The callback. */
    cb) {
        if (typeof cb !== 'function') {
            throw new Error('The state change handler must be a function!');
        }
        let filePatterns;
        if (Array.isArray(filePattern)) {
            filePatterns = filePattern;
        }
        else {
            filePatterns = [filePattern];
        }
        const toSubscribe = [];
        for (let f = 0; f < filePatterns.length; f++) {
            const pattern = filePatterns[f];
            const key = `${id}$%$${pattern}`;
            if (!this.filesSubscribes[key]) {
                this.filesSubscribes[key] = {
                    regId: new RegExp(pattern2RegEx(id)),
                    regFilePattern: new RegExp(pattern2RegEx(pattern)),
                    cbs: [cb],
                };
                toSubscribe.push(pattern);
            }
            else {
                !this.filesSubscribes[key].cbs.includes(cb) && this.filesSubscribes[key].cbs.push(cb);
            }
        }
        if (this.connected && toSubscribe.length) {
            this._socket.emit('subscribeFiles', id, toSubscribe);
        }
        return Promise.resolve();
    }
    /**
     * Unsubscribes the given callback from changes of files.
     *
     * @param id The ioBroker state ID.
     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
     * @param cb The callback.
     */
    unsubscribeFiles(id, filePattern, cb) {
        let filePatterns;
        if (Array.isArray(filePattern)) {
            filePatterns = filePattern;
        }
        else {
            filePatterns = [filePattern];
        }
        const toUnsubscribe = [];
        for (let f = 0; f < filePatterns.length; f++) {
            const pattern = filePatterns[f];
            const key = `${id}$%$${pattern}`;
            if (this.filesSubscribes[key]) {
                const sub = this.filesSubscribes[key];
                if (cb) {
                    const pos = sub.cbs.indexOf(cb);
                    pos !== -1 && sub.cbs.splice(pos, 1);
                }
                else {
                    sub.cbs = [];
                }
                if (!sub.cbs?.length) {
                    delete this.filesSubscribes[key];
                    if (this.connected) {
                        toUnsubscribe.push(pattern);
                    }
                }
            }
        }
        if (this.connected && toUnsubscribe.length) {
            this._socket.emit('unsubscribeFiles', id, toUnsubscribe);
        }
    }
    /**
     * Called internally.
     */
    objectChange(id, obj) {
        // update main.objects cache
        if (!this.objects) {
            return;
        }
        let oldObj;
        let changed = false;
        if (obj) {
            if (this.objects[id]) {
                // @ts-expect-error fix later
                oldObj = { _id: id, type: this.objects[id].type };
            }
            if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {
                this.objects[id] = obj;
                changed = true;
            }
        }
        else if (this.objects[id]) {
            // @ts-expect-error fix later
            oldObj = { _id: id, type: this.objects[id].type };
            delete this.objects[id];
            changed = true;
        }
        Object.keys(this.objectsSubscribes).forEach(_id => {
            if (_id === id || this.objectsSubscribes[_id].reg.test(id)) {
                this.objectsSubscribes[_id].cbs.forEach(cb => {
                    try {
                        cb(id, obj, oldObj);
                    }
                    catch (e) {
                        console.error(`Error by callback of objectChange: ${e}`);
                    }
                });
            }
        });
        if (changed && this.props.onObjectChange) {
            void this.props.onObjectChange(id, obj);
        }
    }
    /**
     * Called internally.
     */
    stateChange(id, state) {
        for (const task in this.statesSubscribes) {
            if (Object.prototype.hasOwnProperty.call(this.statesSubscribes, task) &&
                this.statesSubscribes[task].reg.test(id)) {
                this.statesSubscribes[task].cbs.forEach(cb => {
                    try {
                        void cb(id, state);
                    }
                    catch (e) {
                        const knownError = e;
                        console.error(`Error by callback of stateChange: ${knownError?.message}`);
                    }
                });
            }
        }
    }
    /**
     * Called internally.
     *
     * @param messageType The message type
     * @param sourceInstance The source instance
     * @param data Payload
     */
    instanceMessage(messageType, sourceInstance, data) {
        if (this._instanceSubscriptions[sourceInstance]) {
            this._instanceSubscriptions[sourceInstance].forEach(sub => {
                if (sub.messageType === messageType) {
                    sub.callback(data, sourceInstance, messageType);
                }
            });
        }
    }
    /**
     * Gets all states.
     *
     * @param pattern The pattern to filter states
     * @param disableProgressUpdate Don't call onProgress() when done
     */
    getStates(pattern, disableProgressUpdate) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (typeof pattern === 'boolean') {
            disableProgressUpdate = pattern;
            pattern = undefined;
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getStates', pattern, (err, res) => {
                this.states = res;
                !disableProgressUpdate && this.onProgress(PROGRESS.STATES_LOADED);
                err ? reject(new Error(err)) : resolve(this.states);
            });
        });
    }
    /**
     * Gets the given state.
     *
     * @param id The state ID
     */
    getState(id) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (id && id === this.ignoreState) {
            return Promise.resolve(this.simStates[id] || { val: null, ack: true });
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getState', id, (err, state) => err ? reject(new Error(err)) : resolve(state));
        });
    }
    /**
     * Get the given binary state.
     *
     * @deprecated since js-controller 5.0. Use files instead.
     * @param id The state ID.
     */
    getBinaryState(id) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        // the data will come in base64
        return new Promise((resolve, reject) => {
            this._socket.emit('getBinaryState', id, (err, base64) => err ? reject(new Error(err)) : resolve(base64));
        });
    }
    /**
     * Set the given binary state.
     *
     * @deprecated since js-controller 5.0. Use files instead.
     * @param id The state ID.
     * @param base64 The Base64 encoded binary data.
     */
    setBinaryState(id, base64) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        // the data will come in base64
        return new Promise((resolve, reject) => {
            this._socket.emit('setBinaryState', id, base64, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Sets the given state value.
     *
     * @param id The state ID
     * @param val The state value
     * @param ack The acknowledgment flag
     */
    setState(id, val, ack) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        // extra handling for "nothing_selected" state for vis
        if (id && id === this.ignoreState) {
            let state;
            if (typeof ack === 'boolean') {
                state = val;
            }
            else if (typeof val === 'object' && val.val !== undefined) {
                state = val;
            }
            else {
                state = {
                    val: val,
                    ack: false,
                    ts: Date.now(),
                    lc: Date.now(),
                    from: 'system.adapter.vis.0',
                };
            }
            this.simStates[id] = state;
            // inform subscribers about changes
            if (this.statesSubscribes[id]) {
                for (const cb of this.statesSubscribes[id].cbs) {
                    try {
                        void cb(id, state);
                    }
                    catch (e) {
                        console.error(`Error by callback of stateChanged: ${e}`);
                    }
                }
            }
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('setState', id, val, (err) => (err ? reject(new Error(err)) : resolve()));
        });
    }
    /**
     * Gets all objects.
     *
     * @param update Set to true to retrieve all objects from the server (instead of using the local cache)
     * @param disableProgressUpdate Don't call onProgress() when done
     */
    getObjects(update, disableProgressUpdate) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            if (!update && this.objects) {
                resolve(this.objects);
            }
            else {
                this._socket.emit(LegacyConnection.isWeb() ? 'getObjects' : 'getAllObjects', (err, res) => {
                    this.objects = res;
                    disableProgressUpdate && this.onProgress(PROGRESS.OBJECTS_LOADED);
                    err ? reject(new Error(err)) : resolve(this.objects);
                });
            }
        });
    }
    /**
     * Gets objects by list of IDs.
     *
     * @param list Array of object IDs to retrieve
     */
    getObjectsById(list) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getObjects', list, (err, res) => err ? reject(new Error(err)) : resolve(res));
        });
    }
    /**
     * Called internally.
     */
    _subscribe(isEnable) {
        if (isEnable && !this.subscribed) {
            this.subscribed = true;
            this.autoSubscribes.forEach(id => this._socket.emit('subscribeObjects', id));
            // re-subscribe objects
            Object.keys(this.objectsSubscribes).forEach(id => this._socket.emit('subscribeObjects', id));
            // re-subscribe logs
            this.autoSubscribeLog && this._socket.emit('requireLog', true);
            // re-subscribe states
            const ids = Object.keys(this.statesSubscribes);
            ids.forEach(id => this._socket.emit('subscribe', id));
            ids.length &&
                this._socket.emit(LegacyConnection.isWeb() ? 'getStates' : 'getForeignStates', ids, (err, states) => {
                    err && console.error(`Cannot getForeignStates: ${JSON.stringify(err)}`);
                    // inform about states
                    states && Object.keys(states).forEach(id => this.stateChange(id, states[id]));
                });
        }
        else if (!isEnable && this.subscribed) {
            this.subscribed = false;
            // un-subscribe objects
            this.autoSubscribes.forEach(id => this._socket.emit('unsubscribeObjects', id));
            Object.keys(this.objectsSubscribes).forEach(id => this._socket.emit('unsubscribeObjects', id));
            // un-subscribe logs
            this.autoSubscribeLog && this._socket.emit('requireLog', false);
            // un-subscribe states
            Object.keys(this.statesSubscribes).forEach(id => this._socket.emit('unsubscribe', id));
        }
    }
    /**
     * Requests log updates.
     *
     * @param isEnabled Set to true to get logs
     */
    requireLog(isEnabled) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('requireLog', isEnabled, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Deletes the given object.
     *
     * @param id The object ID
     * @param maintenance Force deletion of non-conform IDs
     */
    delObject(id, maintenance) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('delObject', id, { maintenance: !!maintenance }, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Deletes the given object and all its children.
     *
     * @param id The object ID
     * @param maintenance Force deletion of non-conform IDs
     */
    delObjects(id, maintenance) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('delObjects', id, { maintenance: !!maintenance }, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Sets the object.
     */
    setObject(id, obj) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!obj) {
            return Promise.reject(new Error('Null object is not allowed'));
        }
        obj = JSON.parse(JSON.stringify(obj));
        if (Object.prototype.hasOwnProperty.call(obj, 'from')) {
            delete obj.from;
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'user')) {
            delete obj.user;
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'ts')) {
            delete obj.ts;
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('setObject', id, obj, (err) => (err ? reject(new Error(err)) : resolve()));
        });
    }
    /**
     * Gets the object with the given id from the server.
     */
    getObject(id) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (id && id === this.ignoreState) {
            return Promise.resolve({
                _id: this.ignoreState,
                type: 'state',
                common: {
                    name: 'ignored state',
                    type: 'mixed',
                    read: true,
                    write: true,
                    role: 'state',
                },
                native: {},
            });
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getObject', id, (err, obj) => err ? reject(new Error(err)) : resolve(obj));
        });
    }
    /**
     * Get all instances of the given adapter or all instances of all adapters.
     *
     * @param adapter The name of the adapter
     * @param update Force update
     */
    getAdapterInstances(adapter, update) {
        if (typeof adapter === 'boolean') {
            update = adapter;
            adapter = '';
        }
        adapter ||= '';
        if (!update && this._promises[`instances_${adapter}`] instanceof Promise) {
            return this._promises[`instances_${adapter}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`instances_${adapter}`] = new Promise((resolve, reject) => {
            this._socket.emit('getAdapterInstances', adapter, (err, instances) => err ? reject(new Error(err)) : resolve(instances));
        });
        return this._promises[`instances_${adapter}`];
    }
    /**
     * Get adapters with the given name or all adapters.
     *
     * @param adapter The name of the adapter
     * @param update Force update
     */
    getAdapters(adapter, update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (typeof adapter === 'boolean') {
            update = adapter;
            adapter = '';
        }
        adapter ||= '';
        if (!update && this._promises[`adapter_${adapter}`] instanceof Promise) {
            return this._promises[`adapter_${adapter}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`adapter_${adapter}`] = new Promise((resolve, reject) => {
            this._socket.emit('getAdapters', adapter, (err, adapters) => {
                err ? reject(new Error(err)) : resolve(adapters);
            });
        });
        return this._promises[`adapter_${adapter}`];
    }
    /**
     * Called internally.
     */
    _renameGroups(objs, cb) {
        if (!objs?.length) {
            cb?.(null);
        }
        else {
            const obj = objs.pop();
            if (!obj) {
                setTimeout(() => this._renameGroups(objs, cb), 0);
                return;
            }
            const oldId = obj._id;
            obj._id = obj.newId;
            delete obj.newId;
            this.setObject(obj._id, obj)
                .then(() => this.delObject(oldId))
                .then(() => setTimeout(() => this._renameGroups(objs, cb), 0))
                .catch((err) => cb?.(err));
        }
    }
    /**
     * Rename a group.
     *
     * @param id The id.
     * @param newId The new id.
     * @param newName The new name.
     */
    async renameGroup(id, newId, newName) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        const groups = await this.getGroups(true);
        if (groups.length) {
            // find all elements
            const groupsToRename = groups.filter(group => group._id.startsWith(`${id}.`));
            groupsToRename.forEach(group => {
                group.newId = (newId + group._id.substring(id.length));
            });
            await new Promise((resolve, reject) => {
                this._renameGroups(groupsToRename, (err) => err ? reject(new Error(err)) : resolve(null));
            });
            const obj = groups.find(group => group._id === id);
            if (obj) {
                obj._id = newId;
                if (newName !== undefined) {
                    obj.common ||= {};
                    obj.common.name = newName;
                }
                return this.setObject(obj._id, obj).then(() => this.delObject(id));
            }
        }
        return Promise.resolve();
    }
    /**
     * Sends a message to a specific instance or all instances of some specific adapter.
     *
     * @param instance The instance to send this message to.
     * @param command Command name of the target instance.
     * @param data The message data to send.
     */
    sendTo(instance, command, data) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise(resolve => {
            this._socket.emit('sendTo', instance, command, data, (result) => resolve(result));
        });
    }
    /**
     * Extend an object and create it if it might not exist.
     *
     * @param id The id.
     * @param obj The object.
     */
    extendObject(id, obj) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        obj = JSON.parse(JSON.stringify(obj));
        if (Object.prototype.hasOwnProperty.call(obj, 'from')) {
            delete obj.from;
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'user')) {
            delete obj.user;
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'ts')) {
            delete obj.ts;
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('extendObject', id, obj, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Register a handler for log messages.
     */
    registerLogHandler(handler) {
        !this.onLogHandlers.includes(handler) && this.onLogHandlers.push(handler);
    }
    /**
     * Unregister a handler for log messages.
     */
    unregisterLogHandler(handler) {
        const pos = this.onLogHandlers.indexOf(handler);
        pos !== -1 && this.onLogHandlers.splice(pos, 1);
    }
    /**
     * Register a handler for the connection state.
     */
    registerConnectionHandler(handler) {
        !this.onConnectionHandlers.includes(handler) && this.onConnectionHandlers.push(handler);
    }
    /**
     * Unregister a handler for the connection state.
     */
    unregisterConnectionHandler(handler) {
        const pos = this.onConnectionHandlers.indexOf(handler);
        pos !== -1 && this.onConnectionHandlers.splice(pos, 1);
    }
    /**
     * Set the handler for standard output of a command.
     *
     * @param handler The handler.
     */
    registerCmdStdoutHandler(handler) {
        this.onCmdStdoutHandler = handler;
    }
    /**
     * Unset the handler for standard output of a command.
     */
    unregisterCmdStdoutHandler( /* handler */) {
        this.onCmdStdoutHandler = undefined;
    }
    /**
     * Set the handler for standard error of a command.
     *
     * @param handler The handler.
     */
    registerCmdStderrHandler(handler) {
        this.onCmdStderrHandler = handler;
    }
    /**
     * Unset the handler for standard error of a command.
     */
    unregisterCmdStderrHandler() {
        this.onCmdStderrHandler = undefined;
    }
    /**
     * Set the handler for exit of a command.
     */
    registerCmdExitHandler(handler) {
        this.onCmdExitHandler = handler;
    }
    /**
     * Unset the handler for exit of a command.
     */
    unregisterCmdExitHandler() {
        this.onCmdExitHandler = undefined;
    }
    /**
     * Get all enums with the given name.
     */
    getEnums(
    /** The name of the enum. */
    _enum, 
    /** Force update. */
    update) {
        if (!update && this._promises[`enums_${_enum || 'all'}`] instanceof Promise) {
            return this._promises[`enums_${_enum || 'all'}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`enums_${_enum || 'all'}`] = new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', 'system', 'enum', { startkey: `enum.${_enum || ''}`, endkey: `enum.${_enum ? `${_enum}.` : ''}\u9999` }, (err, res) => {
                if (!err && res) {
                    const _res = {};
                    for (let i = 0; i < res.rows.length; i++) {
                        if (_enum && res.rows[i].id === `enum.${_enum}`) {
                            continue;
                        }
                        _res[res.rows[i].id] = res.rows[i].value;
                    }
                    resolve(_res);
                }
                else if (err) {
                    reject(new Error(err));
                }
                else {
                    reject(new Error('Invalid response while getting enums'));
                }
            });
        });
        return this._promises[`enums_${_enum || 'all'}`];
    }
    /**
     * Query a predefined object view.
     *
     * @param design design - 'system' or other designs like `custom`.
     * @param type The type of object.
     * @param start The start ID.
     * @param end The end ID.
     */
    getObjectViewCustom(
    /** The design: 'system' or other designs like `custom`. */
    design, 
    /** The type of object. */
    type, 
    /** The start ID. */
    start, 
    /** The end ID. */
    end) {
        return new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', design, type, { startkey: start, endkey: end }, (err, res) => {
                if (!err) {
                    const _res = {};
                    if (res && res.rows) {
                        for (let i = 0; i < res.rows.length; i++) {
                            _res[res.rows[i].id] = res.rows[i].value;
                        }
                    }
                    resolve(_res);
                }
                else {
                    reject(new Error(err));
                }
            });
        });
    }
    /**
     * Query a predefined object view.
     *
     * @param type The type of object.
     * @param start The start ID.
     * @param end The end ID.
     */
    async getObjectViewSystem(type, start, end) {
        const key = `${type}_${start || ''}_${end || ''}`;
        const result = await this.getObjectViewCustom('system', type, start, end);
        if (this.objectViewCached?.[key]) {
            // update cached value
            this.objectViewCached[key] = result;
        }
        return result;
    }
    /**
     * Query a predefined object view.
     *
     * @param type The type of object.
     * @param start The start ID.
     * @param [end] The end ID.
     */
    async getObjectViewSystemCached(type, start, end) {
        const key = `${type}_${start || ''}_${end || ''}`;
        if (this.objectViewCached?.[key]) {
            return Promise.resolve(this.objectViewCached[key]);
        }
        const result = await this.getObjectViewCustom('system', type, start, end);
        this.objectViewCached ||= {};
        this.objectViewCached[key] = result;
        return result;
    }
    /**
     * @deprecated since version 1.1.15, cause parameter order does not match backend
     *
     * Query a predefined object view.
     * @param start The start ID.
     * @param end The end ID.
     * @param type The type of object.
     */
    getObjectView(start, end, type) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        start ||= '';
        end ||= '\u9999';
        return this.getObjectViewCustom('system', type, start, end);
    }
    /**
     * Get the stored certificates.
     *
     * @param update Force update.
     */
    getCertificates(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (this._promises.cert instanceof Promise && !update) {
            return this._promises.cert;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.cert = this.getObject('system.certificates').then(res => {
            const certs = [];
            if (res && res.native && res.native.certificates) {
                Object.keys(res.native.certificates).forEach(c => {
                    const cert = res.native.certificates[c];
                    if (!cert) {
                        return;
                    }
                    const _cert = {
                        name: c,
                        type: '',
                    };
                    // If it is a filename, it could be everything
                    if (cert.length < 700 && (cert.includes('/') || cert.includes('\\'))) {
                        if (c.toLowerCase().includes('private')) {
                            _cert.type = 'private';
                        }
                        else if (cert.toLowerCase().includes('private')) {
                            _cert.type = 'private';
                        }
                        else if (c.toLowerCase().includes('public')) {
                            _cert.type = 'public';
                        }
                        else if (cert.toLowerCase().includes('public')) {
                            _cert.type = 'public';
                        }
                        certs.push(_cert);
                    }
                    else {
                        _cert.type =
                            cert.substring(0, '-----BEGIN RSA PRIVATE KEY'.length) === '-----BEGIN RSA PRIVATE KEY' ||
                                cert.substring(0, '-----BEGIN PRIVATE KEY'.length) === '-----BEGIN PRIVATE KEY'
                                ? 'private'
                                : 'public';
                        if (_cert.type === 'public') {
                            const m = cert.split('-----END CERTIFICATE-----');
                            if (m.filter((t) => t.replace(/\r\n|\r|\n/, '').trim()).length > 1) {
                                _cert.type = 'chained';
                            }
                        }
                        certs.push(_cert);
                    }
                });
            }
            return certs;
        });
        return this._promises.cert;
    }
    /**
     * Get the logs from a host (only for admin connection).
     */
    getLogs(host, linesNumber) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise(resolve => {
            this._socket.emit('sendToHost', host, 'getLogs', linesNumber || 200, (lines) => resolve(lines));
        });
    }
    /**
     * Get the log files (only for admin connection).
     */
    getLogsFiles(host) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('readLogs', host, (err, files) => err ? reject(new Error(err)) : resolve(files));
        });
    }
    /**
     * Delete the logs from a host (only for admin connection).
     */
    delLogs(host) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('sendToHost', host, 'delLogs', null, (error) => error ? reject(new Error(error)) : resolve());
        });
    }
    /**
     * Read the meta items.
     */
    readMetaItems() {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', 'system', 'meta', { startkey: '', endkey: '\u9999' }, (err, objs) => err
                ? reject(new Error(err))
                : resolve(objs.rows &&
                    objs.rows.map((obj) => obj.value)));
        });
    }
    /**
     * Read the directory of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The directory name.
     */
    readDir(adapter, fileName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('readDir', adapter, fileName, (err, files) => err ? reject(new Error(err)) : resolve(files));
        });
    }
    /**
     * Read a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     * @param base64 If it must be a base64 format.
     */
    readFile(adapter, fileName, base64) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            if (!base64) {
                this._socket.emit('readFile', adapter, fileName, (err, data, type) => {
                    err ? reject(new Error(err)) : resolve({ data, type });
                });
            }
            else {
                this._socket.emit('readFile64', adapter, fileName, base64, (err, data) => err ? reject(new Error(err)) : resolve(data));
            }
        });
    }
    /**
     * Write a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     * @param data The data (if it's a Buffer, it will be converted to Base64)
     */
    writeFile64(adapter, fileName, data) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            if (typeof data === 'string') {
                this._socket.emit('writeFile', adapter, fileName, data, (err) => err ? reject(new Error(err)) : resolve());
            }
            else {
                const base64 = btoa(new Uint8Array(data).reduce((_data, byte) => _data + String.fromCharCode(byte), ''));
                this._socket.emit('writeFile64', adapter, fileName, base64, (err) => err ? reject(new Error(err)) : resolve());
            }
        });
    }
    /**
     * Delete a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     */
    deleteFile(adapter, fileName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('unlink', adapter, fileName, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Delete a folder of an adapter.
     * All files in folder will be deleted.
     *
     * @param adapter The adapter name.
     * @param folderName The folder name.
     */
    deleteFolder(adapter, folderName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('deleteFolder', adapter, folderName, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Get the list of all hosts.
     *
     * @param update Force update.
     */
    getHosts(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.hosts instanceof Promise) {
            return this._promises.hosts;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.hosts = new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', 'system', 'host', { startkey: 'system.host.', endkey: 'system.host.\u9999' }, (err, doc) => {
                if (err) {
                    reject(new Error(err));
                }
                else {
                    resolve(doc.rows.map(item => item.value));
                }
            });
        });
        return this._promises.hosts;
    }
    /**
     * Get the list of all users.
     *
     * @param update Force update.
     */
    getUsers(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.users instanceof Promise) {
            return this._promises.users;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.users = new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', 'system', 'user', { startkey: 'system.user.', endkey: 'system.user.\u9999' }, (err, doc) => {
                if (err) {
                    reject(new Error(err));
                }
                else {
                    resolve(doc.rows.map(item => item.value));
                }
            });
        });
        return this._promises.users;
    }
    /**
     * Get the list of all groups.
     *
     * @param update Force update.
     */
    getGroups(update) {
        if (!update && this._promises.groups instanceof Promise) {
            return this._promises.groups;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.groups = new Promise((resolve, reject) => {
            this._socket.emit('getObjectView', 'system', 'group', { startkey: 'system.group.', endkey: 'system.group.\u9999' }, (err, doc) => {
                if (err) {
                    reject(new Error(err));
                }
                else {
                    resolve(doc.rows.map(item => item.value));
                }
            });
        });
        return this._promises.groups;
    }
    /**
     * Get the host information.
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs Optional read timeout.
     */
    getHostInfo(host, update, timeoutMs) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        if (!update && this._promises[`hostInfo_${host}`] instanceof Promise) {
            return this._promises[`hostInfo_${host}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`hostInfo_${host}`] = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getHostInfo timeout'));
                }
            }, timeoutMs || this.props.cmdTimeout);
            this._socket.emit('sendToHost', host, 'getHostInfo', null, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getHostInfo"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getHostInfo"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises[`hostInfo_${host}`];
    }
    /**
     * Get the host information (short version).
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs Optional read timeout.
     */
    getHostInfoShort(host, update, timeoutMs) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        if (!update && this._promises[`hostInfoShort_${host}`] instanceof Promise) {
            return this._promises[`hostInfoShort_${host}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`hostInfoShort_${host}`] = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('hostInfoShort timeout'));
                }
            }, timeoutMs || this.props.cmdTimeout);
            this._socket.emit('sendToHost', host, 'getHostInfoShort', null, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getHostInfoShort"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getHostInfoShort"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises[`hostInfoShort_${host}`];
    }
    /**
     * Get the repository.
     *
     * @param host The host name.
     * @param options Options.
     * @param update Force update.
     * @param timeoutMs Timeout in ms.
     */
    getRepository(host, options, update, timeoutMs) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.repo instanceof Promise) {
            return this._promises.repo;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        this._promises.repo = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getRepository timeout'));
                }
            }, timeoutMs || this.props.cmdTimeout);
            this._socket.emit('sendToHost', host, 'getRepository', options, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getRepository"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getRepository"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises.repo;
    }
    /**
     * Get the installed.
     *
     * @param host The host name.
     * @param update Force update.
     * @param cmdTimeout Timeout in ms.
     */
    getInstalled(host, update, cmdTimeout) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        this._promises.installed = this._promises.installed || {};
        if (!update && this._promises.installed[host] instanceof Promise) {
            return this._promises.installed[host];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        this._promises.installed[host] = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getInstalled timeout'));
                }
            }, cmdTimeout || this.props.cmdTimeout);
            this._socket.emit('sendToHost', host, 'getInstalled', null, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getInstalled"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getInstalled"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises.installed[host];
    }
    /**
     * Rename file or folder in ioBroker DB
     *
     * @param adapter Instance name, like `vis-2.0`.
     * @param oldName The current file name, e.g., main/vis-views.json
     * @param newName The new file name, e.g., main/vis-views-new.json
     */
    rename(adapter, oldName, newName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('rename', adapter, oldName, newName, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Rename file in ioBroker DB
     */
    renameFile(
    /** instance name */
    adapter, 
    /** current file name, e.g., main/vis-views.json */
    oldName, 
    /** new file name, e.g., main/vis-views-new.json */
    newName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('renameFile', adapter, oldName, newName, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Execute a command on a host.
     */
    cmdExec(
    /** The host name. */
    host, 
    /** The command. */
    cmd, 
    /** The command ID. */
    cmdId, 
    /** Timeout of command in ms */
    cmdTimeout) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!host.startsWith(host)) {
            host += `system.host.${host}`;
        }
        return new Promise((resolve, reject) => {
            let timeout = cmdTimeout
                ? setTimeout(() => {
                    if (timeout) {
                        timeout = null;
                        reject(new Error('cmdExec timeout'));
                    }
                }, cmdTimeout)
                : null;
            this._socket.emit('cmdExec', host, cmdId, cmd, null, (err) => {
                if (!cmdTimeout || timeout) {
                    timeout && clearTimeout(timeout);
                    timeout = null;
                    if (err) {
                        reject(new Error(err));
                    }
                    else {
                        resolve();
                    }
                }
            });
        });
    }
    /**
     * Checks if a given feature is supported.
     */
    checkFeatureSupported(
    /** The feature to check. */
    feature, 
    /** Force update. */
    update) {
        if (!update && this._promises[`supportedFeatures_${feature}`] instanceof Promise) {
            return this._promises[`supportedFeatures_${feature}`];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises[`supportedFeatures_${feature}`] = new Promise((resolve, reject) => {
            this._socket.emit('checkFeatureSupported', feature, (err, supported) => err ? reject(new Error(err)) : resolve(supported));
        });
        return this._promises[`supportedFeatures_${feature}`];
    }
    /**
     * Read the base settings of a given host.
     */
    async readBaseSettings(host) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        const result = await this.checkFeatureSupported('CONTROLLER_READWRITE_BASE_SETTINGS');
        if (result) {
            if (!this.connected) {
                return Promise.reject(new Error(NOT_CONNECTED));
            }
            return new Promise((resolve, reject) => {
                let timeout = setTimeout(() => {
                    if (timeout) {
                        timeout = null;
                        reject(new Error('readBaseSettings timeout'));
                    }
                }, this.props.cmdTimeout);
                if (host.startsWith('system.host.')) {
                    host = host.replace(/^system\.host\./, '');
                }
                this._socket.emit('sendToHost', host, 'readBaseSettings', null, (data) => {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                        if (data === PERMISSION_ERROR) {
                            reject(new Error('May not read "BaseSettings"'));
                        }
                        else if (!data || typeof data !== 'object') {
                            reject(new Error('Cannot read "BaseSettings"'));
                        }
                        else {
                            resolve(data);
                        }
                    }
                });
            });
        }
        return Promise.reject(new Error('Not supported'));
    }
    /**
     * Write the base settings of a given host.
     *
     * @param host The host name.
     * @param config The new base settings.
     */
    writeBaseSettings(host, config) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return this.checkFeatureSupported('CONTROLLER_READWRITE_BASE_SETTINGS').then(result => {
            if (result) {
                if (!this.connected) {
                    return Promise.reject(new Error(NOT_CONNECTED));
                }
                return new Promise((resolve, reject) => {
                    let timeout = setTimeout(() => {
                        if (timeout) {
                            timeout = null;
                            reject(new Error('writeBaseSettings timeout'));
                        }
                    }, this.props.cmdTimeout);
                    this._socket.emit('sendToHost', host, 'writeBaseSettings', config, (data) => {
                        if (timeout) {
                            clearTimeout(timeout);
                            timeout = null;
                            if (data === PERMISSION_ERROR) {
                                reject(new Error('May not write "BaseSettings"'));
                            }
                            else if (!data) {
                                reject(new Error('Cannot write "BaseSettings"'));
                            }
                            else {
                                resolve(data);
                            }
                        }
                    });
                });
            }
            return Promise.reject(new Error('Not supported'));
        });
    }
    /**
     * Send command to restart the iobroker on host
     */
    restartController(host) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('sendToHost', host, 'restartController', null, (error) => {
                error ? reject(new Error(error)) : resolve(true);
            });
        });
    }
    /**
     * Read statistics information from host
     *
     * @param host Host name
     * @param typeOfDiag one of none, normal, no-city, extended
     */
    getDiagData(host, typeOfDiag) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return new Promise(resolve => {
            this._socket.emit('sendToHost', host, 'getDiagData', typeOfDiag, (result) => resolve(result));
        });
    }
    /**
     * Read all states (which might not belong to this adapter) which match the given pattern.
     */
    getForeignStates(pattern) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (LegacyConnection.isWeb()) {
            return new Promise((resolve, reject) => {
                this._socket.emit('getStates', pattern || '*', (err, states) => err ? reject(new Error(err)) : resolve(states));
            });
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getForeignStates', pattern || '*', (err, states) => err ? reject(new Error(err)) : resolve(states));
        });
    }
    /**
     * Get foreign objects by pattern, by specific type and resolve their enums. (Only admin)
     */
    getForeignObjects(pattern, type) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getForeignObjects', pattern || '*', type, (err, states) => err ? reject(new Error(err)) : resolve(states));
        });
    }
    /**
     * Gets the system configuration.
     *
     * @param update Force update.
     */
    getSystemConfig(update) {
        if (!update && this._promises.systemConfig instanceof Promise) {
            return this._promises.systemConfig;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.systemConfig = this.getObject('system.config').then(obj => {
            const systemConfig = (obj || {});
            systemConfig.common ||= {};
            systemConfig.native ||= {};
            return systemConfig;
        });
        return this._promises.systemConfig;
    }
    /**
     * Sets the system configuration.
     */
    setSystemConfig(obj) {
        return this.setObject('system.config', obj).then(() => (this._promises.systemConfig = Promise.resolve(obj)));
    }
    /**
     * Get the raw socket.io socket.
     */
    getRawSocket() {
        return this._socket;
    }
    /**
     * Get the history of a given state.
     */
    getHistory(id, options) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getHistory', id, options, (err, values) => err ? reject(new Error(err)) : resolve(values));
        });
    }
    /**
     * Get the history of a given state.
     */
    getHistoryEx(id, options) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getHistory', id, options, (err, values, step, sessionId) => err ? reject(new Error(err)) : resolve({ values, sessionId, step }));
        });
    }
    /**
     * Change the password of the given user.
     */
    changePassword(user, password) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('changePassword', user, password, (err) => err ? reject(new Error(err)) : resolve());
        });
    }
    /**
     * Get the IP addresses of the given host.
     */
    getIpAddresses(host, 
    /** Force update. */
    update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!host.startsWith('system.host.')) {
            host = `system.host.${host}`;
        }
        if (!update && this._promises[`IPs_${host}`] instanceof Promise) {
            return this._promises[`IPs_${host}`];
        }
        this._promises[`IPs_${host}`] = this.getObject(host).then(obj => (obj?.common ? obj.common.address || [] : []));
        return this._promises[`IPs_${host}`];
    }
    /**
     * Get the IP addresses with interface names of the given host or find host by IP.
     */
    getHostByIp(ipOrHostName, 
    /** Force update. */
    update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (ipOrHostName.startsWith('system.host.')) {
            ipOrHostName = ipOrHostName.replace(/^system\.host\./, '');
        }
        if (!update && this._promises[`rIPs_${ipOrHostName}`] instanceof Promise) {
            return this._promises[`rIPs_${ipOrHostName}`];
        }
        this._promises[`rIPs_${ipOrHostName}`] = new Promise(resolve => {
            this._socket.emit('getHostByIp', ipOrHostName, (_ip, host) => {
                const IPs4 = [{ name: '[IPv4] 0.0.0.0 - Listen on all IPs', address: '0.0.0.0', family: 'ipv4' }];
                const IPs6 = [{ name: '[IPv6] :: - Listen on all IPs', address: '::', family: 'ipv6' }];
                if (host?.native?.hardware?.networkInterfaces) {
                    for (const eth in host.native.hardware.networkInterfaces) {
                        if (!Object.prototype.hasOwnProperty.call(host.native.hardware.networkInterfaces, eth)) {
                            continue;
                        }
                        for (let num = 0; num < host.native.hardware.networkInterfaces[eth].length; num++) {
                            if (host.native.hardware.networkInterfaces[eth][num].family !== 'IPv6') {
                                IPs4.push({
                                    name: `[${host.native.hardware.networkInterfaces[eth][num].family}] ${host.native.hardware.networkInterfaces[eth][num].address} - ${eth}`,
                                    address: host.native.hardware.networkInterfaces[eth][num].address,
                                    family: 'ipv4',
                                });
                            }
                            else {
                                IPs6.push({
                                    name: `[${host.native.hardware.networkInterfaces[eth][num].family}] ${host.native.hardware.networkInterfaces[eth][num].address} - ${eth}`,
                                    address: host.native.hardware.networkInterfaces[eth][num].address,
                                    family: 'ipv6',
                                });
                            }
                        }
                    }
                }
                for (let i = 0; i < IPs6.length; i++) {
                    IPs4.push(IPs6[i]);
                }
                resolve(IPs4);
            });
        });
        return this._promises[`rIPs_${ipOrHostName}`];
    }
    /**
     * Encrypt a text
     */
    encrypt(text) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('encrypt', text, (err, _text) => err ? reject(new Error(err)) : resolve(_text));
        });
    }
    /**
     * Decrypt a text
     */
    decrypt(encryptedText) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('decrypt', encryptedText, (err, text) => err ? reject(new Error(err)) : resolve(text));
        });
    }
    /**
     * Gets the version.
     */
    getVersion(update) {
        if (!update && this._promises.version instanceof Promise) {
            return this._promises.version;
        }
        this._promises.version = new Promise((resolve, reject) => {
            this._socket.emit('getVersion', (err, version, serverName) => {
                // support of old socket.io
                if (err && !version && typeof err === 'string' && err.match(/\d+\.\d+\.\d+/)) {
                    resolve({ version: err, serverName: 'socketio' });
                }
                else {
                    err ? reject(new Error(err)) : resolve({ version, serverName });
                }
            });
        });
        return this._promises.version;
    }
    /**
     * Gets the web server name.
     */
    getWebServerName() {
        if (this._promises.webName instanceof Promise) {
            return this._promises.webName;
        }
        this._promises.webName = new Promise((resolve, reject) => {
            this._socket.emit('getAdapterName', (err, name) => err ? reject(new Error(err)) : resolve(name));
        });
        return this._promises.webName;
    }
    /**
     * Gets the admin version.
     *
     * @deprecated use getVersion()
     */
    getAdminVersion() {
        console.log('Deprecated: use getVersion');
        return this.getVersion();
    }
    /**
     * Change access rights for a file
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     * @param options like {mode: 0x644}
     * @param options.mode Access rights. Default is 0x644
     */
    chmodFile(adapter, fileName, options) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('chmodFile', adapter, fileName, options, (err, entries, id) => err ? reject(new Error(err)) : resolve({ entries, id }));
        });
    }
    /**
     * Change an owner or/and owner group for a file
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     * @param options like {owner: 'user', ownerGroup: 'group'}
     * @param options.owner User name
     * @param options.ownerGroup Group name
     */
    chownFile(adapter, fileName, options) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('chownFile', adapter, fileName, options, (err, entries, id) => err ? reject(new Error(err)) : resolve({ entries, id }));
        });
    }
    /**
     * Check if the file exists
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     */
    fileExists(adapter, fileName) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('fileExists', adapter, fileName, (err, exists) => err ? reject(new Error(err)) : resolve(exists));
        });
    }
    /**
     * Get the alarm notifications from a host (only for admin connection).
     */
    getNotifications(host, category) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise(resolve => {
            this._socket.emit('sendToHost', host, 'getNotifications', { category }, (notifications) => resolve(notifications));
        });
    }
    /**
     * Clear the alarm notifications on a host (only for admin connection).
     *
     * @param host The host name.
     * @param category optional
     */
    clearNotifications(host, category) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise(resolve => {
            this._socket.emit('sendToHost', host, 'clearNotifications', { category }, (result) => resolve(result));
        });
    }
    /**
     * Read if only easy mode is allowed (only for admin connection).
     */
    getIsEasyModeStrict() {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getIsEasyModeStrict', (error, isStrict) => error ? reject(new Error(error)) : resolve(isStrict));
        });
    }
    /**
     * Read easy mode configuration (only for admin connection).
     */
    getEasyMode() {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getEasyMode', (error, config) => error ? reject(new Error(error)) : resolve(config));
        });
    }
    /**
     * Read current user
     */
    getCurrentUser() {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise(resolve => {
            this._socket.emit('authEnabled', (_isSecure, user) => resolve(user));
        });
    }
    getCurrentSession(cmdTimeout) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            const controller = new AbortController();
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    controller.abort();
                    reject(new Error('getCurrentSession timeout'));
                }
            }, cmdTimeout || 5000);
            fetch('./session', { signal: controller.signal })
                .then(res => res.json())
                .then(json => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    resolve(json);
                }
            })
                .catch(e => reject(new Error(`getCurrentSession: ${e}`)));
        });
    }
    /**
     * Read adapter ratings
     */
    getRatings(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('getRatings', update, (err, ratings) => err ? reject(new Error(err)) : resolve(ratings));
        });
    }
    /**
     * Read current web, socketio or admin namespace, like admin.0
     */
    getCurrentInstance() {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (this._promises.currentInstance instanceof Promise) {
            return this._promises.currentInstance;
        }
        this._promises.currentInstance = new Promise((resolve, reject) => {
            this._socket.emit('getCurrentInstance', (err, namespace) => err ? reject(new Error(err)) : resolve(namespace));
        });
        return this._promises.currentInstance;
    }
    // returns very optimized information for adapters to minimize a connection load
    getCompactAdapters(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.compactAdapters instanceof Promise) {
            return this._promises.compactAdapters;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.compactAdapters = new Promise((resolve, reject) => {
            this._socket.emit('getCompactAdapters', (err, adapters) => err ? reject(new Error(err)) : resolve(adapters));
        });
        return this._promises.compactAdapters;
    }
    getAdaptersResetCache(adapter) {
        adapter ||= '';
        delete this._promises.compactAdapters;
        delete this._promises[`adapter_${adapter}`];
    }
    // returns very optimized information for adapters to minimize a connection load
    getCompactInstances(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.compactInstances instanceof Promise) {
            return this._promises.compactInstances;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.compactInstances = new Promise((resolve, reject) => {
            this._socket.emit('getCompactInstances', (err, instances) => err ? reject(new Error(err)) : resolve(instances));
        });
        return this._promises.compactInstances;
    }
    getAdapternInstancesResetCache(adapter) {
        adapter ||= '';
        delete this._promises.compactInstances;
        delete this._promises[`instances_${adapter}`];
    }
    /**
     * Returns very optimized information for adapters to minimize a connection load.
     * Reads only version of installed adapter
     */
    getCompactInstalled(host, update, cmdTimeout) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        this._promises.installedCompact ||= {};
        if (!update && this._promises.installedCompact[host] instanceof Promise) {
            return this._promises.installedCompact[host];
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        this._promises.installedCompact[host] = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getCompactInstalled timeout'));
                }
            }, cmdTimeout || this.props.cmdTimeout);
            this._socket.emit('getCompactInstalled', host, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getCompactInstalled"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getCompactInstalled"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises.installedCompact[host];
    }
    // returns very optimized information for adapters to minimize a connection load.
    // reads only version of installed adapter
    getCompactSystemRepositories(update, cmdTimeout) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.getCompactSystemRepositories instanceof Promise) {
            return this._promises.getCompactSystemRepositories;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.getCompactSystemRepositories = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getCompactSystemRepositories timeout'));
                }
            }, cmdTimeout || this.props.cmdTimeout);
            this._socket.emit('getCompactSystemRepositories', (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getCompactSystemRepositories"'));
                    }
                    else if (!data || typeof data !== 'object') {
                        reject(new Error('Cannot read "getCompactSystemRepositories"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises.getCompactSystemRepositories;
    }
    // returns very optimized information for adapters to minimize a connection load
    getCompactSystemConfig(update) {
        if (!update && this._promises.systemConfigPromise instanceof Promise) {
            return this._promises.systemConfigPromise;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.systemConfigPromise = new Promise((resolve, reject) => {
            this._socket.emit('getCompactSystemConfig', (err, systemConfig) => err ? reject(new Error(err)) : resolve(systemConfig));
        });
        return this._promises.systemConfigPromise;
    }
    /**
     * Get the repository in compact form (only version and icon).
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs timeout in ms.
     */
    getCompactRepository(host, update, timeoutMs) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.repoCompact instanceof Promise) {
            return this._promises.repoCompact;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        if (!host.startsWith('system.host.')) {
            host += `system.host.${host}`;
        }
        this._promises.repoCompact = new Promise((resolve, reject) => {
            let timeout = setTimeout(() => {
                if (timeout) {
                    timeout = null;
                    reject(new Error('getCompactRepository timeout'));
                }
            }, timeoutMs || this.props.cmdTimeout);
            this._socket.emit('getCompactRepository', host, (data) => {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                    if (data === PERMISSION_ERROR) {
                        reject(new Error('May not read "getCompactRepository"'));
                    }
                    else if (!data) {
                        reject(new Error('Cannot read "getCompactRepository"'));
                    }
                    else {
                        resolve(data);
                    }
                }
            });
        });
        return this._promises.repoCompact;
    }
    getInstalledResetCache() {
        delete this._promises.repoCompact;
        delete this._promises.repo;
    }
    /**
     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)
     */
    getCompactHosts(update) {
        if (LegacyConnection.isWeb()) {
            return Promise.reject(new Error('Allowed only in admin'));
        }
        if (!update && this._promises.hostsCompact instanceof Promise) {
            return this._promises.hostsCompact;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.hostsCompact = new Promise((resolve, reject) => {
            this._socket.emit('getCompactHosts', (err, hosts) => err ? reject(new Error(err)) : resolve(hosts));
        });
        return this._promises.hostsCompact;
    }
    /**
     * Get uuid
     */
    getUuid() {
        if (this._promises.uuid instanceof Promise) {
            return this._promises.uuid;
        }
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        this._promises.uuid = this.getObject('system.meta.uuid').then(obj => obj?.native?.uuid);
        return this._promises.uuid;
    }
    /**
     * Subscribe on instance message
     *
     * @param targetInstance instance, like 'cameras.0'
     * @param  messageType message type like 'startCamera/cam3'
     * @param data optional data object
     * @param callback message handler
     */
    subscribeOnInstance(targetInstance, messageType, data, callback) {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('clientSubscribe', targetInstance, messageType, data, (err, result) => {
                if (err) {
                    reject(new Error(err));
                }
                else if (result?.error) {
                    reject(new Error(result.error));
                }
                else {
                    if (!targetInstance.startsWith('system.adapter.')) {
                        targetInstance = `system.adapter.${targetInstance}`;
                    }
                    // save callback
                    this._instanceSubscriptions[targetInstance] ||= [];
                    if (!this._instanceSubscriptions[targetInstance].find(sub => sub.messageType === messageType && sub.callback === callback)) {
                        this._instanceSubscriptions[targetInstance].push({
                            messageType,
                            callback,
                        });
                    }
                    resolve(result);
                }
            });
        });
    }
    /**
     * Unsubscribe from instance message
     *
     * @param targetInstance instance, like 'cameras.0'
     * @param messageType message type like 'startCamera/cam3'
     * @param callback message handler. Could be null if all callbacks for this messageType should be unsubscribed
     */
    unsubscribeFromInstance(targetInstance, messageType, callback) {
        if (!targetInstance.startsWith('system.adapter.')) {
            targetInstance = `system.adapter.${targetInstance}`;
        }
        let deleted;
        const promiseResults = [];
        do {
            deleted = false;
            const index = this._instanceSubscriptions[targetInstance]?.findIndex(sub => (!messageType || sub.messageType === messageType) && (!callback || sub.callback === callback));
            if (index !== undefined && index !== null && index !== -1) {
                deleted = true;
                // remember messageType
                const _messageType = this._instanceSubscriptions[targetInstance][index].messageType;
                this._instanceSubscriptions[targetInstance].splice(index, 1);
                if (!this._instanceSubscriptions[targetInstance].length) {
                    delete this._instanceSubscriptions[targetInstance];
                }
                // try to find another subscription for this instance and messageType
                const found = this._instanceSubscriptions[targetInstance] &&
                    this._instanceSubscriptions[targetInstance].find(sub => sub.messageType === _messageType);
                if (!found) {
                    promiseResults.push(new Promise((resolve, reject) => {
                        this._socket.emit('clientUnsubscribe', targetInstance, messageType, (err, wasSubscribed) => {
                            if (err) {
                                reject(new Error(err));
                            }
                            else {
                                resolve(wasSubscribed);
                            }
                        });
                    }));
                }
            }
        } while (deleted && (!callback || !messageType));
        if (promiseResults.length) {
            return Promise.all(promiseResults).then((results) => results.find(result => result) || false);
        }
        return Promise.resolve(false);
    }
    /**
     * Send log to ioBroker log
     */
    log(text, level) {
        if (text) {
            this._socket.emit('log', text, level || 'debug');
        }
    }
    /**
     * Logout current user
     */
    logout() {
        if (!this.connected) {
            return Promise.reject(new Error(NOT_CONNECTED));
        }
        return new Promise((resolve, reject) => {
            this._socket.emit('logout', (err) => (err ? reject(new Error(err)) : resolve()));
        });
    }
    /**
     * This is a special method for vis.
     * It is used to not send to server the changes about "nothing_selected" state
     *
     * @param id The state that has to be ignored by communication
     */
    setStateToIgnore(id) {
        this.ignoreState = id || '';
    }
}
//# sourceMappingURL=LegacyConnection.js.map