/**
 * Copyright 2020-2025, Denis Haev (bluefox) <dogafox@gmail.com>
 *
 * MIT License
 *
 */
import type { InstalledInfo, HostInfo } from '@iobroker/socket-client';
import type { IoBJson } from '@iobroker/types/build/config';
declare global {
    interface Window {
        adapterName: undefined | string;
        socketUrl: undefined | string;
        registerSocketOnLoad: (func: () => void) => void;
        vendorPrefix: undefined | string;
        io: any;
        iob: any;
    }
}
type LogMessage = {
    /** Log message */
    message: string;
    /** origin */
    from: string;
    /** timestamp in ms */
    ts: number;
    /** Log message */
    severity: ioBroker.LogLevel;
    /** unique ID of the message */
    _id: number;
};
export type Severity = 'info' | 'notify' | 'alert';
interface NotificationMessageObject {
    message: string;
    ts: number;
}
type MultilingualObject = Exclude<ioBroker.StringOrTranslated, string>;
export interface FilteredNotificationInformation {
    [scope: string]: {
        description: MultilingualObject;
        name: MultilingualObject;
        categories: {
            [category: string]: {
                description: MultilingualObject;
                name: MultilingualObject;
                severity: Severity;
                instances: {
                    [instance: string]: {
                        messages: NotificationMessageObject[];
                    };
                };
            };
        };
    };
}
export type CompactSystemRepositoryEntry = {
    link: string;
    hash?: string;
    stable?: boolean;
    json: {
        _repoInfo: {
            stable?: boolean;
            name?: ioBroker.StringOrTranslated;
        };
    } | null | undefined;
};
export type CompactSystemRepository = {
    _id: ioBroker.HostObject['_id'];
    common: {
        name: ioBroker.HostCommon['name'];
        dontDelete: boolean;
    };
    native: {
        repositories: Record<string, CompactSystemRepositoryEntry>;
    };
};
/** Possible progress states. */
export declare const PROGRESS: {
    /** The socket is connecting. */
    CONNECTING: number;
    /** The socket is successfully connected. */
    CONNECTED: number;
    /** All objects are loaded. */
    OBJECTS_LOADED: number;
    /** All states are loaded. */
    STATES_LOADED: number;
    /** The socket is ready for use. */
    READY: number;
};
export declare const ERRORS: {
    PERMISSION_ERROR: string;
    NOT_CONNECTED: string;
};
export type BinaryStateChangeHandler = (id: string, base64: string | null) => void;
/** Converts ioB pattern into regex */
export declare function pattern2RegEx(pattern: string): string;
interface ConnectionProps {
    /** The socket name. */
    name?: string;
    /** State IDs to always automatically subscribe to. */
    autoSubscribes?: string[];
    /** Automatically subscribe to logging. */
    autoSubscribeLog?: boolean;
    /** The protocol to use for the socket.io connection. */
    protocol: string;
    /** The host name to use for the socket.io connection. */
    host: string;
    /** The port to use for the socket.io connection. */
    port?: string | number;
    /** The socket.io connection timeout. */
    ioTimeout?: number;
    /** The socket.io command timeout. */
    cmdTimeout?: number;
    /** Flag to indicate if all objects should be loaded or not. Default true (not loaded) */
    doNotLoadAllObjects?: boolean;
    /** Flag to indicate if AccessControlList for current user will be loaded or not. Default true (not loaded) */
    doNotLoadACL?: boolean;
    /** Progress callback. */
    onProgress?: (progress: number) => void;
    /** Ready callback. */
    onReady?: (objects: Record<string, ioBroker.Object>) => void;
    /** Log callback. */
    onLog?: (message: LogMessage) => void;
    /** Error callback. */
    onError?: (error: any) => void;
    /** Object change callback. */
    onObjectChange?: ioBroker.ObjectChangeHandler;
    /** Gets called when the system language is determined */
    onLanguage?: (lang: ioBroker.Languages) => void;
    /** The device UUID with which the communication must be established */
    uuid?: string;
    /** Authentication token (used only in cloud) */
    token?: string;
}
export interface ConnectOptions {
    path?: string;
    query?: string;
    name?: string;
    timeout?: number;
    uuid?: string;
}
export interface SocketClient {
    connect(url?: string, options?: ConnectOptions): void;
    close(): void;
    destroy(): void;
    readonly connected: boolean;
    on(event: string, callback: (...args: any) => void): void;
    off(event: string, callback: (...args: any) => void): void;
    emit(event: string, ...args: any): boolean;
}
export declare class LegacyConnection {
    private _socket;
    private _authTimer;
    private systemLang;
    private readonly _waitForFirstConnection;
    private _waitForFirstConnectionResolve;
    private _promises;
    private readonly _instanceSubscriptions;
    private props;
    private readonly doNotLoadAllObjects;
    private readonly doNotLoadACL;
    private states;
    private objects;
    private scriptLoadCounter;
    private acl;
    private firstConnect;
    private readonly waitForRestart;
    private connected;
    private readonly statesSubscribes;
    private readonly objectsSubscribes;
    private readonly filesSubscribes;
    private onConnectionHandlers;
    private onLogHandlers;
    private readonly onProgress;
    private readonly onError;
    private loaded;
    private loadTimer;
    private loadCounter;
    private ignoreState;
    private readonly simStates;
    private autoSubscribes;
    private readonly autoSubscribeLog;
    private subscribed;
    isSecure: boolean | undefined;
    private onCmdStdoutHandler;
    private onCmdStderrHandler;
    private onCmdExitHandler;
    systemConfig: ioBroker.SystemConfigObject | null;
    private objectViewCached;
    constructor(props: ConnectionProps);
    /**
     * Checks if this connection is running in a web adapter and not in an admin.
     *
     * @returns True if running in a web adapter or in a socketio adapter.
     */
    static isWeb(): boolean;
    /**
     * Starts the socket.io connection.
     */
    startSocket(): void;
    /**
     * Called internally.
     */
    private onPreConnect;
    /**
     * Checks if running in ioBroker cloud
     */
    static isCloud(): boolean;
    /**
     * Checks if the socket is connected.
     */
    isConnected(): boolean;
    /**
     * Checks if the socket is connected.
     * Promise resolves if once connected.
     */
    waitForFirstConnection(): Promise<void>;
    /**
     * Called internally.
     */
    private _getUserPermissions;
    /**
     * Called internally.
     */
    private onConnect;
    /**
     * Called internally.
     */
    private static authenticate;
    /**
     * Subscribe to changes of the given state.
     *
     * @param id The ioBroker state ID or array of states
     * @param binary Set to true if the given state is binary and requires Base64 decoding
     * @param cb The callback
     */
    subscribeState(id: string | string[], binary: boolean | ioBroker.StateChangeHandler | BinaryStateChangeHandler, cb?: ioBroker.StateChangeHandler | BinaryStateChangeHandler): Promise<void>;
    /**
     * Subscribe to changes of the given state.
     */
    subscribeStateAsync(
    /** The ioBroker state ID or array of states */
    id: string | string[], 
    /** The callback. */
    cb: ioBroker.StateChangeHandler): Promise<void>;
    /**
     * Unsubscribes all or the given callback from changes of the given state.
     */
    unsubscribeState(
    /** The ioBroker state ID or array of states */
    id: string | string[], 
    /** The callback. */
    cb?: ioBroker.StateChangeHandler | BinaryStateChangeHandler): void;
    /**
     * Subscribe to changes of the given object.
     *
     * @param id The ioBroker object ID or array of objects
     * @param cb The callback
     */
    subscribeObject(id: string | string[], cb: ioBroker.ObjectChangeHandler): Promise<void>;
    /**
     * Unsubscribes all or the given callback from changes of the given object.
     *
     * @param id The ioBroker object ID or array of objects
     * @param cb The callback
     */
    unsubscribeObject(id: string | string[], cb?: ioBroker.ObjectChangeHandler): Promise<void>;
    /**
     * Called internally.
     */
    private fileChange;
    /**
     * Subscribe to changes of the files.
     *
     * @param id The ioBroker state ID for meta-object. Could be a pattern
     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
     * @param cb The callback.
     */
    subscribeFiles(
    /** The ioBroker state ID for meta-object. Could be a pattern */
    id: string, 
    /** Pattern or file name, like 'main/*' or 'main/visViews.json` */
    filePattern: string | string[], 
    /** The callback. */
    cb: ioBroker.FileChangeHandler): Promise<void>;
    /**
     * Unsubscribes the given callback from changes of files.
     *
     * @param id The ioBroker state ID.
     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
     * @param cb The callback.
     */
    unsubscribeFiles(id: string, filePattern: string, cb?: ioBroker.FileChangeHandler): void;
    /**
     * Called internally.
     */
    private objectChange;
    /**
     * Called internally.
     */
    private stateChange;
    /**
     * Called internally.
     *
     * @param messageType The message type
     * @param sourceInstance The source instance
     * @param data Payload
     */
    instanceMessage(messageType: string, sourceInstance: string, data: Record<string, any>): void;
    /**
     * Gets all states.
     *
     * @param pattern The pattern to filter states
     * @param disableProgressUpdate Don't call onProgress() when done
     */
    getStates(pattern?: string | boolean, disableProgressUpdate?: boolean): Promise<Record<string, ioBroker.State>>;
    /**
     * Gets the given state.
     *
     * @param id The state ID
     */
    getState(id: string): Promise<ioBroker.State | null>;
    /**
     * Get the given binary state.
     *
     * @deprecated since js-controller 5.0. Use files instead.
     * @param id The state ID.
     */
    getBinaryState(id: string): Promise<string>;
    /**
     * Set the given binary state.
     *
     * @deprecated since js-controller 5.0. Use files instead.
     * @param id The state ID.
     * @param base64 The Base64 encoded binary data.
     */
    setBinaryState(id: string, base64: string): Promise<void>;
    /**
     * Sets the given state value.
     *
     * @param id The state ID
     * @param val The state value
     * @param ack The acknowledgment flag
     */
    setState(id: string, val: string | number | boolean | ioBroker.SettableState | null, ack?: boolean): Promise<void>;
    /**
     * Gets all objects.
     *
     * @param update Set to true to retrieve all objects from the server (instead of using the local cache)
     * @param disableProgressUpdate Don't call onProgress() when done
     */
    getObjects(update?: boolean, disableProgressUpdate?: boolean): Promise<Record<string, ioBroker.Object>>;
    /**
     * Gets objects by list of IDs.
     *
     * @param list Array of object IDs to retrieve
     */
    getObjectsById(list: string[]): Promise<Record<string, ioBroker.Object>>;
    /**
     * Called internally.
     */
    private _subscribe;
    /**
     * Requests log updates.
     *
     * @param isEnabled Set to true to get logs
     */
    requireLog(isEnabled: boolean): Promise<void>;
    /**
     * Deletes the given object.
     *
     * @param id The object ID
     * @param maintenance Force deletion of non-conform IDs
     */
    delObject(id: string, maintenance?: boolean): Promise<void>;
    /**
     * Deletes the given object and all its children.
     *
     * @param id The object ID
     * @param maintenance Force deletion of non-conform IDs
     */
    delObjects(id: string, maintenance?: boolean): Promise<void>;
    /**
     * Sets the object.
     */
    setObject(id: string, obj: ioBroker.SettableObject): Promise<void>;
    /**
     * Gets the object with the given id from the server.
     */
    getObject<T = ioBroker.Object>(id: string): Promise<T>;
    /**
     * Get all instances of the given adapter or all instances of all adapters.
     *
     * @param adapter The name of the adapter
     * @param update Force update
     */
    getAdapterInstances(adapter?: string | boolean, update?: boolean): Promise<ioBroker.InstanceObject[]>;
    /**
     * Get adapters with the given name or all adapters.
     *
     * @param adapter The name of the adapter
     * @param update Force update
     */
    getAdapters(adapter?: string | boolean, update?: boolean): Promise<ioBroker.AdapterObject[]>;
    /**
     * Called internally.
     */
    private _renameGroups;
    /**
     * Rename a group.
     *
     * @param id The id.
     * @param newId The new id.
     * @param newName The new name.
     */
    renameGroup(id: string, newId: string, newName: ioBroker.StringOrTranslated): Promise<void>;
    /**
     * Sends a message to a specific instance or all instances of some specific adapter.
     *
     * @param instance The instance to send this message to.
     * @param command Command name of the target instance.
     * @param data The message data to send.
     */
    sendTo(instance: string, command: string, data: any): Promise<{
        result?: any;
        error?: string;
    }>;
    /**
     * Extend an object and create it if it might not exist.
     *
     * @param id The id.
     * @param obj The object.
     */
    extendObject(id: string, obj: ioBroker.PartialObject): Promise<void>;
    /**
     * Register a handler for log messages.
     */
    registerLogHandler(handler: (message: string) => void): void;
    /**
     * Unregister a handler for log messages.
     */
    unregisterLogHandler(handler: (message: string) => void): void;
    /**
     * Register a handler for the connection state.
     */
    registerConnectionHandler(handler: (connected: boolean) => void): void;
    /**
     * Unregister a handler for the connection state.
     */
    unregisterConnectionHandler(handler: (connected: boolean) => void): void;
    /**
     * Set the handler for standard output of a command.
     *
     * @param handler The handler.
     */
    registerCmdStdoutHandler(handler: (id: string, text: string) => void): void;
    /**
     * Unset the handler for standard output of a command.
     */
    unregisterCmdStdoutHandler(): void;
    /**
     * Set the handler for standard error of a command.
     *
     * @param handler The handler.
     */
    registerCmdStderrHandler(handler: (id: string, text: string) => void): void;
    /**
     * Unset the handler for standard error of a command.
     */
    unregisterCmdStderrHandler(): void;
    /**
     * Set the handler for exit of a command.
     */
    registerCmdExitHandler(handler: (id: string, exitCode: number) => void): void;
    /**
     * Unset the handler for exit of a command.
     */
    unregisterCmdExitHandler(): void;
    /**
     * Get all enums with the given name.
     */
    getEnums(
    /** The name of the enum. */
    _enum?: string, 
    /** Force update. */
    update?: boolean): Promise<Record<string, ioBroker.EnumObject>>;
    /**
     * Query a predefined object view.
     *
     * @param design design - 'system' or other designs like `custom`.
     * @param type The type of object.
     * @param start The start ID.
     * @param end The end ID.
     */
    getObjectViewCustom(
    /** The design: 'system' or other designs like `custom`. */
    design: string, 
    /** The type of object. */
    type: ioBroker.ObjectType, 
    /** The start ID. */
    start: string, 
    /** The end ID. */
    end?: string): Promise<Record<string, ioBroker.Object>>;
    /**
     * Query a predefined object view.
     *
     * @param type The type of object.
     * @param start The start ID.
     * @param end The end ID.
     */
    getObjectViewSystem<T extends ioBroker.ObjectType>(type: ioBroker.ObjectType, start: string, end?: string): Promise<Record<string, ioBroker.AnyObject & {
        type: T;
    }>>;
    /**
     * Query a predefined object view.
     *
     * @param type The type of object.
     * @param start The start ID.
     * @param [end] The end ID.
     */
    getObjectViewSystemCached<T extends ioBroker.ObjectType>(type: T, start?: string, end?: string): Promise<Record<string, ioBroker.AnyObject & {
        type: T;
    }>>;
    /**
     * @deprecated since version 1.1.15, cause parameter order does not match backend
     *
     * Query a predefined object view.
     * @param start The start ID.
     * @param end The end ID.
     * @param type The type of object.
     */
    getObjectView(start: string, end: string, type: ioBroker.ObjectType): Promise<Record<string, ioBroker.Object>>;
    /**
     * Get the stored certificates.
     *
     * @param update Force update.
     */
    getCertificates(update?: boolean): Promise<{
        name: string;
        type: 'public' | 'private' | 'chained' | '';
    }[]>;
    /**
     * Get the logs from a host (only for admin connection).
     */
    getLogs(host: string, linesNumber?: number): Promise<string[]>;
    /**
     * Get the log files (only for admin connection).
     */
    getLogsFiles(host: string): Promise<string[]>;
    /**
     * Delete the logs from a host (only for admin connection).
     */
    delLogs(host: string): Promise<void>;
    /**
     * Read the meta items.
     */
    readMetaItems(): Promise<ioBroker.MetaObject[]>;
    /**
     * Read the directory of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The directory name.
     */
    readDir(adapter: string, fileName: string): Promise<ioBroker.ReadDirResult[]>;
    /**
     * Read a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     * @param base64 If it must be a base64 format.
     */
    readFile(adapter: string, fileName: string, base64?: boolean): Promise<string | {
        data: string;
        type: string;
    }>;
    /**
     * Write a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     * @param data The data (if it's a Buffer, it will be converted to Base64)
     */
    writeFile64(adapter: string, fileName: string, data: Buffer | string): Promise<void>;
    /**
     * Delete a file of an adapter.
     *
     * @param adapter The adapter name.
     * @param fileName The file name.
     */
    deleteFile(adapter: string, fileName: string): Promise<void>;
    /**
     * Delete a folder of an adapter.
     * All files in folder will be deleted.
     *
     * @param adapter The adapter name.
     * @param folderName The folder name.
     */
    deleteFolder(adapter: string, folderName: string): Promise<void>;
    /**
     * Get the list of all hosts.
     *
     * @param update Force update.
     */
    getHosts(update?: boolean): Promise<ioBroker.HostObject[]>;
    /**
     * Get the list of all users.
     *
     * @param update Force update.
     */
    getUsers(update?: boolean): Promise<ioBroker.UserObject[]>;
    /**
     * Get the list of all groups.
     *
     * @param update Force update.
     */
    getGroups(update?: boolean): Promise<ioBroker.GroupObject[]>;
    /**
     * Get the host information.
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs Optional read timeout.
     */
    getHostInfo(host: string, update?: boolean, timeoutMs?: number): Promise<HostInfo>;
    /**
     * Get the host information (short version).
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs Optional read timeout.
     */
    getHostInfoShort(host: string, update?: boolean, timeoutMs?: number): Promise<HostInfo>;
    /**
     * Get the repository.
     *
     * @param host The host name.
     * @param options Options.
     * @param update Force update.
     * @param timeoutMs Timeout in ms.
     */
    getRepository(host: string, options?: {
        update: boolean;
        repo: string;
    } | string, update?: boolean, timeoutMs?: number): Promise<Record<string, ioBroker.AdapterCommon>>;
    /**
     * Get the installed.
     *
     * @param host The host name.
     * @param update Force update.
     * @param cmdTimeout Timeout in ms.
     */
    getInstalled(host: string, update?: boolean, cmdTimeout?: number): Promise<InstalledInfo>;
    /**
     * Rename file or folder in ioBroker DB
     *
     * @param adapter Instance name, like `vis-2.0`.
     * @param oldName The current file name, e.g., main/vis-views.json
     * @param newName The new file name, e.g., main/vis-views-new.json
     */
    rename(adapter: string, oldName: string, newName: string): Promise<void>;
    /**
     * Rename file in ioBroker DB
     */
    renameFile(
    /** instance name */
    adapter: string, 
    /** current file name, e.g., main/vis-views.json */
    oldName: string, 
    /** new file name, e.g., main/vis-views-new.json */
    newName: string): Promise<void>;
    /**
     * Execute a command on a host.
     */
    cmdExec(
    /** The host name. */
    host: string, 
    /** The command. */
    cmd: string, 
    /** The command ID. */
    cmdId: string, 
    /** Timeout of command in ms */
    cmdTimeout: number): Promise<void>;
    /**
     * Checks if a given feature is supported.
     */
    checkFeatureSupported(
    /** The feature to check. */
    feature: string, 
    /** Force update. */
    update?: boolean): Promise<boolean>;
    /**
     * Read the base settings of a given host.
     */
    readBaseSettings(host: string): Promise<Record<string, any>>;
    /**
     * Write the base settings of a given host.
     *
     * @param host The host name.
     * @param config The new base settings.
     */
    writeBaseSettings(host: string, config: IoBJson): Promise<{
        result?: 'ok';
        error?: string;
    }>;
    /**
     * Send command to restart the iobroker on host
     */
    restartController(host: string): Promise<boolean>;
    /**
     * Read statistics information from host
     *
     * @param host Host name
     * @param typeOfDiag one of none, normal, no-city, extended
     */
    getDiagData(host: string, typeOfDiag: 'none' | 'normal' | 'no-city' | 'extended'): Promise<Record<string, any>>;
    /**
     * Read all states (which might not belong to this adapter) which match the given pattern.
     */
    getForeignStates(pattern?: string): Promise<Record<string, ioBroker.State>>;
    /**
     * Get foreign objects by pattern, by specific type and resolve their enums. (Only admin)
     */
    getForeignObjects(pattern: string, type?: ioBroker.ObjectType): Promise<Record<string, ioBroker.State>>;
    /**
     * Gets the system configuration.
     *
     * @param update Force update.
     */
    getSystemConfig(update?: boolean): Promise<ioBroker.SystemConfigObject>;
    /**
     * Sets the system configuration.
     */
    setSystemConfig(obj: ioBroker.SettableObjectWorker<ioBroker.SystemConfigObject>): Promise<ioBroker.SystemConfigObject>;
    /**
     * Get the raw socket.io socket.
     */
    getRawSocket(): SocketClient;
    /**
     * Get the history of a given state.
     */
    getHistory(id: string, options: ioBroker.GetHistoryOptions): Promise<ioBroker.GetHistoryResult>;
    /**
     * Get the history of a given state.
     */
    getHistoryEx(id: string, options: ioBroker.GetHistoryOptions): Promise<{
        values: ioBroker.GetHistoryResult;
        sessionId: string;
        step: number;
    }>;
    /**
     * Change the password of the given user.
     */
    changePassword(user: string, password: string): Promise<void>;
    /**
     * Get the IP addresses of the given host.
     */
    getIpAddresses(host: string, 
    /** Force update. */
    update?: boolean): Promise<string[]>;
    /**
     * Get the IP addresses with interface names of the given host or find host by IP.
     */
    getHostByIp(ipOrHostName: string, 
    /** Force update. */
    update?: boolean): Promise<{
        name: string;
        address: string;
        family: 'ipv4' | 'ipv6';
    }[]>;
    /**
     * Encrypt a text
     */
    encrypt(text: string): Promise<string>;
    /**
     * Decrypt a text
     */
    decrypt(encryptedText: string): Promise<string>;
    /**
     * Gets the version.
     */
    getVersion(update?: boolean): Promise<{
        version: string;
        serverName: string;
    }>;
    /**
     * Gets the web server name.
     */
    getWebServerName(): Promise<string>;
    /**
     * Gets the admin version.
     *
     * @deprecated use getVersion()
     */
    getAdminVersion(): Promise<{
        version: string;
        serverName: string;
    }>;
    /**
     * Change access rights for a file
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     * @param options like {mode: 0x644}
     * @param options.mode Access rights. Default is 0x644
     */
    chmodFile(adapter: string, fileName: string, options?: {
        mode: number;
    }): Promise<{
        entries: ioBroker.ChownFileResult[];
        id: string;
    }>;
    /**
     * Change an owner or/and owner group for a file
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     * @param options like {owner: 'user', ownerGroup: 'group'}
     * @param options.owner User name
     * @param options.ownerGroup Group name
     */
    chownFile(adapter: string, fileName: string, options: {
        owner?: string;
        ownerGroup?: string;
    }): Promise<{
        entries: ioBroker.ChownFileResult[];
        id: string;
    }>;
    /**
     * Check if the file exists
     *
     * @param adapter The adapter name.
     * @param fileName file name with a full path. It could be like vis.0/*
     */
    fileExists(adapter: string, fileName: string): Promise<boolean>;
    /**
     * Get the alarm notifications from a host (only for admin connection).
     */
    getNotifications(host: string, category?: string): Promise<FilteredNotificationInformation>;
    /**
     * Clear the alarm notifications on a host (only for admin connection).
     *
     * @param host The host name.
     * @param category optional
     */
    clearNotifications(host: string, category?: string): Promise<{
        result: 'ok';
    }>;
    /**
     * Read if only easy mode is allowed (only for admin connection).
     */
    getIsEasyModeStrict(): Promise<boolean>;
    /**
     * Read easy mode configuration (only for admin connection).
     */
    getEasyMode(): Promise<any>;
    /**
     * Read current user
     */
    getCurrentUser(): Promise<string>;
    getCurrentSession(cmdTimeout?: number): Promise<{
        expireInSec: number;
    }>;
    /**
     * Read adapter ratings
     */
    getRatings(update?: boolean): Promise<any>;
    /**
     * Read current web, socketio or admin namespace, like admin.0
     */
    getCurrentInstance(): Promise<string>;
    getCompactAdapters(update?: boolean): Promise<Record<string, ioBroker.AdapterObject>>;
    getAdaptersResetCache(adapter?: string): void;
    getCompactInstances(update?: boolean): Promise<Record<string, ioBroker.InstanceObject>>;
    getAdapternInstancesResetCache(adapter?: string): void;
    /**
     * Returns very optimized information for adapters to minimize a connection load.
     * Reads only version of installed adapter
     */
    getCompactInstalled(host: string, update?: boolean, cmdTimeout?: number): Promise<Record<string, ioBroker.AdapterObject>>;
    getCompactSystemRepositories(update?: boolean, cmdTimeout?: number): Promise<CompactSystemRepository>;
    getCompactSystemConfig(update?: boolean): Promise<ioBroker.SystemConfigObject>;
    /**
     * Get the repository in compact form (only version and icon).
     *
     * @param host The host name.
     * @param update Force update.
     * @param timeoutMs timeout in ms.
     */
    getCompactRepository(host: string, update?: boolean, timeoutMs?: number): Promise<Record<string, {
        version: string;
        icon: string;
    }>>;
    getInstalledResetCache(): void;
    /**
     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)
     */
    getCompactHosts(update?: boolean): Promise<ioBroker.HostObject[]>;
    /**
     * Get uuid
     */
    getUuid(): Promise<string | undefined>;
    /**
     * Subscribe on instance message
     *
     * @param targetInstance instance, like 'cameras.0'
     * @param  messageType message type like 'startCamera/cam3'
     * @param data optional data object
     * @param callback message handler
     */
    subscribeOnInstance(targetInstance: string, messageType: string, data: any, callback: (_data: Record<string, any>, sourceInstance: string, _messageType: string) => void): Promise<{
        error?: string;
        accepted?: boolean;
        heartbeat?: number;
    }>;
    /**
     * Unsubscribe from instance message
     *
     * @param targetInstance instance, like 'cameras.0'
     * @param messageType message type like 'startCamera/cam3'
     * @param callback message handler. Could be null if all callbacks for this messageType should be unsubscribed
     */
    unsubscribeFromInstance(targetInstance: string, messageType?: string, callback?: (data: Record<string, any>, sourceInstance: string, _messageType: string) => void): Promise<boolean>;
    /**
     * Send log to ioBroker log
     */
    log(text: string, level?: 'info' | 'debug' | 'warn' | 'error' | 'silly'): void;
    /**
     * Logout current user
     */
    logout(): Promise<void>;
    /**
     * This is a special method for vis.
     * It is used to not send to server the changes about "nothing_selected" state
     *
     * @param id The state that has to be ignored by communication
     */
    setStateToIgnore(id?: string | null): void;
}
export {};
