{"version":3,"file":"SocketClient.js","sourceRoot":"","sources":["../../src/SocketClient.ts"],"names":[],"mappings":"","sourcesContent":["import type { IOEmitEvents, IOListenEvents } from './SocketEvents.js';\n\nexport type ListenEventHandler =\n    // Add more overloads as necessary\n    | ((arg1: any, arg2: any, arg3: any, arg4: any, arg5: any) => void)\n    | ((arg1: any, arg2: any, arg3: any, arg4: any) => void)\n    | ((arg1: any, arg2: any, arg3: any) => void)\n    | ((arg1: any, arg2: any) => void)\n    | ((arg1: any) => void)\n    | ((...args: any[]) => void);\n\nexport type EmitEventHandler =\n    // Add more overloads as necessary\n    | ((arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, callback?: (...args: any[]) => void) => void)\n    | ((arg1: any, arg2: any, arg3: any, arg4: any, callback?: (...args: any[]) => void) => void)\n    | ((arg1: any, arg2: any, arg3: any, callback?: (...args: any[]) => void) => void)\n    | ((arg1: any, arg2: any, callback?: (...args: any[]) => void) => void)\n    | ((arg1: any, callback?: (...args: any[]) => void) => void)\n    | ((...args: [...any[], (...args: any[]) => void]) => void)\n    | ((...args: any[]) => void);\n\n// export type ListenEventHandler = (...args: any[]) => void;\n\n// export type EmitEventHandler = (\n// \t...args: any[],\n// \tcallback?: (...args: any[]) => void,\n// ) => void;\n\n// ^ not sure why we cannot type these with tuple-typed arguments, but whatever...\nexport interface ConnectOptions {\n    /** Timeout for answer for ping (pong) */\n    pongTimeout?: number;\n    /** Ping interval */\n    pingInterval?: number;\n    /** connection request timeout */\n    connectTimeout?: number;\n    /** Authentication timeout */\n    authTimeout?: number;\n    /** Interval between connection attempts */\n    connectInterval?: number;\n    /** Every connection attempt the interval increasing at options.connectInterval till max this number */\n    connectMaxAttempt?: number;\n}\n\nexport interface SocketClient<\n    TListenEvents extends Record<keyof TListenEvents, ListenEventHandler> = Record<string, never>,\n    TEmitEvents extends Record<keyof TEmitEvents, EmitEventHandler> = Record<string, never>,\n> {\n    connect(url?: string, options?: ConnectOptions): void;\n    close(): void;\n    destroy(): void;\n\n    readonly connected: boolean;\n\n    on<TEvent extends keyof IOListenEvents>(event: TEvent, callback: IOListenEvents[TEvent]): void;\n    on<TEvent extends keyof TListenEvents>(event: TEvent, callback: TListenEvents[TEvent]): void;\n    off<TEvent extends keyof IOListenEvents>(event: TEvent, callback: IOListenEvents[TEvent]): void;\n    off<TEvent extends keyof TListenEvents>(event: TEvent, callback: TListenEvents[TEvent]): void;\n\n    emit<TEvent extends keyof TEmitEvents>(event: TEvent, ...args: Parameters<TEmitEvents[TEvent]>): boolean;\n    emit<TEvent extends keyof IOEmitEvents>(event: TEvent, ...args: Parameters<IOEmitEvents[TEvent]>): boolean;\n}\n"]}