"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Connection_exports = {};
__export(Connection_exports, {
  Connection: () => Connection,
  ERRORS: () => ERRORS,
  NOT_CONNECTED: () => NOT_CONNECTED,
  PERMISSION_ERROR: () => PERMISSION_ERROR,
  PROGRESS: () => PROGRESS
});
module.exports = __toCommonJS(Connection_exports);
var import_DeferredPromise = require("./DeferredPromise.js");
var import_tools = require("./tools.js");
if (typeof globalThis.process !== "undefined") {
  globalThis.location ||= {
    href: "http://localhost:8081/",
    protocol: "http:",
    host: "localhost:8081",
    pathname: "/",
    hostname: "localhost",
    reload: /* @__PURE__ */ __name(() => {
    }, "reload")
  };
  globalThis.localStorage ||= {
    _keys: {},
    setItem: /* @__PURE__ */ __name((key, value) => {
      globalThis.localStorage._keys[key] = value;
    }, "setItem"),
    getItem: /* @__PURE__ */ __name((key) => {
      if (key in globalThis.localStorage._keys) {
        return globalThis.localStorage._keys[key];
      }
      return null;
    }, "getItem"),
    removeItem: /* @__PURE__ */ __name((key) => {
      if (key in globalThis.localStorage._keys) {
        delete globalThis.localStorage._keys[key];
      }
    }, "removeItem")
  };
  globalThis.sessionStorage ||= globalThis.localStorage;
  globalThis.navigator ||= {
    language: "en"
  };
}
var PROGRESS;
(function(PROGRESS2) {
  PROGRESS2[PROGRESS2["CONNECTING"] = 0] = "CONNECTING";
  PROGRESS2[PROGRESS2["CONNECTED"] = 1] = "CONNECTED";
  PROGRESS2[PROGRESS2["OBJECTS_LOADED"] = 2] = "OBJECTS_LOADED";
  PROGRESS2[PROGRESS2["READY"] = 3] = "READY";
})(PROGRESS || (PROGRESS = {}));
var ERRORS;
(function(ERRORS2) {
  ERRORS2["PERMISSION_ERROR"] = "permissionError";
  ERRORS2["NOT_CONNECTED"] = "notConnectedError";
  ERRORS2["TIMEOUT"] = "timeout";
  ERRORS2["NOT_ADMIN"] = "Allowed only in admin";
  ERRORS2["NOT_SUPPORTED"] = "Not supported";
})(ERRORS || (ERRORS = {}));
const PERMISSION_ERROR = ERRORS.PERMISSION_ERROR;
const NOT_CONNECTED = ERRORS.NOT_CONNECTED;
const ADAPTERS = ["material", "echarts", "vis"];
class Connection {
  static {
    __name(this, "Connection");
  }
  props;
  connId;
  lastAccessToken = null;
  ignoreState = "";
  connected = false;
  subscribed = false;
  firstConnect = true;
  waitForRestart = false;
  loaded = false;
  simStates = {};
  objectViewCached;
  /**
   * Creates a new instance of the Connection class.
   *
   * @param props The connection properties.
   */
  constructor(props) {
    this.props = this.applyDefaultProps(props);
    this.connId = `${this.props.name ? `${this.props.name}-` : ""}${Math.round(Math.random() * 1e6).toString().padStart(6, "0")}`;
    this.waitForSocketLib().then(() => this.startSocket()).catch((e) => {
      alert(`Socket connection could not be initialized: ${e}`);
    });
  }
  applyDefaultProps(props) {
    return {
      ...props,
      // Define default props that always need to be set
      protocol: props.protocol || globalThis.location.protocol,
      host: props.host || globalThis.location.hostname,
      port: props.port || (globalThis.location.port === "3000" ? 8081 : globalThis.location.port),
      ioTimeout: Math.max(props.ioTimeout || 2e4, 2e4),
      cmdTimeout: Math.max(props.cmdTimeout || 5e3, 5e3),
      admin5only: props.admin5only || false,
      autoSubscribes: props.autoSubscribes ?? [],
      autoSubscribeLog: props.autoSubscribeLog ?? false,
      doNotLoadACL: props.doNotLoadACL ?? true,
      doNotLoadAllObjects: props.doNotLoadAllObjects ?? true
    };
  }
  statesSubscribes = {};
  filesSubscribes = {};
  objectsSubscribes = {};
  objects = {};
  states = {};
  acl = null;
  isSecure = false;
  // Do not inform about readiness two times
  onReadyDone = false;
  onConnectionHandlers = [];
  onLogHandlers = [];
  onCmdStdoutHandler;
  onCmdStderrHandler;
  onCmdExitHandler;
  onError(error) {
    (this.props.onError ?? console.error)(error);
  }
  /** The socket instance */
  _socket;
  _waitForSocketPromise;
  _waitForFirstConnectionPromise = (0, import_DeferredPromise.createDeferredPromise)();
  /** array with all subscriptions to instances */
  _instanceSubscriptions = {};
  /** Cache for server requests */
  _promises = {};
  _authTimer = null;
  _refreshTimer = null;
  _systemConfig;
  /** The "system.config" object */
  get systemConfig() {
    return this._systemConfig;
  }
  /** System language. It could be changed during runtime */
  systemLang = "en";
  /**
   * Checks if this connection is running in a web adapter and not in an admin.
   *
   * @returns True if running in a web adapter or in a socketio adapter.
   */
  static isWeb() {
    return globalThis.socketUrl !== void 0;
  }
  waitForSocketLib() {
    if (this._waitForSocketPromise) {
      return this._waitForSocketPromise;
    }
    this._waitForSocketPromise = new Promise(async (resolve, reject) => {
      if (this.props.connect) {
        resolve();
        return;
      }
      if (typeof globalThis.io === "undefined" && typeof globalThis.iob === "undefined") {
        if (typeof globalThis.registerSocketOnLoad === "function") {
          globalThis.registerSocketOnLoad(() => resolve());
        } else {
          for (let i = 1; i <= 30; i++) {
            if (globalThis.io || globalThis.iob) {
              return resolve();
            }
            await (0, import_tools.wait)(100);
          }
          reject(new Error("Socket library could not be loaded!"));
        }
      } else {
        resolve();
      }
    });
    return this._waitForSocketPromise;
  }
  /**
   * Starts the socket.io connection.
   */
  async startSocket() {
    if (this._socket) {
      return;
    }
    let host = this.props.host;
    let port = this.props.port;
    let protocol = (this.props.protocol || globalThis.location.protocol).replace(":", "");
    let path = globalThis.location.pathname;
    if (globalThis.location.hostname === "iobroker.net" || globalThis.location.hostname === "iobroker.pro") {
      path = "";
    } else {
      if (globalThis.socketUrl) {
        const parsed = new globalThis.URL(globalThis.socketUrl);
        host = parsed.hostname;
        port = parsed.port;
        protocol = parsed.protocol.replace(":", "");
      }
      const pos = path.lastIndexOf("/");
      if (pos !== -1) {
        path = path.substring(0, pos + 1);
      }
      if (Connection.isWeb()) {
        const parts = path.split("/");
        if (parts.length > 2) {
          parts.pop();
          parts.pop();
          if (ADAPTERS.includes(parts[parts.length - 1])) {
            parts.pop();
          }
          path = parts.join("/");
          if (!path.endsWith("/")) {
            path += "/";
          }
        }
      }
    }
    const url = port ? `${protocol}://${host}:${port}` : `${protocol}://${host}`;
    const connectFunc = this.props.connect || (globalThis.io || globalThis.iob).connect;
    this._socket = connectFunc(url, {
      path: path.endsWith("/") ? `${path}socket.io` : `${path}/socket.io`,
      query: "ws=true",
      name: this.props.name,
      timeout: this.props.ioTimeout,
      uuid: this.props.uuid,
      token: this.props.token
    });
    this._socket.on("connect", (noTimeout) => {
      globalThis.addEventListener?.("storage", this.onAccessTokenUpdated);
      const tokens = Connection.readTokens();
      if (tokens && !tokens.owner) {
        const now = Date.now();
        this.saveTokens({
          access_token: tokens.access_token,
          refresh_token: tokens.refresh_token,
          expires_in: Math.round((tokens.expires_in.getTime() - now) / 1e3),
          refresh_token_expires_in: Math.round((tokens.refresh_token_expires_in.getTime() - now) / 1e3),
          token_type: "Bearer"
        }, tokens.stayLoggedIn);
      }
      this.onReadyDone = false;
      if (noTimeout !== true) {
        this.connected = true;
        setTimeout(() => this.getVersion().then((info) => {
          const [major, minor, patch] = info.version.split(".");
          const v = parseInt(major, 10) * 1e4 + parseInt(minor, 10) * 100 + parseInt(patch, 10);
          if (v < 40102) {
            this._authTimer = null;
            this.onPreConnect(false, false);
          } else {
            this._socket.emit("authenticate", (isOk, isSecure) => this.onPreConnect(isOk, isSecure));
          }
        }).catch((e) => this.onError({
          message: e.toString(),
          operation: "getVersion"
        })), 500);
      } else {
        this._socket.emit("authenticate", (isOk, isSecure) => {
          this.onPreConnect(isOk, isSecure);
        });
      }
    });
    this._socket.on("reconnect", () => {
      this.onReadyDone = false;
      this.props.onProgress?.(PROGRESS.READY);
      this.connected = true;
      if (this.waitForRestart) {
        globalThis.location.reload();
      } else {
        this._subscribe(true);
        this.onConnectionHandlers.forEach((cb) => cb(true));
      }
    });
    this._socket.on("disconnect", () => {
      this.onReadyDone = false;
      this.connected = false;
      this.subscribed = false;
      this.props.onProgress?.(PROGRESS.CONNECTING);
      this.onConnectionHandlers.forEach((cb) => cb(false));
    });
    this._socket.on("reauthenticate", () => this.authenticate());
    this._socket.on("log", (message) => {
      this.props.onLog?.(message);
      this.onLogHandlers.forEach((cb) => cb(message));
    });
    this._socket.on("error", (err) => {
      let _err;
      if (err == void 0) {
        _err = "";
      } else if (typeof err.toString === "function") {
        _err = err.toString();
      } else {
        _err = JSON.stringify(err);
        console.error(`Received strange error: ${_err}`);
      }
      if (_err.includes("User not authorized")) {
        this.authenticate();
      } else if (_err.includes("websocket error")) {
        console.error(`Socket Error => reload: ${err}`);
        globalThis.location.reload();
      } else {
        console.error(`Socket Error: ${err}`);
      }
    });
    this._socket.on("connect_error", (err) => console.error(`Connect error: ${err}`));
    this._socket.on("permissionError", (err) => this.onError({
      message: "no permission",
      operation: err.operation,
      type: err.type,
      id: err.id || ""
    }));
    this._socket.on("objectChange", (id, obj) => {
      setTimeout(() => this.objectChange(id, obj), 0);
    });
    this._socket.on("stateChange", (id, state) => {
      setTimeout(() => this.stateChange(id, state), 0);
    });
    this._socket.on("im", (messageType, from, data) => {
      setTimeout(() => this.instanceMessage(messageType, from, data), 0);
    });
    this._socket.on("fileChange", (id, fileName, size) => {
      setTimeout(() => this.fileChange(id, fileName, size), 0);
    });
    this._socket.on("cmdStdout", (id, text) => {
      this.onCmdStdoutHandler?.(id, text);
    });
    this._socket.on("cmdStderr", (id, text) => {
      this.onCmdStderrHandler?.(id, text);
    });
    this._socket.on("cmdExit", (id, exitCode) => {
      this.onCmdExitHandler?.(id, exitCode);
    });
    return Promise.resolve();
  }
  /**
   * Called internally.
   */
  onPreConnect(_isOk, isSecure) {
    if (this._authTimer) {
      clearTimeout(this._authTimer);
      this._authTimer = null;
    }
    this.connected = true;
    this.isSecure = isSecure;
    if (this.waitForRestart) {
      globalThis.location.reload();
    } else {
      if (this.firstConnect) {
        void this.loadData().catch((e) => {
          console.error(`Cannot load data: ${e}`);
        });
      } else {
        this.props.onProgress?.(PROGRESS.READY);
      }
      this._subscribe(true);
      this.onConnectionHandlers.forEach((cb) => cb(true));
      this.checkAccessTokenExpire();
    }
    this._waitForFirstConnectionPromise.resolve();
  }
  static readTokens() {
    let tokenString = globalThis.sessionStorage.getItem("iob_tokens");
    const stayLoggedIn = !tokenString;
    if (!tokenString) {
      tokenString = globalThis.localStorage.getItem("iob_tokens");
    }
    if (!tokenString) {
      return null;
    }
    const [refresh_token, refresh_token_expires_in, access_token, expires_in, owner] = tokenString.split(";");
    const refreshExpires = new Date(refresh_token_expires_in);
    if (refreshExpires.getTime() < Date.now()) {
      return null;
    }
    return {
      refresh_token,
      refresh_token_expires_in: refreshExpires,
      access_token,
      expires_in: new Date(expires_in),
      owner,
      stayLoggedIn
    };
  }
  static saveTokensStatic(data, stayLoggedIn, owner) {
    const tokenStr = `${data.refresh_token};${new Date(Date.now() + data.refresh_token_expires_in * 1e3).toISOString()};${data.access_token};${new Date(Date.now() + data.expires_in * 1e3).toISOString()}${owner ? `;${owner}` : ""}`;
    if (stayLoggedIn) {
      globalThis.localStorage.setItem("iob_tokens", tokenStr);
    } else {
      globalThis.sessionStorage.setItem("iob_tokens", tokenStr);
    }
  }
  saveTokens(data, stayLoggedIn) {
    Connection.saveTokensStatic(data, stayLoggedIn, this.connId);
  }
  static deleteTokensStatic() {
    globalThis.localStorage.removeItem("iob_tokens");
    globalThis.sessionStorage.removeItem("iob_tokens");
  }
  /**
   * Destroy tokens if they were created by this connection if they expired or invalid
   *
   * @param stayLoggedIn if stored in localStorage or in sessionStorage
   * @param logout if logout is requested
   */
  deleteTokens(stayLoggedIn, logout) {
    const tokens = Connection.readTokens();
    if (tokens) {
      if (logout) {
        Connection.deleteTokensStatic();
      } else if (tokens.stayLoggedIn === stayLoggedIn && tokens.owner === this.connId) {
        if (tokens.stayLoggedIn) {
          globalThis.localStorage.removeItem("iob_tokens");
        } else {
          globalThis.sessionStorage.removeItem("iob_tokens");
        }
      }
    }
  }
  onAccessTokenUpdated = /* @__PURE__ */ __name((event) => {
    if (event.key === "iob_tokens") {
      const tokens = Connection.readTokens();
      if (tokens) {
        console.log(`Tab ${this.connId} received updated token: ${tokens.access_token}`);
        this.updateTokenExpiration(tokens.access_token);
      }
    }
  }, "onAccessTokenUpdated");
  updateTokenExpiration(accessToken) {
    if (this.lastAccessToken !== accessToken) {
      this.lastAccessToken = accessToken;
      this._socket.emit("updateTokenExpiration", accessToken, (err, success) => {
        if (err) {
          console.error(`[UPDATE/${(/* @__PURE__ */ new Date()).toISOString()}] cannot say to server about new token: ${err}`);
          globalThis.location.reload();
        } else if (!success) {
          console.error(`[UPDATE/${(/* @__PURE__ */ new Date()).toISOString()}] cannot say to server about new token`);
          globalThis.location.reload();
        } else {
          console.log(`[UPDATE/${(/* @__PURE__ */ new Date()).toISOString()}] server accepted new token: ${accessToken}`);
        }
      });
    }
    this.checkAccessTokenExpire();
  }
  refreshTokens(tokenStructure, takeOwnership) {
    if (!tokenStructure) {
      console.log(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] No token structure found => reloading the page`);
      setTimeout(() => globalThis.location.reload(), 500);
      return;
    }
    if (takeOwnership || !tokenStructure.owner || tokenStructure.owner === this.connId) {
      console.log(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] claim ownership of the token`);
      if (this.acquireTokenLock()) {
        console.log(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] refreshing token`);
        fetch("./oauth/token", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: `grant_type=refresh_token&refresh_token=${tokenStructure.refresh_token}&client_id=ioBroker&stayloggedin=${tokenStructure.stayLoggedIn}`
        }).then((response) => {
          if (response.ok) {
            return response.json();
          }
          throw new Error("Cannot refresh access token");
        }).then((data) => {
          if (data.access_token) {
            console.log(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] received new token: ${data.access_token}`);
            this.saveTokens(data, tokenStructure.stayLoggedIn);
            this.releaseTokenLock();
            this.updateTokenExpiration(data.access_token);
          } else {
            throw new Error("Cannot get access token");
          }
        }).catch((err) => {
          console.warn(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] cannot refresh token: ${err}`);
          this.releaseTokenLock();
          this.deleteTokens(tokenStructure.stayLoggedIn);
          console.error(err);
          globalThis.location.reload();
        });
      } else {
        console.log(`[REFRESH/${(/* @__PURE__ */ new Date()).toISOString()}] Someone else is updating the token, so wait for the next check`);
        this.checkAccessTokenExpire();
      }
    } else if (this.lastAccessToken !== tokenStructure.access_token) {
      this.updateTokenExpiration(tokenStructure.access_token);
    }
  }
  /**
   * Attempts to acquire the semaphore lock.
   *
   * @returns True if the lock was acquired successfully; otherwise, false.
   */
  acquireTokenLock() {
    const now = Date.now();
    const lock = globalThis.localStorage.getItem("iob_token_semaphore");
    if (lock) {
      try {
        const lockData = JSON.parse(lock);
        if (now < lockData.expiry) {
          return false;
        }
      } catch {
      }
    }
    const newLock = {
      connId: this.connId,
      expiry: now + 10 * 1e3
      // 10 seconds in milliseconds
    };
    globalThis.localStorage.setItem("iob_token_semaphore", JSON.stringify(newLock));
    return true;
  }
  /** Releases the semaphore lock if it's owned by the given connection ID. */
  releaseTokenLock() {
    const lock = globalThis.localStorage.getItem("iob_token_semaphore");
    if (lock) {
      try {
        const lockData = JSON.parse(lock);
        if (lockData.connId === this.connId) {
          globalThis.localStorage.removeItem("iob_token_semaphore");
        }
      } catch {
        globalThis.localStorage.removeItem("iob_token_semaphore");
      }
    }
  }
  checkAccessTokenExpire() {
    if (this._refreshTimer) {
      clearTimeout(this._refreshTimer);
      this._refreshTimer = null;
    }
    if (this.isSecure) {
      const tokens = Connection.readTokens();
      if (tokens) {
        const accessExpireInUnixMs = tokens.expires_in.getTime();
        if (accessExpireInUnixMs < Date.now() + 3e4) {
          const takeOwnership = accessExpireInUnixMs < Date.now() + 5500;
          console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] Updating refresh token ${tokens.access_token}`);
          if (!tokens.refresh_token) {
            console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] We do not have a refresh token, so we need to reauthenticate`);
            setTimeout(() => globalThis.location.reload(), Date.now() > accessExpireInUnixMs ? 500 : accessExpireInUnixMs - Date.now());
          } else if (tokens.owner === this.connId || // We gave 25 seconds to the owner to update the token, and now we will do it and take the ownership
          takeOwnership) {
            if (tokens.owner === this.connId) {
              console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] We are the owner of the token`);
            } else {
              console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] We are not the owner of the token, but we will take ownership`);
            }
            if (this.props.tokenTimeoutHandler) {
              console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] Asking GUI if we should prolong the token`);
              void this.props.tokenTimeoutHandler(accessExpireInUnixMs).then((prolong) => {
                if (prolong) {
                  console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] Token will be prolonged`);
                  this.refreshTokens(tokens, takeOwnership);
                } else {
                  console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] Token will not be prolonged. Reloading the page`);
                  setTimeout(() => globalThis.location.reload(), Date.now() > accessExpireInUnixMs ? 500 : accessExpireInUnixMs - Date.now());
                }
              });
            } else {
              console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] No tokenTimeoutHandler defined. Prolonging the token`);
              this.refreshTokens(tokens, takeOwnership);
            }
          } else if (this.lastAccessToken !== tokens.access_token) {
            console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] We are not the owner of the token, but we will inform the server about new token`);
            this.refreshTokens(tokens);
          } else {
            console.log(`[TOKEN/${(/* @__PURE__ */ new Date()).toISOString()}] We are not the owner of the token and the token did not change. Check in 3 seconds if the owner updated the token`);
            this._refreshTimer = setTimeout(() => {
              this._refreshTimer = null;
              this.checkAccessTokenExpire();
            }, 3e3);
          }
        } else {
          this._refreshTimer = setTimeout(() => {
            this._refreshTimer = null;
            this.checkAccessTokenExpire();
          }, accessExpireInUnixMs - Date.now() - 3e4 > 12e4 ? 12e4 : accessExpireInUnixMs - Date.now() - 3e4);
        }
      }
    }
  }
  /**
   * Checks if running in ioBroker cloud
   */
  static isCloud() {
    if (globalThis.location.hostname.includes("amazonaws.com") || globalThis.location.hostname.includes("iobroker.in")) {
      return true;
    }
    if (typeof globalThis.socketUrl === "undefined") {
      return false;
    }
    return globalThis.socketUrl.includes("iobroker.in") || globalThis.socketUrl.includes("amazonaws");
  }
  /**
   * Checks if the socket is connected.
   *
   * @returns true if connected.
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Returns a promise which is resolved when the socket is connected.
   */
  waitForFirstConnection() {
    return this._waitForFirstConnectionPromise;
  }
  /**
   * Called internally.
   */
  async getUserPermissions() {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getUserPermissions", (err, acl) => {
          if (err) {
            reject(err);
          } else {
            resolve(acl || null);
          }
        });
      }, "executor")
    });
  }
  /** Loads the important data and retries a couple of times if it takes too long */
  async loadData() {
    if (this.loaded) {
      return;
    }
    const maxAttempts = 10;
    for (let i = 1; i <= maxAttempts; i++) {
      void this.doLoadData().catch((e) => console.error(`Cannot load data: ${e}`));
      if (this.loaded) {
        return;
      }
      await (0, import_tools.wait)(Connection.isCloud() ? 5e3 : 1e3);
    }
  }
  /**
   * Called after the socket is connected. Loads the necessary data.
   */
  async doLoadData() {
    if (this.loaded) {
      return;
    }
    if (!this.props.doNotLoadACL) {
      try {
        this.acl = await this.getUserPermissions();
      } catch (e) {
        this.onError(`Cannot read user permissions: ${e}`);
        return;
      }
    }
    try {
      if (this.props.admin5only && !Connection.isWeb() && (!globalThis.vendorPrefix || globalThis.vendorPrefix === "@@vendorPrefix@@")) {
        this._systemConfig = await this.getCompactSystemConfig();
      } else {
        this._systemConfig = await this.getSystemConfig();
      }
    } catch (e) {
      this.onError(`Cannot read system config: ${e}`);
      return;
    }
    if (this._systemConfig) {
      this.systemLang = this._systemConfig.common?.language;
      if (!this.systemLang) {
        this.systemLang = globalThis.navigator.userLanguage || globalThis.navigator.language;
        if (/^(en|de|ru|pt|nl|fr|it|es|pl|uk)-?/.test(this.systemLang)) {
          this.systemLang = this.systemLang.substring(0, 2);
        } else if (!/^(en|de|ru|pt|nl|fr|it|es|pl|uk|zh-cn)$/.test(this.systemLang)) {
          this.systemLang = "en";
        }
        this._systemConfig.common.language = this.systemLang;
      }
    }
    this.props.onLanguage?.(this.systemLang);
    this.loaded = true;
    this.props.onProgress?.(PROGRESS.CONNECTED);
    this.firstConnect = false;
    if (!this.props.doNotLoadAllObjects) {
      this.objects = await this.getObjects();
    } else if (this.props.admin5only) {
      this.objects = {};
    } else {
      this.objects = { "system.config": this._systemConfig };
    }
    this.props.onProgress?.(PROGRESS.READY);
    if (!this.onReadyDone) {
      this.onReadyDone = true;
      this.props.onReady?.(this.objects);
    }
  }
  /**
   * Called internally.
   */
  authenticate() {
    if (globalThis.location.search.includes("&href=")) {
      globalThis.location.href = `${globalThis.location.protocol}//${globalThis.location.host}${globalThis.location.pathname}${globalThis.location.search}`;
    } else {
      globalThis.location.href = `${globalThis.location.protocol}//${globalThis.location.host}${globalThis.location.pathname}?login&href=${encodeURIComponent(globalThis.location.search + globalThis.location.hash)}`;
    }
  }
  async subscribeState(...args) {
    let id;
    let binary;
    let cb;
    if (args.length === 3) {
      [id, binary, cb] = args;
    } else {
      [id, cb] = args;
      binary = false;
    }
    let ids;
    if (!Array.isArray(id)) {
      ids = [id];
    } else {
      ids = id;
    }
    if (typeof cb !== "function") {
      throw new Error("The state change handler must be a function!");
    }
    const toSubscribe = [];
    for (let i = 0; i < ids.length; i++) {
      const _id = ids[i];
      if (!this.statesSubscribes[_id]) {
        this.statesSubscribes[_id] = {
          reg: new RegExp((0, import_tools.pattern2RegEx)(_id)),
          cbs: [cb]
        };
        if (id !== this.ignoreState) {
          toSubscribe.push(_id);
        }
      } else {
        !this.statesSubscribes[_id].cbs.includes(cb) && this.statesSubscribes[_id].cbs.push(cb);
      }
    }
    if (!this.connected) {
      return;
    }
    if (toSubscribe.length) {
      this._socket.emit("subscribe", toSubscribe);
    }
    if (binary) {
      let base64;
      for (let i = 0; i < ids.length; i++) {
        try {
          base64 = await this.getBinaryState(ids[i]);
        } catch (e) {
          console.error(`Cannot getBinaryState "${ids[i]}": ${JSON.stringify(e)}`);
          base64 = void 0;
        }
        if (base64 != void 0) {
          cb(ids[i], base64);
        }
      }
    } else if (ids.find((_id) => _id.includes("*"))) {
      let states;
      for (let i = 0; i < ids.length; i++) {
        try {
          states = await this.getForeignStates(ids[i]);
        } catch (e) {
          console.error(`Cannot getForeignStates "${ids[i]}": ${JSON.stringify(e)}`);
          return;
        }
        if (states) {
          for (const [id2, state] of Object.entries(states)) {
            const mayBePromise = cb(id2, state);
            if (mayBePromise instanceof Promise) {
              void mayBePromise.catch((e) => console.error(`Cannot call state change handler: ${e}`));
            }
          }
        }
      }
    } else {
      try {
        const states = await (Connection.isWeb() ? this.getStates(ids) : this.getForeignStates(ids));
        if (states) {
          for (const [id2, state] of Object.entries(states)) {
            const mayBePromise = cb(id2, state);
            if (mayBePromise instanceof Promise) {
              void mayBePromise.catch((e) => console.error(`Cannot call state change handler: ${e}`));
            }
          }
        }
      } catch (e) {
        console.error(`Cannot getState "${ids.join(", ")}": ${e.message}`);
        return;
      }
    }
  }
  /**
   * Subscribe to the changes of the given state and wait for answer.
   *
   * @param id The ioBroker state ID.
   * @param cb The callback.
   */
  async subscribeStateAsync(id, cb) {
    return this.subscribeState(id, cb);
  }
  /**
   * Unsubscribes the given callback from changes of the given state.
   *
   * @param id The ioBroker state ID or array of state IDs.
   * @param cb The callback.
   */
  unsubscribeState(id, cb) {
    let ids;
    if (!Array.isArray(id)) {
      ids = [id];
    } else {
      ids = id;
    }
    const toUnsubscribe = [];
    for (let i = 0; i < ids.length; i++) {
      const _id = ids[i];
      if (this.statesSubscribes[_id]) {
        const sub = this.statesSubscribes[_id];
        if (cb) {
          const pos = sub.cbs.indexOf(cb);
          pos !== -1 && sub.cbs.splice(pos, 1);
        } else {
          sub.cbs = [];
        }
        if (!sub.cbs?.length) {
          delete this.statesSubscribes[_id];
          if (_id !== this.ignoreState) {
            toUnsubscribe.push(_id);
          }
        }
      }
    }
    if (this.connected && toUnsubscribe.length) {
      this._socket.emit("unsubscribe", ids);
    }
  }
  /**
   * Subscribe to changes of the given object.
   * In compare to the subscribeState method,
   * this method does not call the handler with the current value immediately after subscribe.
   *
   * the current value.
   *
   * @param id The ioBroker object ID.
   * @param cb The callback.
   */
  subscribeObject(id, cb) {
    let ids;
    if (!Array.isArray(id)) {
      ids = [id];
    } else {
      ids = id;
    }
    if (typeof cb !== "function") {
      throw new Error("The object change handler must be a function!");
    }
    const toSubscribe = [];
    for (let i = 0; i < ids.length; i++) {
      const _id = ids[i];
      if (!this.objectsSubscribes[_id]) {
        this.objectsSubscribes[_id] = {
          reg: new RegExp((0, import_tools.pattern2RegEx)(_id)),
          cbs: [cb]
        };
        toSubscribe.push(_id);
      } else {
        !this.objectsSubscribes[_id].cbs.includes(cb) && this.objectsSubscribes[_id].cbs.push(cb);
      }
    }
    if (this.connected && toSubscribe.length) {
      this._socket.emit("subscribeObjects", toSubscribe);
    }
    return Promise.resolve();
  }
  /**
   * Unsubscribes all callbacks from changes of the given object.
   *
   * @param id The ioBroker object ID.
   */
  /**
   * Unsubscribes the given callback from changes of the given object.
   *
   * @param id The ioBroker object ID.
   * @param cb The callback.
   */
  unsubscribeObject(id, cb) {
    let ids;
    if (!Array.isArray(id)) {
      ids = [id];
    } else {
      ids = id;
    }
    const toUnsubscribe = [];
    for (let i = 0; i < ids.length; i++) {
      const _id = ids[i];
      if (this.objectsSubscribes[_id]) {
        const sub = this.objectsSubscribes[_id];
        if (cb) {
          const pos = sub.cbs.indexOf(cb);
          pos !== -1 && sub.cbs.splice(pos, 1);
        } else {
          sub.cbs = [];
        }
        if (!sub.cbs?.length) {
          delete this.objectsSubscribes[_id];
          toUnsubscribe.push(_id);
        }
      }
    }
    if (this.connected && toUnsubscribe.length) {
      this._socket.emit("unsubscribeObjects", toUnsubscribe);
    }
    return Promise.resolve();
  }
  /**
   * Called internally.
   *
   * @param id The ioBroker object ID.
   * @param obj The new object.
   */
  objectChange(id, obj) {
    let oldObj;
    if (this.objects[id]) {
      oldObj = { _id: id, type: this.objects[id].type };
    }
    let changed = false;
    if (obj) {
      if (obj._rev && this.objects[id]) {
        this.objects[id]._rev = obj._rev;
      }
      if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {
        this.objects[id] = obj;
        changed = true;
      }
    } else if (this.objects[id]) {
      delete this.objects[id];
      changed = true;
    }
    for (const [_id, sub] of Object.entries(this.objectsSubscribes)) {
      if (_id === id || sub.reg.test(id)) {
        sub.cbs.forEach((cb) => {
          try {
            const mayBePromise = cb(id, obj, oldObj);
            if (mayBePromise instanceof Promise) {
              void mayBePromise.catch((e) => console.error(`Cannot call object change handler: ${e}`));
            }
          } catch (e) {
            console.error(`Error by callback of objectChange: ${e}`);
          }
        });
      }
    }
    if (changed) {
      const mayBePromise = this.props.onObjectChange?.(id, obj);
      if (mayBePromise instanceof Promise) {
        void mayBePromise.catch((e) => console.error(`Cannot call object change handler: ${e}`));
      }
    }
  }
  /**
   * Called internally.
   *
   * @param id The ioBroker state ID.
   * @param state The new state value.
   */
  stateChange(id, state) {
    for (const sub of Object.values(this.statesSubscribes)) {
      if (sub.reg.test(id)) {
        for (const cb of sub.cbs) {
          try {
            const mayBePromise = cb(id, state ?? null);
            if (mayBePromise instanceof Promise) {
              void mayBePromise.catch((e) => console.error(`Cannot call state change handler: ${e}`));
            }
          } catch (e) {
            console.error(`Error by callback of stateChanged: ${e}`);
          }
        }
      }
    }
  }
  /**
   * Called internally.
   *
   * @param messageType The message type from the instance
   * @param sourceInstance The source instance
   * @param data The message data
   */
  instanceMessage(messageType, sourceInstance, data) {
    this._instanceSubscriptions[sourceInstance]?.forEach((sub) => {
      if (sub.messageType === messageType) {
        const mayBePromise = sub.callback(data, sourceInstance, messageType);
        if (mayBePromise instanceof Promise) {
          void mayBePromise.catch((e) => console.error(`Cannot call instance message handler: ${e}`));
        }
      }
    });
  }
  /**
   * Called internally.
   *
   * @param id The ioBroker object ID of type 'meta'.
   * @param fileName - file name
   * @param size - size of the file
   */
  fileChange(id, fileName, size) {
    for (const sub of Object.values(this.filesSubscribes)) {
      if (sub.regId.test(id) && sub.regFilePattern.test(fileName)) {
        for (const cb of sub.cbs) {
          try {
            cb(id, fileName, size);
          } catch (e) {
            console.error(`Error by callback of fileChange: ${e}`);
          }
        }
      }
    }
  }
  /**
   * Subscribe to changes of the files.
   *
   * @param id The ioBroker state ID for a "meta" object. Could be a pattern
   * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
   * @param cb The callback.
   */
  async subscribeFiles(id, filePattern, cb) {
    if (typeof cb !== "function") {
      throw new Error("The state change handler must be a function!");
    }
    let filePatterns;
    if (Array.isArray(filePattern)) {
      filePatterns = filePattern;
    } else {
      filePatterns = [filePattern];
    }
    const toSubscribe = [];
    for (let f = 0; f < filePatterns.length; f++) {
      const pattern = filePatterns[f];
      const key = `${id}$%$${pattern}`;
      if (!this.filesSubscribes[key]) {
        this.filesSubscribes[key] = {
          regId: new RegExp((0, import_tools.pattern2RegEx)(id)),
          regFilePattern: new RegExp((0, import_tools.pattern2RegEx)(pattern)),
          cbs: [cb]
        };
        toSubscribe.push(pattern);
      } else {
        !this.filesSubscribes[key].cbs.includes(cb) && this.filesSubscribes[key].cbs.push(cb);
      }
    }
    if (this.connected && toSubscribe.length) {
      this._socket.emit("subscribeFiles", id, toSubscribe);
    }
    return Promise.resolve();
  }
  /**
   * Unsubscribes the given callback from changes of files.
   *
   * @param id The ioBroker state ID.
   * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`
   * @param cb The callback.
   */
  unsubscribeFiles(id, filePattern, cb) {
    let filePatterns;
    if (Array.isArray(filePattern)) {
      filePatterns = filePattern;
    } else {
      filePatterns = [filePattern];
    }
    const toUnsubscribe = [];
    for (let f = 0; f < filePatterns.length; f++) {
      const pattern = filePatterns[f];
      const key = `${id}$%$${pattern}`;
      if (this.filesSubscribes[key]) {
        const sub = this.filesSubscribes[key];
        if (cb) {
          const pos = sub.cbs.indexOf(cb);
          pos !== -1 && sub.cbs.splice(pos, 1);
        } else {
          sub.cbs = [];
        }
        if (!sub.cbs?.length) {
          delete this.filesSubscribes[key];
          toUnsubscribe.push(pattern);
        }
      }
    }
    if (this.connected && toUnsubscribe.length) {
      this._socket.emit("unsubscribeFiles", id, toUnsubscribe);
    }
  }
  /** Requests data from the server or reads it from the cache */
  async request({
    cacheKey,
    forceUpdate,
    commandTimeout,
    onTimeout,
    requireAdmin,
    requireFeatures,
    // requestName,
    executor
  }) {
    if (requireAdmin && Connection.isWeb()) {
      return Promise.reject(new Error(ERRORS.NOT_ADMIN));
    }
    if (cacheKey && !forceUpdate && cacheKey in this._promises) {
      return this._promises[cacheKey];
    }
    if (!this.connected) {
      return Promise.reject(new Error(ERRORS.NOT_CONNECTED));
    }
    if (requireFeatures?.length) {
      for (const feature of requireFeatures) {
        if (!await this.checkFeatureSupported(feature)) {
          throw new Error(ERRORS.NOT_SUPPORTED);
        }
      }
    }
    const promise = new Promise(async (resolve, reject) => {
      const timeoutControl = {
        elapsed: false,
        clearTimeout: /* @__PURE__ */ __name(() => {
        }, "clearTimeout")
      };
      let timeout;
      if (commandTimeout !== false) {
        timeout = setTimeout(() => {
          timeoutControl.elapsed = true;
          onTimeout?.();
          if (cacheKey && this._promises[cacheKey] instanceof Promise) {
            delete this._promises[cacheKey];
          }
          reject(new Error(ERRORS.TIMEOUT));
        }, commandTimeout ?? this.props.cmdTimeout);
        timeoutControl.clearTimeout = () => {
          clearTimeout(timeout);
        };
      }
      try {
        await executor(resolve, reject, timeoutControl);
      } catch (e) {
        if (cacheKey && this._promises[cacheKey] instanceof Promise) {
          delete this._promises[cacheKey];
        }
        reject(new Error(e.toString()));
      }
    });
    if (cacheKey) {
      this._promises[cacheKey] = promise;
    }
    return promise;
  }
  /**
   * Deletes cached promise.
   * So next time the information will be requested anew
   */
  resetCache(key, isAll) {
    if (isAll) {
      Object.keys(this._promises).filter((k) => k.startsWith(key)).forEach((k) => {
        delete this._promises[k];
      });
    } else {
      delete this._promises[key];
    }
  }
  /**
   * Gets all states.
   *
   * @param pattern Pattern of states or array of IDs
   */
  getStates(pattern) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getStates", pattern, (err, res) => {
          this.states = res ?? {};
          if (err) {
            reject(err);
          } else {
            resolve(this.states);
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the given state.
   *
   * @param id The state ID.
   */
  getState(id) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        if (id && id === this.ignoreState) {
          resolve(this.simStates[id] || { val: null, ack: true });
          return;
        }
        this._socket.emit("getState", id, (err, state) => {
          if (err) {
            reject(err);
          } else {
            resolve(state);
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the given binary state Base64 encoded.
   *
   * @deprecated since js-controller 5.0. Use files instead.
   * @param id The state ID.
   */
  getBinaryState(id) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getBinaryState", id, (err, state) => {
          if (err) {
            reject(err);
          } else {
            resolve(state);
          }
        });
      }, "executor")
    });
  }
  /**
   * Sets the given binary state.
   *
   * @deprecated since js-controller 5.0. Use files instead.
   * @param id The state ID.
   * @param base64 The Base64 encoded binary data.
   */
  setBinaryState(id, base64) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("setBinaryState", id, base64, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Sets the given state value.
   *
   * @param id The state ID.
   * @param val The state value.
   * @param ack Acknowledgement flag.
   */
  setState(id, val, ack) {
    if (typeof ack === "boolean") {
      val = { val, ack };
    }
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        if (id && id === this.ignoreState) {
          let state;
          if (typeof ack === "boolean") {
            state = val;
          } else if (typeof val === "object" && val.val !== void 0) {
            state = val;
          } else {
            state = {
              val,
              ack: false,
              ts: Date.now(),
              lc: Date.now(),
              from: "system.adapter.vis.0"
            };
          }
          this.simStates[id] = state;
          if (this.statesSubscribes[id]) {
            for (const cb of this.statesSubscribes[id].cbs) {
              try {
                const mayBePromise = cb(id, state);
                if (mayBePromise instanceof Promise) {
                  void mayBePromise.catch((e) => console.error(`Cannot call state change handler: ${e}`));
                }
              } catch (e) {
                console.error(`Error by callback of stateChanged: ${e}`);
              }
            }
          }
          resolve();
          return;
        }
        this._socket.emit("setState", id, val, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets all objects.
   *
   * @param update Callback that is executed when all objects are retrieved.
   */
  /**
   * Gets all objects.
   *
   * @param update Set to true to retrieve all objects from the server (instead of using the local cache).
   * @param disableProgressUpdate don't call onProgress() when done
   */
  getObjects(update, disableProgressUpdate) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        if (!update && this.objects) {
          resolve(this.objects);
          return;
        }
        this._socket.emit(Connection.isWeb() ? "getObjects" : "getAllObjects", (err, res) => {
          if (!disableProgressUpdate) {
            this.props.onProgress?.(PROGRESS.OBJECTS_LOADED);
          }
          if (err) {
            reject(err);
          } else {
            this.objects = res ?? {};
            resolve(this.objects);
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the list of objects by ID.
   *
   * @param list array of IDs to retrieve
   */
  getObjectsById(list) {
    return this.request({
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getObjects", list, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve(res);
          }
        });
      }, "executor")
    });
  }
  /**
   * Called internally.
   *
   * @param isEnable Set to true if subscribing, false to unsubscribe.
   */
  _subscribe(isEnable) {
    if (isEnable && !this.subscribed) {
      this.subscribed = true;
      if (this.props.autoSubscribes?.length) {
        this._socket.emit("subscribeObjects", this.props.autoSubscribes);
      }
      const ids = Object.keys(this.objectsSubscribes);
      if (ids.length) {
        this._socket.emit("subscribeObjects", ids);
      }
      Object.keys(this.objectsSubscribes).forEach((id) => this._socket.emit("subscribeObjects", id));
      this.props.autoSubscribeLog && this._socket.emit("requireLog", true);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("subscribe", id));
      Object.keys(this.filesSubscribes).forEach((key) => {
        const [id, filePattern] = key.split("$%$");
        this._socket.emit("subscribeFiles", id, filePattern);
      });
    } else if (!isEnable && this.subscribed) {
      this.subscribed = false;
      if (this.props.autoSubscribes?.length) {
        this._socket.emit("unsubscribeObjects", this.props.autoSubscribes);
      }
      const ids = Object.keys(this.objectsSubscribes);
      if (ids.length) {
        this._socket.emit("unsubscribeObjects", ids);
      }
      this.props.autoSubscribeLog && this._socket.emit("requireLog", false);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("unsubscribe", id));
      Object.keys(this.filesSubscribes).forEach((key) => {
        const [id, filePattern] = key.split("$%$");
        this._socket.emit("unsubscribeFiles", id, filePattern);
      });
    }
  }
  /**
   * Requests log updates.
   *
   * @param isEnabled Set to true to get logs.
   */
  requireLog(isEnabled) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("requireLog", isEnabled, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Deletes the given object.
   *
   * @param id The object ID.
   * @param maintenance Force deletion of non conform IDs.
   */
  delObject(id, maintenance = false) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("delObject", id, { maintenance }, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Deletes the given object and all its children.
   *
   * @param id The object ID.
   * @param maintenance Force deletion of non conform IDs.
   */
  delObjects(id, maintenance) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("delObjects", id, { maintenance }, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Sets the object.
   *
   * @param id The object ID.
   * @param obj The object.
   */
  setObject(id, obj) {
    if (!obj) {
      return Promise.reject(new Error("Null object is not allowed"));
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("setObject", id, obj, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the object with the given id from the server.
   *
   * @param id The object ID.
   * @returns The object.
   */
  getObject(id) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        if (id && id === this.ignoreState) {
          resolve({
            _id: this.ignoreState,
            type: "state",
            common: {
              name: "ignored state",
              type: "mixed"
            }
          });
          return;
        }
        this._socket.emit("getObject", id, (err, obj) => {
          if (err) {
            reject(err);
          } else {
            resolve(obj);
          }
        });
      }, "executor")
    });
  }
  /**
   * Sends a message to a specific instance or all instances of some specific adapter.
   *
   * @param instance The instance to send this message to.
   * @param command Command name of the target instance.
   * @param data The message data to send.
   */
  sendTo(instance, command, data) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve) => {
        this._socket.emit("sendTo", instance, command, data, (result) => {
          resolve(result);
        });
      }, "executor")
    });
  }
  /**
   * Extend an object and create it if it might not exist.
   *
   * @param id The id.
   * @param obj The object.
   */
  extendObject(id, obj) {
    if (!obj) {
      return Promise.reject(new Error("Null object is not allowed"));
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("extendObject", id, obj, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Register a handler for log messages.
   *
   * @param handler The handler.
   */
  registerLogHandler(handler) {
    if (!this.onLogHandlers.includes(handler)) {
      this.onLogHandlers.push(handler);
    }
  }
  /**
   * Unregister a handler for log messages.
   *
   * @param handler The handler.
   */
  unregisterLogHandler(handler) {
    const pos = this.onLogHandlers.indexOf(handler);
    pos !== -1 && this.onLogHandlers.splice(pos, 1);
  }
  /**
   * Register a handler for the connection state.
   *
   * @param handler The handler.
   */
  registerConnectionHandler(handler) {
    if (!this.onConnectionHandlers.includes(handler)) {
      this.onConnectionHandlers.push(handler);
    }
  }
  /**
   * Unregister a handler for the connection state.
   *
   * @param handler The handler.
   */
  unregisterConnectionHandler(handler) {
    const pos = this.onConnectionHandlers.indexOf(handler);
    pos !== -1 && this.onConnectionHandlers.splice(pos, 1);
  }
  /**
   * Set the handler for standard output of a command.
   *
   * @param handler The handler.
   */
  registerCmdStdoutHandler(handler) {
    this.onCmdStdoutHandler = handler;
  }
  /**
   * Unset the handler for standard output of a command.
   */
  unregisterCmdStdoutHandler() {
    this.onCmdStdoutHandler = void 0;
  }
  /**
   * Set the handler for standard error of a command.
   *
   * @param handler The handler.
   */
  registerCmdStderrHandler(handler) {
    this.onCmdStderrHandler = handler;
  }
  /**
   * Unset the handler for standard error of a command.
   */
  unregisterCmdStderrHandler() {
    this.onCmdStderrHandler = void 0;
  }
  /**
   * Set the handler for exit of a command.
   *
   * @param handler The handler.
   */
  registerCmdExitHandler(handler) {
    this.onCmdExitHandler = handler;
  }
  /**
   * Unset the handler for exit of a command.
   */
  unregisterCmdExitHandler() {
    this.onCmdExitHandler = void 0;
  }
  /**
   * Get all enums with the given name.
   *
   * @param _enum The name of the enum, like `rooms` or `functions`
   * @param update Force update.
   */
  getEnums(_enum, update) {
    return this.request({
      cacheKey: `enums_${_enum || "all"}`,
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getObjectView", "system", "enum", {
          startkey: `enum.${_enum || ""}`,
          endkey: _enum ? `enum.${_enum}.\u9999` : `enum.\u9999`
        }, (err, res) => {
          if (err) {
            reject(err);
          } else {
            const _res = {};
            if (res) {
              for (let i = 0; i < res.rows.length; i++) {
                if (_enum && res.rows[i].id === `enum.${_enum}`) {
                  continue;
                }
                _res[res.rows[i].id] = res.rows[i].value;
              }
            }
            resolve(_res);
          }
        });
      }, "executor")
    });
  }
  /**
   * @deprecated since version 1.1.15, cause parameter order does not match backend
   * Query a predefined object view.
   * @param start The start ID.
   * @param end The end ID.
   * @param type The type of object.
   */
  getObjectView(start, end, type) {
    return this.getObjectViewCustom("system", type, start, end);
  }
  /**
   * Query a predefined object view.
   *
   * @param type The type of object.
   * @param start The start ID.
   * @param [end] The end ID.
   */
  async getObjectViewSystem(type, start, end) {
    const key = `${type}_${start || ""}_${end || ""}`;
    const result = await this.getObjectViewCustom("system", type, start, end);
    if (this.objectViewCached?.[key]) {
      this.objectViewCached[key] = result;
    }
    return result;
  }
  /**
   * Query a predefined object view.
   *
   * @param type The type of object.
   * @param start The start ID.
   * @param [end] The end ID.
   */
  async getObjectViewSystemCached(type, start, end) {
    const key = `${type}_${start || ""}_${end || ""}`;
    if (this.objectViewCached?.[key]) {
      return Promise.resolve(this.objectViewCached[key]);
    }
    const result = await this.getObjectViewCustom("system", type, start, end);
    this.objectViewCached ||= {};
    this.objectViewCached[key] = result;
    return result;
  }
  /**
   * Query a predefined object view.
   *
   * @param design design - 'system' or other designs like `custom`.
   * @param type The type of object.
   * @param start The start ID.
   * @param [end] The end ID.
   */
  getObjectViewCustom(design, type, start, end) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        start ||= "";
        end ||= "\u9999";
        this._socket.emit("getObjectView", design, type, { startkey: start, endkey: end }, (err, res) => {
          if (err) {
            reject(err);
          } else {
            const _res = {};
            if (res && res.rows) {
              for (let i = 0; i < res.rows.length; i++) {
                _res[res.rows[i].id] = res.rows[i].value;
              }
            }
            resolve(_res);
          }
        });
      }, "executor")
    });
  }
  /**
   * Read the meta items.
   */
  readMetaItems() {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getObjectView", "system", "meta", { startkey: "", endkey: "\u9999" }, (err, objs) => {
          if (err) {
            reject(err);
          } else {
            resolve(objs.rows?.map((obj) => obj.value).filter((val) => !!val));
          }
        });
      }, "executor")
    });
  }
  /**
   * Read the directory of an adapter.
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param path The directory name.
   */
  readDir(namespace, path) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("readDir", namespace, path, (err, files) => {
          if (err) {
            reject(err);
          } else {
            resolve(files);
          }
        });
      }, "executor")
    });
  }
  /**
   * Read a file of an adapter.
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param fileName The file name.
   * @param base64 If it must be a base64 format
   */
  readFile(namespace, fileName, base64) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit(base64 ? "readFile64" : "readFile", namespace, fileName, (err, data, type) => {
          if (err) {
            reject(err);
          } else {
            resolve({ file: data, mimeType: type });
          }
        });
      }, "executor")
    });
  }
  /**
   * Write a file of an adapter.
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param fileName The file name.
   * @param data The data (if it's a Buffer, it will be converted to Base64).
   */
  writeFile64(namespace, fileName, data) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        if (typeof data === "string") {
          this._socket.emit("writeFile", namespace, fileName, data, (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        } else {
          const base64 = btoa(new Uint8Array(data).reduce((data2, byte) => data2 + String.fromCharCode(byte), ""));
          this._socket.emit("writeFile64", namespace, fileName, base64, (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        }
      }, "executor")
    });
  }
  /**
   * Delete a file of an adapter.
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param fileName The file name.
   */
  deleteFile(namespace, fileName) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("deleteFile", namespace, fileName, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Delete a folder of an adapter.
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param folderName The folder name.
   */
  deleteFolder(namespace, folderName) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("deleteFolder", namespace, folderName, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Rename file or folder in ioBroker DB
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param oldName current file name, e.g., main/vis-views.json
   * @param newName new file name, e.g., main/vis-views-new.json
   */
  rename(namespace, oldName, newName) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("rename", namespace, oldName, newName, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Rename file in ioBroker DB
   *
   * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).
   * @param oldName current file name, e.g., main/vis-views.json
   * @param newName new file name, e.g., main/vis-views-new.json
   */
  renameFile(namespace, oldName, newName) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("renameFile", namespace, oldName, newName, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Execute a command on a host.
   */
  cmdExec(host, cmd, cmdId, cmdTimeout) {
    return this.request({
      commandTimeout: cmdTimeout,
      executor: /* @__PURE__ */ __name((resolve, reject, timeout) => {
        host = (0, import_tools.normalizeHostId)(host);
        this._socket.emit("cmdExec", host, cmdId, cmd, (err) => {
          if (timeout.elapsed) {
            return;
          }
          timeout.clearTimeout();
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the system configuration.
   *
   * @param update Force update.
   */
  getSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfig",
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name(async (resolve) => {
        let systemConfig = await this.getObject("system.config");
        systemConfig ??= {};
        systemConfig.common ??= {};
        systemConfig.native ??= {};
        resolve(systemConfig);
      }, "executor")
    });
  }
  // returns very optimized information for adapters to minimize a connection load
  getCompactSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfigCommon",
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      requireAdmin: true,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getCompactSystemConfig", (err, systemConfig) => {
          if (err) {
            reject(err);
          } else {
            systemConfig ??= {};
            systemConfig.common ??= {};
            systemConfig.native ??= {};
            resolve(systemConfig);
          }
        });
      }, "executor")
    });
  }
  /**
   * Read all states (which might not belong to this adapter) which match the given pattern.
   *
   * @param pattern The pattern to match.
   */
  getForeignStates(pattern) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getForeignStates", pattern || "*", (err, states) => {
          if (err) {
            reject(err);
          } else {
            resolve(states ?? {});
          }
        });
      }, "executor")
    });
  }
  /**
   * Get foreign objects by pattern, by specific type and resolve their enums.
   *
   * @param pattern The pattern to match.
   * @param type The type of the object.
   */
  getForeignObjects(pattern, type) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getForeignObjects", pattern || "*", type, (err, objects) => {
          if (err) {
            reject(err);
          } else {
            resolve(objects);
          }
        });
      }, "executor")
    });
  }
  /**
   * Sets the system configuration.
   *
   * @param obj The new system configuration.
   */
  setSystemConfig(obj) {
    return this.setObject("system.config", obj);
  }
  /**
   * Get the raw socket.io socket.
   */
  getRawSocket() {
    return this._socket;
  }
  /**
   * Get the history of a given state.
   *
   * @param id The state ID.
   * @param options The query options.
   */
  getHistory(id, options) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values) => {
          if (err) {
            reject(err);
          } else {
            resolve(values);
          }
        });
      }, "executor")
    });
  }
  /**
   * Get the history of a given state.
   *
   * @param id The state ID.
   * @param options The query options.
   */
  getHistoryEx(id, options) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values, step, sessionId) => {
          if (err) {
            reject(err);
          } else {
            resolve({
              values,
              sessionId,
              step
            });
          }
        });
      }, "executor")
    });
  }
  /**
   * Get the IP addresses of the given host.
   *
   * @param host The host name.
   * @param update Force update.
   */
  getIpAddresses(host, update) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `IPs_${host}`,
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name(async (resolve) => {
        const obj = await this.getObject(host);
        resolve(obj?.common.address ?? []);
      }, "executor")
    });
  }
  /**
   * Gets the version.
   */
  getVersion(update) {
    return this.request({
      cacheKey: "version",
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getVersion", (err, version, serverName) => {
          if (err && !version && typeof err === "string" && err.match(/\d+\.\d+\.\d+/)) {
            resolve({ version: err, serverName: "socketio" });
          } else {
            if (err) {
              reject(err);
            } else {
              resolve({
                version,
                serverName
              });
            }
          }
        });
      }, "executor")
    });
  }
  /**
   * Gets the web server name.
   */
  getWebServerName() {
    return this.request({
      cacheKey: "webName",
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getAdapterName", (err, name) => {
          if (err) {
            reject(err);
          } else {
            resolve(name);
          }
        });
      }, "executor")
    });
  }
  /**
   * Check if the file exists
   *
   * @param adapter adapter name
   * @param filename file name with the full path. it could be like vis.0/*
   */
  fileExists(adapter, filename) {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("fileExists", adapter, filename, (err, exists) => {
          if (err) {
            reject(err);
          } else {
            resolve(!!exists);
          }
        });
      }, "executor")
    });
  }
  /**
   * Read current user
   */
  getCurrentUser() {
    return this.request({
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve) => {
        this._socket.emit("authEnabled", (_isSecure, user) => {
          resolve(user);
        });
      }, "executor")
    });
  }
  /**
   * Get uuid
   */
  getUuid() {
    return this.request({
      cacheKey: "uuid",
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name(async (resolve) => {
        const obj = await this.getObject("system.meta.uuid");
        resolve(obj?.native?.uuid);
      }, "executor")
    });
  }
  /**
   * Checks if a given feature is supported.
   *
   * @param feature The feature to check.
   * @param update Force update.
   */
  checkFeatureSupported(feature, update) {
    return this.request({
      cacheKey: `supportedFeatures_${feature}`,
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("checkFeatureSupported", feature, (err, features) => {
          if (err) {
            reject(err);
          } else {
            resolve(features);
          }
        });
      }, "executor")
    });
  }
  /**
   * Get all adapter instances.
   *
   * @param update Force update.
   */
  /**
   * Get all instances of the given adapter.
   *
   * @param adapter The name of the adapter.
   * @param update Force update.
   */
  getAdapterInstances(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter ||= "";
    return this.request({
      cacheKey: `instances_${adapter}`,
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name(async (resolve) => {
        const startKey = adapter ? `system.adapter.${adapter}.` : "system.adapter.";
        const endKey = `${startKey}\u9999`;
        const instances = await this.getObjectViewSystem("instance", startKey, endKey);
        const instanceObjects = Object.values(instances);
        if (adapter) {
          resolve(instanceObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(instanceObjects);
        }
      }, "executor")
    });
  }
  /**
   * Get adapters with the given name.
   *
   * @param adapter The name of the adapter.
   * @param update Force update.
   */
  getAdapters(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter ||= "";
    return this.request({
      cacheKey: `adapter_${adapter}`,
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name(async (resolve) => {
        const adapters = await this.getObjectViewSystem("adapter", `system.adapter.${adapter || ""}`, `system.adapter.${adapter || "\u9999"}`);
        const adapterObjects = Object.values(adapters);
        if (adapter) {
          resolve(adapterObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(adapterObjects);
        }
      }, "executor")
    });
  }
  /**
   * Get the list of all groups.
   *
   * @param update Force update.
   */
  getGroups(update) {
    return this.request({
      cacheKey: "groups",
      forceUpdate: update,
      // TODO: check if this should time out
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("getObjectView", "system", "group", {
          startkey: "system.group.",
          endkey: "system.group.\u9999"
        }, (err, doc) => {
          if (err) {
            reject(err);
          } else {
            resolve((0, import_tools.getObjectViewResultToArray)(doc));
          }
        });
      }, "executor")
    });
  }
  /**
   * Logout current user
   */
  logout() {
    return this.request({
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("logout", (err) => {
          err ? reject(err) : resolve(null);
        });
      }, "executor")
    });
  }
  /**
   * Subscribe on instance message
   *
   * @param targetInstance instance, like 'cameras.0'
   * @param messageType message type like 'startCamera/cam3'
   * @param data optional data object
   * @param callback message handler
   */
  subscribeOnInstance(targetInstance, messageType, data, callback) {
    return this.request({
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve, reject) => {
        this._socket.emit("clientSubscribe", targetInstance, messageType, data, (err, subscribeResult) => {
          if (err) {
            reject(err);
          } else if (subscribeResult) {
            if (subscribeResult.error) {
              reject(subscribeResult.error);
            } else {
              if (!targetInstance.startsWith("system.adapter.")) {
                targetInstance = `system.adapter.${targetInstance}`;
              }
              this._instanceSubscriptions[targetInstance] = this._instanceSubscriptions[targetInstance] || [];
              if (!this._instanceSubscriptions[targetInstance].find((subscription) => subscription.messageType === messageType && subscription.callback === callback)) {
                this._instanceSubscriptions[targetInstance].push({
                  messageType,
                  callback
                });
              }
              resolve(subscribeResult);
            }
          }
        });
      }, "executor")
    });
  }
  /**
   * Unsubscribe from instance message
   *
   * @param targetInstance instance, like 'cameras.0'
   * @param messageType message type like 'startCamera/cam3'
   * @param callback message handler
   */
  unsubscribeFromInstance(targetInstance, messageType, callback) {
    if (!targetInstance.startsWith("system.adapter.")) {
      targetInstance = `system.adapter.${targetInstance}`;
    }
    let deleted;
    const promiseResults = [];
    do {
      deleted = false;
      const index = this._instanceSubscriptions[targetInstance]?.findIndex((sub) => (!messageType || sub.messageType === messageType) && (!callback || sub.callback === callback));
      if (index !== void 0 && index !== null && index !== -1) {
        deleted = true;
        const _messageType = this._instanceSubscriptions[targetInstance][index].messageType;
        this._instanceSubscriptions[targetInstance].splice(index, 1);
        if (!this._instanceSubscriptions[targetInstance].length) {
          delete this._instanceSubscriptions[targetInstance];
        }
        const found = this._instanceSubscriptions[targetInstance] && this._instanceSubscriptions[targetInstance].find((sub) => sub.messageType === _messageType);
        if (!found) {
          promiseResults.push(this.request({
            commandTimeout: false,
            executor: /* @__PURE__ */ __name((resolve, reject) => {
              this._socket.emit("clientUnsubscribe", targetInstance, messageType, (err, wasSubscribed) => err ? reject(err) : resolve(wasSubscribed));
            }, "executor")
          }));
        }
      }
    } while (deleted && (!callback || !messageType));
    if (promiseResults.length) {
      return Promise.all(promiseResults).then((results) => !!results.find((result) => result));
    }
    return Promise.resolve(false);
  }
  /**
   * Send log to ioBroker log
   *
   * @param text Log text
   * @param level `info`, `debug`, `warn`, `error` or `silly`
   */
  log(text, level) {
    return text ? this.request({
      commandTimeout: false,
      executor: /* @__PURE__ */ __name((resolve) => {
        this._socket.emit("log", text, level);
        return resolve(null);
      }, "executor")
    }) : Promise.resolve(null);
  }
  /**
   * This is a special method for vis.
   * It is used to not send to server the changes about "nothing_selected" state
   *
   * @param id The state that has to be ignored by communication
   */
  setStateToIgnore(id) {
    this.ignoreState = id;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Connection,
  ERRORS,
  NOT_CONNECTED,
  PERMISSION_ERROR,
  PROGRESS
});
//# sourceMappingURL=Connection.js.map
