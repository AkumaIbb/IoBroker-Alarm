{
  "version": 3,
  "sources": ["../../src/AdminConnection.ts"],
  "sourcesContent": ["import { Connection, ERRORS, type RequestOptions } from './Connection.js';\nimport type { ConnectionProps } from './ConnectionProps.js';\nimport type {\n    AdminEmitEvents,\n    AdminListenEvents,\n    CompactAdapterInfo,\n    CompactHost,\n    CompactInstalledInfo,\n    CompactInstanceInfo,\n    CompactRepository,\n    CompactSystemRepository,\n    License,\n    LogFile,\n} from './SocketEvents.js';\nimport { getObjectViewResultToArray, normalizeHostId, objectIdToHostname } from './tools.js';\n\ninterface Certificate {\n    name: string;\n    type: 'public' | 'private' | 'chained';\n}\n\n// taken from \"@iobroker/js-controller-common-db/build/lib/common/notificationHandler\"\nexport type MultilingualObject = Exclude<ioBroker.StringOrTranslated, string>;\nexport type Severity = 'info' | 'notify' | 'alert';\nexport interface NotificationMessageObject {\n    message: string;\n    ts: number;\n}\n\ntype DockerInformation =\n    | {\n          /** If it is a Docker installation */\n          isDocker: boolean;\n          /** If it is the official Docker image */\n          isOfficial: true;\n          /** Semver string for official Docker image */\n          officialVersion: string;\n      }\n    | {\n          /** If it is a Docker installation */\n          isDocker: boolean;\n          /** If it is the official Docker image */\n          isOfficial: false;\n      };\n\nexport interface HostInfo {\n    /** Converted OS for human readability */\n    Platform:\n        | 'aix'\n        | 'android'\n        | 'darwin'\n        | 'freebsd'\n        | 'haiku'\n        | 'linux'\n        | 'openbsd'\n        | 'sunos'\n        | 'win32'\n        | 'cygwin'\n        | 'netbsd'\n        | 'docker'\n        | 'Windows'\n        | 'OSX';\n    /** The underlying OS */\n    os:\n        | 'aix'\n        | 'android'\n        | 'darwin'\n        | 'freebsd'\n        | 'haiku'\n        | 'linux'\n        | 'openbsd'\n        | 'sunos'\n        | 'win32'\n        | 'cygwin'\n        | 'netbsd';\n    /** Information about the docker installation */\n    dockerInformation?: DockerInformation;\n    /** Host architecture */\n    Architecture: string;\n    /** Number of CPUs */\n    CPUs: number | null;\n    /** CPU speed */\n    Speed: number | null;\n    /** CPU model */\n    Model: string | null;\n    /** Total RAM of host */\n    RAM: number;\n    /** System uptime in seconds */\n    'System uptime': number;\n    /** Node.JS version */\n    'Node.js': string;\n    /** Current time to compare to local time */\n    time: number;\n    /** Timezone offset to compare to local time */\n    timeOffset: number;\n    /** Number of available adapters */\n    'adapters count': number;\n    /** NPM version */\n    NPM: string;\n    /** Running instances */\n    'Active instances': number;\n    /** Location on disk of iobroker folder */\n    location: string;\n    /** Uptime */\n    Uptime: number;\n    /** Free disk space */\n    'Disk free': number;\n    /** Disk size */\n    'Disk size': number;\n}\n\nexport interface AdapterInformation {\n    /** this flag is only true for the js-controller */\n    controller: boolean;\n    /** adapter version */\n    version: string;\n    /** path to icon of the adapter */\n    icon: string;\n    /** path to local icon of the adapter */\n    localIcon?: string;\n    /** title of the adapter */\n    title: string;\n    /** title of the adapter in multiple languages */\n    titleLang: ioBroker.Translated;\n    /** description of the adapter in multiple languages */\n    desc: ioBroker.Translated;\n    /** platform of the adapter */\n    platform: 'Javascript/Node.js';\n    /** keywords of the adapter */\n    keywords: string[];\n    /** path to a readme file */\n    readme: string;\n    /** The installed adapter version, not existing on controller */\n    runningVersion?: string;\n    /** type of the adapter */\n    type: string;\n    /** license of the adapter */\n    license: string;\n    /** url to license information */\n    licenseUrl?: string;\n}\n\nexport type AdapterRating = {\n    // @ts-expect-error rating is here\n    rating?: { r: number; c: number };\n    [version: string]: { r: number; c: number };\n};\nexport type AdapterRatingInfo = AdapterRating & { title: string };\n\nexport type AdapterInformationEx = AdapterInformation & {\n    installedFrom?: string;\n    enabled: number;\n    count: number;\n    ignoreVersion?: string;\n};\nexport type InstalledInfo = { [adapterName: string]: AdapterInformationEx } & {\n    hosts?: { [hostName: string]: ioBroker.HostCommon & { host: string; runningVersion: string } };\n};\n\ninterface RepositoryEntry {\n    /** Link to external icon */\n    extIcon: string;\n    /** Translated title */\n    titleLang: ioBroker.Translated;\n    [other: string]: unknown;\n}\n\n/** The ioBroker repository */\nexport type Repository = Record<string, RepositoryEntry>;\n\nexport interface FilteredNotificationInformation {\n    [scope: string]: {\n        description: MultilingualObject;\n        name: MultilingualObject;\n        categories: {\n            [category: string]: {\n                description: MultilingualObject;\n                name: MultilingualObject;\n                severity: Severity;\n                instances: {\n                    [instance: string]: {\n                        messages: NotificationMessageObject[];\n                    };\n                };\n            };\n        };\n    };\n}\n\nfunction parseCertificate(name: string, cert: string): Certificate | void {\n    if (!cert) {\n        return;\n    }\n\n    let type: Certificate['type'];\n    // If it is a filename, it could be everything\n    if (cert.length < 700 && (cert.indexOf('/') !== -1 || cert.indexOf('\\\\') !== -1)) {\n        if (name.toLowerCase().includes('private')) {\n            type = 'private';\n        } else if (cert.toLowerCase().includes('private')) {\n            type = 'private';\n        } else if (name.toLowerCase().includes('public')) {\n            type = 'public';\n        } else if (cert.toLowerCase().includes('public')) {\n            type = 'public';\n        } else if (name.toLowerCase().includes('chain')) {\n            type = 'chained';\n        } else if (cert.toLowerCase().includes('chain')) {\n            type = 'chained';\n        } else {\n            // TODO: is this correct?\n            return;\n        }\n    } else {\n        type =\n            cert.substring(0, '-----BEGIN RSA PRIVATE KEY'.length) === '-----BEGIN RSA PRIVATE KEY' ||\n            cert.substring(0, '-----BEGIN PRIVATE KEY'.length) === '-----BEGIN PRIVATE KEY'\n                ? 'private'\n                : 'public';\n\n        if (type === 'public') {\n            const m = cert.split('-----END CERTIFICATE-----');\n            if (m.filter(t => t.replace(/\\r\\n|\\r|\\n/, '').trim()).length > 1) {\n                type = 'chained';\n            }\n        }\n    }\n    return { name, type };\n}\n\nexport interface IPAddress {\n    name: string;\n    address: string;\n    family: 'ipv4' | 'ipv6';\n    internal?: boolean;\n}\n\ninterface IPAddresses {\n    IPs4: IPAddress[];\n    IPs6: IPAddress[];\n}\n\nfunction parseIPAddresses(host: ioBroker.HostObject): IPAddresses {\n    const IPs4: IPAddress[] = [\n        {\n            name: '[IPv4] 0.0.0.0 - Listen on all IPs',\n            address: '0.0.0.0',\n            family: 'ipv4',\n        },\n    ];\n    const IPs6: IPAddress[] = [\n        {\n            name: '[IPv6] :: - Listen on all IPs',\n            address: '::',\n            family: 'ipv6',\n        },\n    ];\n    if (host.native?.hardware?.networkInterfaces) {\n        const list: Record<string, ({ family: 'IPv6' | 'IPv4'; address: string }[]) | undefined> =\n            host.native?.hardware?.networkInterfaces;\n\n        Object.keys(list).forEach(inter => {\n            list[inter]?.forEach(ip => {\n                if (ip.family !== 'IPv6') {\n                    IPs4.push({\n                        name: `[${ip.family}] ${ip.address} - ${inter}`,\n                        address: ip.address,\n                        family: 'ipv4',\n                    });\n                } else {\n                    IPs6.push({\n                        name: `[${ip.family}] ${ip.address} - ${inter}`,\n                        address: ip.address,\n                        family: 'ipv6',\n                    });\n                }\n            });\n        });\n    }\n    return { IPs4, IPs6 };\n}\n\nexport class AdminConnection extends Connection<AdminListenEvents, AdminEmitEvents> {\n    constructor(props: ConnectionProps) {\n        super(props);\n    }\n\n    // We overload the request method here because the admin connection's methods all have `requireAdmin: true`\n    protected request<T>(options: RequestOptions<T>): Promise<T> {\n        return super.request<T>({ requireAdmin: true, ...options });\n    }\n\n    /**\n     * Get the stored certificates.\n     *\n     * @param update Force update.\n     */\n    getCertificates(update?: boolean): Promise<Certificate[]> {\n        return this.request({\n            cacheKey: 'cert',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const obj = await this.getObject('system.certificates');\n                if (obj?.native?.certificates) {\n                    resolve(\n                        Object.entries<string>(obj.native.certificates)\n                            .map(([name, cert]) => parseCertificate(name, cert))\n                            .filter((cert): cert is Certificate => !!cert),\n                    );\n                } else {\n                    resolve([]);\n                }\n            },\n        });\n    }\n\n    /**\n     * Get the logs from a host (only for admin connection).\n     */\n    getLogs(host: string, linesNumber: number = 200): Promise<(string | number)[] | string | { error: string }> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: resolve => {\n                this._socket.emit('sendToHost', host, 'getLogs', linesNumber || 200, (lines: any) => {\n                    resolve(lines);\n                });\n            },\n        });\n    }\n\n    /**\n     * Upgrade adapter with webserver.\n     */\n    upgradeAdapterWithWebserver(\n        host: string,\n        options: {\n            version: string;\n            adapterName: string;\n            port: number;\n            useHttps?: boolean;\n            certPublicName?: string;\n            certPrivateName?: string;\n        },\n    ): Promise<{ result: boolean }> {\n        return this.request({\n            commandTimeout: false,\n            executor: resolve => {\n                this._socket.emit(\n                    'sendToHost',\n                    host,\n                    'upgradeAdapterWithWebserver',\n                    options as any,\n                    (result: unknown) => {\n                        resolve(result as { result: boolean });\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Upgrade controller\n     */\n    upgradeController(host: string, version: string, adminInstance: number): Promise<string> {\n        return this.request({\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'sendToHost',\n                    host,\n                    'upgradeController',\n                    {\n                        version,\n                        adminInstance,\n                    } as any,\n                    (result: unknown) => {\n                        const _result = result as {\n                            result: string;\n                            error?: string;\n                        };\n                        if (_result.error) {\n                            reject(_result.error);\n                        } else {\n                            resolve(_result.result);\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Read licenses from ioBroker.net anew\n     */\n    updateLicenses(\n        /** login for ioBroker.net */\n        login: string,\n        /** password for ioBroker.net */\n        password: string,\n    ): Promise<License[] | undefined> {\n        return this.request({\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('updateLicenses', login, password, (err, licenses?: License[]) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(licenses);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Upgrade controller\n     */\n    upgradeOsPackages(\n        host: string,\n        packages: { name: string; version?: string }[],\n        restart?: boolean,\n    ): Promise<{ success: boolean; error?: string }> {\n        return this.request({\n            commandTimeout: false,\n            executor: resolve => {\n                this._socket.emit(\n                    'sendToHost',\n                    host,\n                    'upgradeOsPackages',\n                    {\n                        packages,\n                        restart: !!restart,\n                    } as any,\n                    (result: unknown) => {\n                        resolve(result as { success: boolean; error?: string });\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Get the log files (only for admin connection).\n     */\n    getLogsFiles(host: string): Promise<LogFile[]> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('readLogs', host, (err, files) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(files!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Delete the logs from a host (only for admin connection).\n     */\n    delLogs(host: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('sendToHost', host, 'delLogs', null, err => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Delete a file of an adapter.\n     *\n     * @param adapter The adapter name.\n     * @param fileName The file name.\n     */\n    deleteFile(adapter: string, fileName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('deleteFile', adapter, fileName, err => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Delete a folder of an adapter.\n     *\n     * @param adapter The adapter name.\n     * @param folderName The folder name.\n     */\n    deleteFolder(adapter: string, folderName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('deleteFolder', adapter, folderName, err => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n    /**\n     * Rename file or folder in ioBroker DB\n     *\n     * @param adapter instance name\n     * @param oldName current file name, e.g., main/vis-views.json\n     * @param newName new file name, e.g., main/vis-views-new.json\n     */\n    rename(adapter: string, oldName: string, newName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('rename', adapter, oldName, newName, err => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Rename file in ioBroker DB\n     *\n     * @param adapter instance name\n     * @param oldName current file name, e.g., main/vis-views.json\n     * @param newName new file name, e.g., main/vis-views-new.json\n     */\n    renameFile(adapter: string, oldName: string, newName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('renameFile', adapter, oldName, newName, err => {\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the list of all hosts.\n     *\n     * @param update Force update.\n     */\n    getHosts(update?: boolean): Promise<ioBroker.HostObject[]> {\n        return this.request({\n            cacheKey: 'hosts',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'getObjectView',\n                    'system',\n                    'host',\n                    { startkey: 'system.host.', endkey: 'system.host.\\u9999' },\n                    (err, doc) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(getObjectViewResultToArray<ioBroker.HostObject>(doc));\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Get the list of all users.\n     *\n     * @param update Force update.\n     */\n    getUsers(update?: boolean): Promise<ioBroker.UserObject[]> {\n        return this.request({\n            cacheKey: 'users',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'getObjectView',\n                    'system',\n                    'user',\n                    { startkey: 'system.user.', endkey: 'system.user.\\u9999' },\n                    (err, doc) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(getObjectViewResultToArray<ioBroker.UserObject>(doc));\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Rename a group.\n     *\n     * @param id The id.\n     * @param newId The new id.\n     * @param newName The new name.\n     */\n    renameGroup(id: string, newId: string, newName: ioBroker.StringOrTranslated): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const groups = await this.getGroups(true);\n                // renaming a group happens by re-creating the object under a different ID\n                const subGroups = groups.filter(g => g._id.startsWith(`${id}.`));\n                // First, do this for all sub-groups\n                for (const group of subGroups) {\n                    const oldGroupId = group._id;\n                    const newGroupId = (newId + group._id.substring(id.length)) as ioBroker.ObjectIDs.Group;\n                    group._id = newGroupId;\n\n                    // Create a new object, then delete the old one if it worked\n                    await this.setObject(newGroupId, group);\n                    await this.delObject(oldGroupId);\n                }\n                // Then for the parent group\n                const parentGroup = groups.find(g => g._id === id);\n                if (parentGroup) {\n                    const oldGroupId = parentGroup._id;\n                    parentGroup._id = newId as ioBroker.ObjectIDs.Group;\n                    if (newName !== undefined) {\n                        (parentGroup.common as any) ??= {};\n                        parentGroup.common.name = newName as any;\n                    }\n\n                    // Create a new object, then delete the old one if it worked\n                    await this.setObject(newId, parentGroup);\n                    await this.delObject(oldGroupId);\n                }\n\n                resolve();\n            },\n        });\n    }\n\n    /**\n     * Get the host information.\n     *\n     * @param host host name\n     * @param update Force update.\n     * @param timeoutMs optional read timeout.\n     */\n    getHostInfo(host: string, update?: boolean, timeoutMs?: number): Promise<HostInfo> {\n        host = normalizeHostId(host);\n        return this.request({\n            cacheKey: `hostInfo_${host}`,\n            forceUpdate: update,\n            commandTimeout: timeoutMs,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getHostInfo', null, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getHostInfo\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getHostInfo\"');\n                    } else {\n                        resolve(data as HostInfo);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the host information (short version).\n     *\n     * @param host host name\n     * @param update Force update.\n     * @param timeoutMs optional read timeout.\n     */\n    getHostInfoShort(host: string, update?: boolean, timeoutMs?: number): Promise<HostInfo> {\n        host = normalizeHostId(host);\n        return this.request({\n            cacheKey: `hostInfoShort_${host}`,\n            forceUpdate: update,\n            commandTimeout: timeoutMs,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getHostInfoShort', null, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getHostInfoShort\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getHostInfoShort\"');\n                    } else {\n                        resolve(data as HostInfo);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the repository.\n     *\n     * @param host The host name.\n     * @param args The arguments.\n     * @param update Force update.\n     * @param timeoutMs timeout in ms.\n     */\n    getRepository(\n        host: string,\n        args?: { update?: boolean; repo?: string | string[] } | string | null,\n        update?: boolean,\n        timeoutMs?: number,\n    ): Promise<Repository> {\n        return this.request({\n            cacheKey: `repository_${host}`,\n            forceUpdate: update,\n            commandTimeout: timeoutMs,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getRepository', args, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getRepository\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getRepository\"');\n                    } else {\n                        resolve(data as Repository);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the installed.\n     *\n     * @param host The host name.\n     * @param update Force update.\n     * @param cmdTimeout timeout in ms\n     */\n    getInstalled(host: string, update?: boolean, cmdTimeout?: number): Promise<InstalledInfo> {\n        host = normalizeHostId(host);\n\n        return this.request({\n            cacheKey: `installed_${host}`,\n            forceUpdate: update,\n            commandTimeout: cmdTimeout,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getInstalled', null, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getInstalled\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getInstalled\"');\n                    } else {\n                        resolve(data as InstalledInfo);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Execute a command on a host.\n     */\n    cmdExec(\n        /** The host name. */\n        host: string,\n        /** The command to execute. */\n        cmd: string,\n        /** The command ID. */\n        cmdId: number,\n        /** Timeout of command in ms */\n        cmdTimeout?: number,\n    ): Promise<void> {\n        return this.request({\n            commandTimeout: cmdTimeout,\n            executor: (resolve, reject, timeout) => {\n                host = normalizeHostId(host);\n\n                this._socket.emit('cmdExec', host, cmdId, cmd, err => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Read the base settings of a given host.\n     *\n     * @param host The host name.\n     */\n    readBaseSettings(host: string): Promise<{ config?: ioBroker.IoBrokerJson; isActive?: boolean }> {\n        // Make sure we deal with a hostname, not an object ID\n        host = objectIdToHostname(host);\n\n        return this.request({\n            requireFeatures: ['CONTROLLER_READWRITE_BASE_SETTINGS'],\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'readBaseSettings', null, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"BaseSettings\"');\n                    } else if (!data) {\n                        reject('Cannot read \"BaseSettings\"');\n                    } else if ((data as { error?: string }).error) {\n                        reject(new Error((data as { error?: string }).error));\n                    } else {\n                        resolve(data as { config: ioBroker.IoBrokerJson; isActive: boolean });\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Write the base settings of a given host.\n     *\n     * @param host The host name.\n     * @param config The configuration to write.\n     */\n    writeBaseSettings(host: string, config: ioBroker.IoBrokerJson): Promise<{ error?: string; result?: 'ok' }> {\n        // Make sure we deal with a hostname, not an object ID\n        host = objectIdToHostname(host);\n\n        return this.request({\n            requireFeatures: ['CONTROLLER_READWRITE_BASE_SETTINGS'],\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'writeBaseSettings', config, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not write \"BaseSettings\"');\n                    } else if (!data) {\n                        reject('Cannot write \"BaseSettings\"');\n                    } else {\n                        resolve(data);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Send command to restart the iobroker on host\n     *\n     * @param host The host name.\n     */\n    restartController(host: string): Promise<true> {\n        // Make sure we deal with a hostname, not an object ID\n        host = objectIdToHostname(host);\n\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'restartController', null, () => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    resolve(true);\n                });\n            },\n        });\n    }\n\n    /**\n     * Read statistics information from host\n     *\n     * @param host The host name.\n     * @param typeOfDiag one of none, normal, no-city, extended\n     */\n    getDiagData(\n        host: string,\n        typeOfDiag: 'none' | 'normal' | 'no-city' | 'extended',\n    ): Promise<Record<string, any> | null> {\n        // Make sure we deal with a hostname, not an object ID\n        host = objectIdToHostname(host);\n\n        return this.request({\n            executor: (resolve, _reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getDiagData', typeOfDiag, result => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (!result) {\n                        resolve(null);\n                    } else {\n                        resolve(result as Promise<Record<string, any>>);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Change the password of the given user.\n     *\n     * @param user The user name.\n     * @param password The new password.\n     */\n    changePassword(user: string, password: string): Promise<void> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('changePassword', user, password, err => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve();\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the IP addresses of the given host.\n     *\n     * @param host The host name.\n     * @param update Force update.\n     */\n    getIpAddresses(host: string, update?: boolean): Promise<string[]> {\n        host = normalizeHostId(host);\n        return this.request({\n            cacheKey: `IPs_${host}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const obj = await this.getObject(host);\n                resolve(obj?.common.address ?? []);\n            },\n        });\n    }\n\n    /**\n     * Get the IP addresses with interface names of the given host or find host by IP.\n     *\n     * @param ipOrHostName The IP address or host name.\n     * @param update Force update.\n     */\n    getHostByIp(ipOrHostName: string, update?: boolean): Promise<IPAddress[]> {\n        // Make sure we deal with a hostname, not an object ID\n        ipOrHostName = objectIdToHostname(ipOrHostName);\n\n        return this.request({\n            cacheKey: `rIPs_${ipOrHostName}`,\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getHostByIp', ipOrHostName, (ip, host) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    const { IPs4, IPs6 } = parseIPAddresses(host);\n                    resolve([...IPs4, ...IPs6]);\n                });\n            },\n        });\n    }\n\n    /**\n     * Encrypt a text\n     *\n     * @param plaintext The text to encrypt.\n     */\n    encrypt(plaintext: string): Promise<string> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('encrypt', plaintext, (err, ciphertext) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(ciphertext!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Decrypt a text\n     *\n     * @param ciphertext The text to decrypt.\n     */\n    decrypt(ciphertext: string): Promise<string> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('decrypt', ciphertext, (err, plaintext) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(plaintext!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Change access rights for file\n     *\n     * @param adapter adapter name\n     * @param path file name with a full path. It could be like 'vis.0/*'\n     * @param options like {mode: 0x644}\n     * @param options.mode The new mode for the file\n     */\n    chmodFile(\n        adapter: string | null,\n        path: string,\n        options?: { mode: number | string },\n    ): Promise<ioBroker.ChownFileResult[]> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('chmodFile', adapter, path, options, (err, processed) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(processed!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Change an owner or/and owner group for file\n     *\n     * @param adapter adapter name\n     * @param filename file name with a full path. it could be like vis.0/*\n     * @param options like {owner: \"newOwner\", ownerGroup: \"newGroup\"}\n     * @param options.owner The new owner for the file\n     * @param options.ownerGroup The new owner group for the file\n     */\n    chownFile(\n        adapter: string,\n        filename: string,\n        options?: { owner?: string; ownerGroup?: string },\n    ): Promise<ioBroker.ChownFileResult[]> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('chownFile', adapter, filename, options, (err, processed) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(processed!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the alarm notifications from a host (only for admin connection).\n     *\n     * @param host The host name.\n     * @param category - optional\n     */\n    getNotifications(host: string, category?: string): Promise<void | { result: FilteredNotificationInformation }> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'getNotifications', { category }, notifications => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    resolve(\n                        notifications as {\n                            result: FilteredNotificationInformation;\n                        },\n                    );\n                });\n            },\n        });\n    }\n\n    /**\n     * Clear the alarm notifications on a host (only for admin connection).\n     *\n     * @param host The host name.\n     * @param category - optional\n     */\n    clearNotifications(host: string, category: string): Promise<{ result: 'ok' }> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('sendToHost', host, 'clearNotifications', { category }, result => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    resolve(result as { result: 'ok' });\n                });\n            },\n        });\n    }\n\n    /**\n     * Read if only easy mode is allowed (only for admin connection).\n     */\n    getIsEasyModeStrict(): Promise<boolean> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getIsEasyModeStrict', (err, isStrict) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(!!isStrict);\n                });\n            },\n        });\n    }\n\n    /**\n     * Read easy mode configuration (only for admin connection).\n     */\n    getEasyMode(): Promise<{\n        strict: boolean;\n        configs: {\n            id: string;\n            title: ioBroker.StringOrTranslated;\n            desc: ioBroker.StringOrTranslated;\n            color: string;\n            url: string;\n            icon: string;\n            materialize: boolean;\n            jsonConfig: boolean;\n            version: string;\n        }[];\n    }> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getEasyMode', (err, config) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n\n                    timeout.clearTimeout();\n\n                    if (err) {\n                        reject(new Error(err));\n                    } else {\n                        resolve(\n                            config as {\n                                strict: boolean;\n                                configs: {\n                                    id: string;\n                                    title: ioBroker.StringOrTranslated;\n                                    desc: ioBroker.StringOrTranslated;\n                                    color: string;\n                                    url: string;\n                                    icon: string;\n                                    materialize: boolean;\n                                    jsonConfig: boolean;\n                                    version: string;\n                                }[];\n                            },\n                        );\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Read adapter ratings\n     */\n    getRatings(update?: boolean): Promise<{ [adapterName: string]: AdapterRating } & { uuid: string }> {\n        return this.request({\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getRatings', !!update, (err, ratings) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(new Error(err));\n                    } else {\n                        resolve(ratings as { [adapterName: string]: AdapterRating } & { uuid: string });\n                    }\n                });\n            },\n        });\n    }\n\n    getCurrentSession(cmdTimeout?: number): Promise<{ expireInSec?: number; error?: string }> {\n        const controller = new AbortController();\n\n        return this.request({\n            commandTimeout: cmdTimeout || 5000,\n            onTimeout: () => {\n                controller.abort();\n            },\n            executor: async (resolve, reject, timeout) => {\n                try {\n                    const res = await fetch('./session', {\n                        signal: controller.signal,\n                    });\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    const result: { expireInSec?: number; error?: string } = await res.json();\n                    resolve(result);\n                } catch (e) {\n                    reject(`getCurrentSession: ${e}`);\n                }\n            },\n        });\n    }\n\n    /**\n     * Read current web, socketio or admin namespace, like admin.0\n     */\n    getCurrentInstance(): Promise<string> {\n        return this.request({\n            cacheKey: 'currentInstance',\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCurrentInstance', (err, namespace) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(namespace!);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get all instances of the given adapter or get all instances.\n     *\n     * @param adapter The name of the adapter.\n     * @param update Force update.\n     */\n    getAdapterInstances(adapter?: string | boolean, update?: boolean): Promise<ioBroker.InstanceObject[]> {\n        let adapterStr: string;\n        if (typeof adapter === 'boolean') {\n            update = adapter;\n            adapterStr = '';\n        } else {\n            adapterStr = adapter || '';\n        }\n\n        return this.request({\n            cacheKey: `instances_${adapterStr}`,\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getAdapterInstances', adapterStr, (err, instances) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(instances!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Get adapters with the given name or get all adapters.\n     *\n     * @param adapter The name of the adapter.\n     * @param update Force update.\n     */\n    getAdapters(adapter?: string | boolean, update?: boolean): Promise<ioBroker.AdapterObject[]> {\n        let adapterStr: string;\n        if (typeof adapter === 'boolean') {\n            update = adapter;\n            adapterStr = '';\n        } else {\n            adapterStr = adapter || '';\n        }\n\n        return this.request({\n            cacheKey: `adapter_${adapterStr}`,\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getAdapters', adapterStr, (err, adapters) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(adapters!);\n                });\n            },\n        });\n    }\n\n    // returns very optimized information for adapters to minimize a connection load\n    getCompactAdapters(update?: boolean): Promise<Record<string, CompactAdapterInfo>> {\n        return this.request({\n            cacheKey: 'compactAdapters',\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactAdapters', (err, adapters) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(adapters!);\n                });\n            },\n        });\n    }\n\n    // reset cached promise, so next time the information will be requested anew\n    getAdaptersResetCache(adapter?: string): void {\n        adapter = adapter ?? '';\n        this.resetCache(`adapter_${adapter}`);\n        this.resetCache(`compactAdapters`);\n    }\n\n    // returns very optimized information for adapters to minimize a connection load\n    getCompactInstances(update?: boolean): Promise<Record<string, CompactInstanceInfo>> {\n        return this.request({\n            cacheKey: 'compactInstances',\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactInstances', (err, instances) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(instances!);\n                });\n            },\n        });\n    }\n\n    // reset cached promise, so next time the information will be requested anew\n    getAdapterInstancesResetCache(adapter?: string): void {\n        adapter = adapter ?? '';\n        this.resetCache(`instances_${adapter}`);\n        this.resetCache(`compactInstances`);\n    }\n\n    // returns very optimized information for adapters to minimize a connection load\n    // reads only a version of installed adapter\n    getCompactInstalled(host: string, update?: boolean, cmdTimeout?: number): Promise<CompactInstalledInfo> {\n        host = normalizeHostId(host);\n\n        return this.request({\n            cacheKey: `installedCompact_${host}`,\n            forceUpdate: update,\n            commandTimeout: cmdTimeout,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactInstalled', host, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getCompactInstalled\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getCompactInstalled\"');\n                    } else {\n                        resolve(data);\n                    }\n                });\n            },\n        });\n    }\n\n    // reset cached promise, so next time the information will be requested anew\n    getInstalledResetCache(host?: string): void {\n        if (!host) {\n            this.resetCache(`installedCompact_`, true);\n            this.resetCache(`installed_`, true);\n        } else {\n            this.resetCache(`installedCompact_${host}`);\n            this.resetCache(`installed_${host}`);\n        }\n    }\n\n    /**\n     * Get the repository in compact form (only version and icon).\n     *\n     * @param host The host name.\n     * @param update Force update.\n     * @param timeoutMs timeout in ms.\n     */\n    getCompactRepository(host: string, update?: boolean, timeoutMs?: number): Promise<CompactRepository> {\n        host = normalizeHostId(host);\n\n        return this.request({\n            cacheKey: `repositoryCompact_${host}`,\n            forceUpdate: update,\n            commandTimeout: timeoutMs,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactRepository', host, data => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (data === ERRORS.PERMISSION_ERROR) {\n                        reject('May not read \"getCompactRepository\"');\n                    } else if (!data) {\n                        reject('Cannot read \"getCompactRepository\"');\n                    } else {\n                        resolve(data);\n                    }\n                });\n            },\n        });\n    }\n\n    // reset cached promise, so next time the information will be requested anew\n    getRepositoryResetCache(host: string): void {\n        if (!host) {\n            this.resetCache(`repositoryCompact_`, true);\n            this.resetCache(`repository_`, true);\n        } else {\n            this.resetCache(`repositoryCompact_${host}`);\n            this.resetCache(`repository_${host}`);\n        }\n    }\n\n    /**\n     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)\n     *\n     * @param update Force update.\n     */\n    getCompactHosts(update?: boolean): Promise<CompactHost[]> {\n        return this.request({\n            cacheKey: 'hostsCompact',\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactHosts', (err, compactHostsInfo) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(compactHostsInfo!);\n                });\n            },\n        });\n    }\n\n    /**\n     * Get `system.repository` without big JSON\n     */\n    getCompactSystemRepositories(update?: boolean): Promise<CompactSystemRepository> {\n        return this.request({\n            cacheKey: 'repositoriesCompact',\n            forceUpdate: update,\n            executor: (resolve, reject, timeout) => {\n                this._socket.emit('getCompactSystemRepositories', (err, systemRepositories) => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n                    if (err) {\n                        reject(err);\n                    }\n                    resolve(systemRepositories!);\n                });\n            },\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
