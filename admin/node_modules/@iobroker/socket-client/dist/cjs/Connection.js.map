{
  "version": 3,
  "sources": ["../../src/Connection.ts"],
  "sourcesContent": ["import type { ConnectionProps, LogMessage } from './ConnectionProps.js';\nimport { createDeferredPromise } from './DeferredPromise.js';\nimport type { EmitEventHandler, ListenEventHandler, SocketClient } from './SocketClient.js';\nimport { getObjectViewResultToArray, normalizeHostId, pattern2RegEx, wait } from './tools.js';\n\nif (typeof (globalThis as any).process !== 'undefined') {\n    // Implement location, localStorage and sessionStorage for Node.js environment\n    // @ts-expect-error globalThis.location is not defined in Node.js\n    globalThis.location ||= {\n        href: 'http://localhost:8081/',\n        protocol: 'http:',\n        host: 'localhost:8081',\n        pathname: '/',\n        hostname: 'localhost',\n        reload: () => {},\n    };\n    // @ts-expect-error globalThis.location is not defined in Node.js\n    globalThis.localStorage ||= {\n        _keys: {} as { [key: string]: string },\n        setItem: (key: string, value: string) => {\n            globalThis.localStorage._keys[key] = value;\n        },\n        getItem: (key: string): string | null => {\n            if (key in globalThis.localStorage._keys) {\n                return globalThis.localStorage._keys[key];\n            }\n            return null;\n        },\n        removeItem: (key: string) => {\n            if (key in globalThis.localStorage._keys) {\n                delete globalThis.localStorage._keys[key];\n            }\n        },\n    };\n    globalThis.sessionStorage ||= globalThis.localStorage;\n    globalThis.navigator ||= {\n        language: 'en',\n    } as Navigator;\n}\n\nexport interface OAuth2Response {\n    /** The access token */\n    access_token: string;\n    /** The time in seconds when the access token expires, e.g., 3600 for 1 hour */\n    expires_in: number;\n    /** The type of the token */\n    token_type: 'Bearer' | 'JWT';\n    /** The refresh token */\n    refresh_token: string;\n    /** The time in seconds when the refresh token expires, e.g., 600 for 10 minutes */\n    refresh_token_expires_in: number;\n}\n\nexport interface StoredTokens {\n    refresh_token: string;\n    access_token: string;\n    expires_in: Date;\n    refresh_token_expires_in: Date;\n    stayLoggedIn: boolean;\n    owner: string | undefined;\n}\n\nexport interface SocketACL {\n    user: `system.user.${string}` | '';\n    groups: `system.group.${string}`[];\n    object?: {\n        read: boolean;\n        list: boolean;\n        write: boolean;\n        delete: boolean;\n    };\n    state?: {\n        list: boolean;\n        read: boolean;\n        write: boolean;\n        delete: boolean;\n        create: boolean;\n    };\n    users?: {\n        create: boolean;\n        delete: boolean;\n        write: boolean;\n    };\n    other?: {\n        http: boolean;\n        execute: boolean;\n        sendto: boolean;\n    };\n    file?: {\n        list: boolean;\n        create: boolean;\n        write: boolean;\n        read: boolean;\n        delete: boolean;\n    };\n}\n\n/** Possible progress states. */\nexport enum PROGRESS {\n    /** The socket is connecting. */\n    CONNECTING = 0,\n    /** The socket is successfully connected. */\n    CONNECTED = 1,\n    /** All objects are loaded. */\n    OBJECTS_LOADED = 2,\n    /** The socket is ready for use. */\n    READY = 3,\n}\n\nexport enum ERRORS {\n    PERMISSION_ERROR = 'permissionError',\n    NOT_CONNECTED = 'notConnectedError',\n    TIMEOUT = 'timeout',\n    NOT_ADMIN = 'Allowed only in admin',\n    NOT_SUPPORTED = 'Not supported',\n}\n\n/** @deprecated Use {@link ERRORS.PERMISSION_ERROR} instead */\nexport const PERMISSION_ERROR = ERRORS.PERMISSION_ERROR;\n/** @deprecated Use {@link ERRORS.NOT_CONNECTED} instead */\nexport const NOT_CONNECTED = ERRORS.NOT_CONNECTED;\n\n// Options to use for the backend request wrapper\n/**\n * @internal\n */\nexport interface RequestOptions<T> {\n    /** The key that is used to cache the results for later requests of the same kind */\n    cacheKey?: string;\n    /** Used to bypass the cache */\n    forceUpdate?: boolean;\n    /** Can be used to identify the request method in error messages */\n    requestName?: string;\n    /**\n     * The timeout in milliseconds after which the call will reject with a timeout error.\n     * If no timeout is given, the default is used. Set this to `false` to explicitly disable the timeout.\n     */\n    commandTimeout?: number | false;\n    /** Will be called when the timeout elapses */\n    onTimeout?: () => void;\n    /** Whether the call should only be allowed in the admin adapter */\n    requireAdmin?: boolean;\n    /** Require certain features to be supported for this call */\n    requireFeatures?: string[];\n    /** The function that does the actual work */\n    executor: (\n        resolve: (value: T | PromiseLike<T> | Promise<T>) => void,\n        reject: (reason?: any) => void,\n        /** Can be used to check in the executor whether the request has timed out and/or stop it from timing out */\n        timeout: Readonly<{ elapsed: boolean; clearTimeout: () => void }>,\n    ) => void | Promise<void>;\n}\n\nexport type BinaryStateChangeHandler = (id: string, base64: string | null) => void;\n\nexport type FileChangeHandler = (\n    id: string,\n    fileName: string,\n    size: number | null, // null if deleted\n) => void;\n\nexport interface OldObject {\n    _id: string;\n    type: string;\n}\n\nexport type ObjectChangeHandler = (\n    id: string,\n    obj: ioBroker.Object | null | undefined,\n    oldObj?: OldObject,\n) => void | Promise<void>;\n\nexport type InstanceMessageCallback = (data: any, sourceInstance: string, messageType: string) => void | Promise<void>;\n\nexport type InstanceSubscribe = {\n    messageType: string;\n    callback: InstanceMessageCallback;\n};\n\nconst ADAPTERS = ['material', 'echarts', 'vis'];\n\nexport class Connection<\n    CustomListenEvents extends Record<keyof CustomListenEvents, ListenEventHandler> = Record<string, never>,\n    CustomEmitEvents extends Record<keyof CustomEmitEvents, EmitEventHandler> = Record<string, never>,\n> {\n    private readonly props: ConnectionProps;\n    public readonly connId: string;\n    private lastAccessToken: string | null = null;\n\n    private ignoreState: string = '';\n    private connected: boolean = false;\n    private subscribed: boolean = false;\n    private firstConnect: boolean = true;\n    public waitForRestart: boolean = false;\n    public loaded: boolean = false;\n    private simStates: Record<string, ioBroker.State> = {};\n    private objectViewCached:\n        | { [key: string]: Record<string, ioBroker.AnyObject & { type: ioBroker.ObjectType }> }\n        | undefined;\n\n    /**\n     * Creates a new instance of the Connection class.\n     *\n     * @param props The connection properties.\n     */\n\n    constructor(props: Partial<ConnectionProps>) {\n        this.props = this.applyDefaultProps(props);\n\n        // Create unique ID of this instance\n        this.connId = `${this.props.name ? `${this.props.name}-` : ''}${Math.round(Math.random() * 1000000)\n            .toString()\n            .padStart(6, '0')}`;\n\n        this.waitForSocketLib()\n            .then(() => this.startSocket())\n            .catch(e => {\n                alert(`Socket connection could not be initialized: ${e}`);\n            });\n    }\n\n    private applyDefaultProps(props: Partial<ConnectionProps>): ConnectionProps {\n        return {\n            ...props,\n            // Define default props that always need to be set\n            protocol: props.protocol || globalThis.location.protocol,\n            host: props.host || globalThis.location.hostname,\n            port: props.port || (globalThis.location.port === '3000' ? 8081 : globalThis.location.port),\n            ioTimeout: Math.max(props.ioTimeout || 20000, 20000),\n            cmdTimeout: Math.max(props.cmdTimeout || 5000, 5000),\n            admin5only: props.admin5only || false,\n            autoSubscribes: props.autoSubscribes ?? [],\n            autoSubscribeLog: props.autoSubscribeLog ?? false,\n            doNotLoadACL: props.doNotLoadACL ?? true,\n            doNotLoadAllObjects: props.doNotLoadAllObjects ?? true,\n        };\n    }\n\n    private readonly statesSubscribes: Record<\n        string,\n        {\n            reg: RegExp;\n            cbs: (ioBroker.StateChangeHandler | BinaryStateChangeHandler)[];\n        }\n    > = {};\n    private readonly filesSubscribes: Record<\n        string,\n        {\n            regId: RegExp;\n            regFilePattern: RegExp;\n            cbs: FileChangeHandler[];\n        }\n    > = {};\n    private readonly objectsSubscribes: Record<string, { reg: RegExp; cbs: ObjectChangeHandler[] }> = {};\n    private objects: Record<string, ioBroker.Object> = {};\n    private states: Record<string, ioBroker.State> = {};\n\n    public acl: SocketACL | null = null;\n    public isSecure: boolean = false;\n    // Do not inform about readiness two times\n    public onReadyDone: boolean = false;\n\n    private readonly onConnectionHandlers: ((connected: boolean) => void)[] = [];\n    private readonly onLogHandlers: ((message: LogMessage) => void)[] = [];\n\n    private onCmdStdoutHandler?: (id: string, text: string) => void;\n    private onCmdStderrHandler?: (id: string, text: string) => void;\n    private onCmdExitHandler?: (id: string, exitCode: number) => void;\n    private onError(error: any): void {\n        (this.props.onError ?? console.error)(error);\n    }\n\n    /** The socket instance */\n    protected _socket!: SocketClient<CustomListenEvents, CustomEmitEvents>;\n\n    private _waitForSocketPromise?: Promise<void>;\n    private readonly _waitForFirstConnectionPromise = createDeferredPromise();\n\n    /** array with all subscriptions to instances */\n    private _instanceSubscriptions: Record<string, InstanceSubscribe[]> = {};\n\n    /** Cache for server requests */\n    private readonly _promises: Record<string, Promise<any>> = {};\n\n    protected _authTimer: ReturnType<typeof setTimeout> | null = null;\n    protected _refreshTimer: ReturnType<typeof setTimeout> | null = null;\n\n    protected _systemConfig?: ioBroker.SystemConfigObject;\n    /** The \"system.config\" object */\n    public get systemConfig(): Readonly<ioBroker.SystemConfigObject> | undefined {\n        return this._systemConfig;\n    }\n\n    /** System language. It could be changed during runtime */\n    public systemLang: ioBroker.Languages = 'en';\n\n    /**\n     * Checks if this connection is running in a web adapter and not in an admin.\n     *\n     * @returns True if running in a web adapter or in a socketio adapter.\n     */\n    static isWeb(): boolean {\n        return (globalThis as any).socketUrl !== undefined;\n    }\n\n    private waitForSocketLib(): Promise<void> {\n        // Only wait once\n        if (this._waitForSocketPromise) {\n            return this._waitForSocketPromise;\n        }\n\n        // eslint-disable-next-line no-async-promise-executor\n        this._waitForSocketPromise = new Promise(async (resolve, reject) => {\n            // Connect function was provided, so we do not need to wait for the socket.io library\n            if (this.props.connect) {\n                resolve();\n                return;\n            }\n\n            // If socket io is not yet loaded, we need to wait for it\n            if (typeof (globalThis as any).io === 'undefined' && typeof (globalThis as any).iob === 'undefined') {\n                // If the registerSocketOnLoad function is defined in index.html,\n                // we can use it to know when the socket library was loaded\n                if (typeof (globalThis as any).registerSocketOnLoad === 'function') {\n                    (globalThis as any).registerSocketOnLoad(() => resolve());\n                } else {\n                    // otherwise, we need to poll\n                    for (let i = 1; i <= 30; i++) {\n                        if ((globalThis as any).io || (globalThis as any).iob) {\n                            return resolve();\n                        }\n                        await wait(100);\n                    }\n\n                    reject(new Error('Socket library could not be loaded!'));\n                }\n            } else {\n                resolve();\n            }\n        });\n        return this._waitForSocketPromise;\n    }\n\n    /**\n     * Starts the socket.io connection.\n     */\n    async startSocket(): Promise<void> {\n        if (this._socket) {\n            return;\n        }\n\n        let host = this.props.host;\n        let port = this.props.port;\n        let protocol = (this.props.protocol || globalThis.location.protocol).replace(':', '');\n        let path = globalThis.location.pathname;\n\n        if (globalThis.location.hostname === 'iobroker.net' || globalThis.location.hostname === 'iobroker.pro') {\n            path = '';\n        } else {\n            // if web adapter, socket io could be on another port or even host\n            if ((globalThis as any).socketUrl) {\n                const parsed = new globalThis.URL((globalThis as any).socketUrl);\n                host = parsed.hostname;\n                port = parsed.port;\n                protocol = parsed.protocol.replace(':', '');\n            }\n            // get a current path\n            const pos = path.lastIndexOf('/');\n            if (pos !== -1) {\n                path = path.substring(0, pos + 1);\n            }\n\n            if (Connection.isWeb()) {\n                // remove one level, like echarts, vis, .... We have here: '/echarts/'\n                const parts = path.split('/');\n                if (parts.length > 2) {\n                    parts.pop();\n                    parts.pop();\n                    // material can have paths like this '/material/1.3.0/', so remove one more level\n                    if (ADAPTERS.includes(parts[parts.length - 1])) {\n                        parts.pop();\n                    }\n                    path = parts.join('/');\n                    if (!path.endsWith('/')) {\n                        path += '/';\n                    }\n                }\n            }\n        }\n\n        const url = port ? `${protocol}://${host}:${port}` : `${protocol}://${host}`;\n\n        const connectFunc: (name: string, par: any) => SocketClient =\n            this.props.connect || ((globalThis as any).io || (globalThis as any).iob).connect;\n\n        this._socket = connectFunc(url, {\n            path: path.endsWith('/') ? `${path}socket.io` : `${path}/socket.io`,\n            query: 'ws=true',\n            name: this.props.name,\n            timeout: this.props.ioTimeout,\n            uuid: this.props.uuid,\n            token: this.props.token,\n        });\n\n        this._socket.on('connect', noTimeout => {\n            // Listen for messages from other tabs\n            globalThis.addEventListener?.('storage', this.onAccessTokenUpdated);\n\n            const tokens = Connection.readTokens();\n            if (tokens && !tokens.owner) {\n                // Take the ownership of the token\n                const now = Date.now();\n                this.saveTokens(\n                    {\n                        access_token: tokens.access_token,\n                        refresh_token: tokens.refresh_token,\n                        expires_in: Math.round((tokens.expires_in.getTime() - now) / 1000),\n                        refresh_token_expires_in: Math.round((tokens.refresh_token_expires_in.getTime() - now) / 1000),\n                        token_type: 'Bearer',\n                    },\n                    tokens.stayLoggedIn,\n                );\n            }\n\n            this.onReadyDone = false;\n            // If the user is not admin, it takes some time to install the handlers, because all rights must be checked\n            if (noTimeout !== true) {\n                this.connected = true;\n                setTimeout(\n                    () =>\n                        this.getVersion()\n                            .then(info => {\n                                const [major, minor, patch] = info.version.split('.');\n                                const v = parseInt(major, 10) * 10000 + parseInt(minor, 10) * 100 + parseInt(patch, 10);\n                                if (v < 40102) {\n                                    this._authTimer = null;\n                                    // possible this is an old version of admin\n                                    this.onPreConnect(false, false);\n                                } else {\n                                    this._socket.emit('authenticate', (isOk, isSecure) =>\n                                        this.onPreConnect(isOk, isSecure),\n                                    );\n                                }\n                            })\n                            .catch(e =>\n                                this.onError({\n                                    message: e.toString(),\n                                    operation: 'getVersion',\n                                }),\n                            ),\n                    500,\n                );\n            } else {\n                // iobroker websocket waits, till all handlers are installed\n                this._socket.emit('authenticate', (isOk, isSecure) => {\n                    this.onPreConnect(isOk, isSecure);\n                });\n            }\n        });\n\n        this._socket.on('reconnect', () => {\n            this.onReadyDone = false;\n            this.props.onProgress?.(PROGRESS.READY);\n            this.connected = true;\n\n            if (this.waitForRestart) {\n                globalThis.location.reload();\n            } else {\n                this._subscribe(true);\n                this.onConnectionHandlers.forEach(cb => cb(true));\n            }\n        });\n\n        this._socket.on('disconnect', () => {\n            this.onReadyDone = false;\n            this.connected = false;\n            this.subscribed = false;\n            this.props.onProgress?.(PROGRESS.CONNECTING);\n            this.onConnectionHandlers.forEach(cb => cb(false));\n        });\n\n        this._socket.on('reauthenticate', () => this.authenticate());\n\n        this._socket.on('log', (message: LogMessage) => {\n            this.props.onLog?.(message);\n            this.onLogHandlers.forEach(cb => cb(message));\n        });\n\n        this._socket.on('error', (err: any) => {\n            let _err: string;\n\n            if (err == undefined) {\n                _err = '';\n            } else if (typeof err.toString === 'function') {\n                _err = err.toString();\n            } else {\n                _err = JSON.stringify(err);\n                console.error(`Received strange error: ${_err}`);\n            }\n\n            if (_err.includes('User not authorized')) {\n                this.authenticate();\n            } else if (_err.includes('websocket error')) {\n                console.error(`Socket Error => reload: ${err}`);\n                globalThis.location.reload();\n            } else {\n                console.error(`Socket Error: ${err}`);\n            }\n        });\n\n        this._socket.on('connect_error', (err: any) => console.error(`Connect error: ${err}`));\n\n        this._socket.on('permissionError', err =>\n            this.onError({\n                message: 'no permission',\n                operation: err.operation,\n                type: err.type,\n                id: err.id || '',\n            }),\n        );\n\n        this._socket.on('objectChange', (id, obj) => {\n            setTimeout(() => this.objectChange(id, obj), 0);\n        });\n\n        this._socket.on('stateChange', (id, state) => {\n            setTimeout(() => this.stateChange(id, state), 0);\n        });\n\n        // instance message\n        this._socket.on('im', (messageType, from, data) => {\n            setTimeout(() => this.instanceMessage(messageType, from, data), 0);\n        });\n\n        this._socket.on('fileChange', (id, fileName, size) => {\n            setTimeout(() => this.fileChange(id, fileName, size), 0);\n        });\n\n        this._socket.on('cmdStdout', (id, text) => {\n            this.onCmdStdoutHandler?.(id, text);\n        });\n\n        this._socket.on('cmdStderr', (id, text) => {\n            this.onCmdStderrHandler?.(id, text);\n        });\n\n        this._socket.on('cmdExit', (id, exitCode) => {\n            this.onCmdExitHandler?.(id, exitCode);\n        });\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Called internally.\n     */\n    private onPreConnect(_isOk: boolean, isSecure: boolean): void {\n        if (this._authTimer) {\n            clearTimeout(this._authTimer);\n            this._authTimer = null;\n        }\n\n        this.connected = true;\n        this.isSecure = isSecure;\n\n        if (this.waitForRestart) {\n            globalThis.location.reload();\n        } else {\n            if (this.firstConnect) {\n                void this.loadData().catch(e => {\n                    console.error(`Cannot load data: ${e}`);\n                });\n            } else {\n                this.props.onProgress?.(PROGRESS.READY);\n            }\n\n            this._subscribe(true);\n            this.onConnectionHandlers.forEach(cb => cb(true));\n\n            this.checkAccessTokenExpire();\n        }\n\n        this._waitForFirstConnectionPromise.resolve();\n    }\n\n    static readTokens(): StoredTokens | null {\n        let tokenString: string | null | undefined = globalThis.sessionStorage.getItem('iob_tokens');\n        const stayLoggedIn = !tokenString;\n        if (!tokenString) {\n            tokenString = globalThis.localStorage.getItem('iob_tokens');\n        }\n        if (!tokenString) {\n            return null;\n        }\n\n        const [refresh_token, refresh_token_expires_in, access_token, expires_in, owner] = tokenString.split(';');\n        const refreshExpires = new Date(refresh_token_expires_in);\n        if (refreshExpires.getTime() < Date.now()) {\n            // refresh token expired\n            return null;\n        }\n        return {\n            refresh_token,\n            refresh_token_expires_in: refreshExpires,\n            access_token,\n            expires_in: new Date(expires_in),\n            owner,\n            stayLoggedIn,\n        };\n    }\n\n    static saveTokensStatic(data: OAuth2Response, stayLoggedIn: boolean, owner?: string): void {\n        const tokenStr = `${data.refresh_token};${new Date(Date.now() + data.refresh_token_expires_in * 1000).toISOString()};${data.access_token};${new Date(Date.now() + data.expires_in * 1000).toISOString()}${owner ? `;${owner}` : ''}`;\n        if (stayLoggedIn) {\n            globalThis.localStorage.setItem('iob_tokens', tokenStr);\n        } else {\n            globalThis.sessionStorage.setItem('iob_tokens', tokenStr);\n        }\n    }\n\n    public saveTokens(data: OAuth2Response, stayLoggedIn: boolean): void {\n        Connection.saveTokensStatic(data, stayLoggedIn, this.connId);\n    }\n\n    static deleteTokensStatic(): void {\n        globalThis.localStorage.removeItem('iob_tokens');\n        globalThis.sessionStorage.removeItem('iob_tokens');\n    }\n\n    /**\n     * Destroy tokens if they were created by this connection if they expired or invalid\n     *\n     * @param stayLoggedIn if stored in localStorage or in sessionStorage\n     * @param logout if logout is requested\n     */\n    public deleteTokens(stayLoggedIn: boolean, logout?: boolean): void {\n        const tokens = Connection.readTokens();\n        if (tokens) {\n            if (logout) {\n                Connection.deleteTokensStatic();\n            } else if (tokens.stayLoggedIn === stayLoggedIn && tokens.owner === this.connId) {\n                if (tokens.stayLoggedIn) {\n                    globalThis.localStorage.removeItem('iob_tokens');\n                } else {\n                    globalThis.sessionStorage.removeItem('iob_tokens');\n                }\n            }\n        }\n    }\n\n    private onAccessTokenUpdated = (event: StorageEvent): void => {\n        // Storage event is only fired in other tabs/globalThiss (or iframes) of the same origin when the localStorage (or sessionStorage) is modified, and not in the same globalThis where the change was made.\n        if (event.key === 'iob_tokens') {\n            const tokens = Connection.readTokens();\n            if (tokens) {\n                console.log(`Tab ${this.connId} received updated token: ${tokens.access_token}`);\n                this.updateTokenExpiration(tokens.access_token);\n            }\n        }\n    };\n\n    private updateTokenExpiration(accessToken: string): void {\n        // This connection is not a token owner, so only read the new access token and inform the server\n        if (this.lastAccessToken !== accessToken) {\n            this.lastAccessToken = accessToken;\n            this._socket.emit('updateTokenExpiration', accessToken, (err: string | null, success?: boolean): void => {\n                if (err) {\n                    console.error(`[UPDATE/${new Date().toISOString()}] cannot say to server about new token: ${err}`);\n                    globalThis.location.reload();\n                } else if (!success) {\n                    console.error(`[UPDATE/${new Date().toISOString()}] cannot say to server about new token`);\n                    globalThis.location.reload();\n                } else {\n                    console.log(`[UPDATE/${new Date().toISOString()}] server accepted new token: ${accessToken}`);\n                }\n            });\n        }\n\n        this.checkAccessTokenExpire();\n    }\n\n    private refreshTokens(tokenStructure: StoredTokens, takeOwnership?: boolean): void {\n        if (!tokenStructure) {\n            console.log(`[REFRESH/${new Date().toISOString()}] No token structure found => reloading the page`);\n            // Refresh the page, as we cannot refresh the token\n            setTimeout(() => globalThis.location.reload(), 500);\n            return;\n        }\n\n        if (takeOwnership || !tokenStructure.owner || tokenStructure.owner === this.connId) {\n            console.log(`[REFRESH/${new Date().toISOString()}] claim ownership of the token`);\n            if (this.acquireTokenLock()) {\n                console.log(`[REFRESH/${new Date().toISOString()}] refreshing token`);\n                // Access token will expire soon => Send authentication again\n                fetch('./oauth/token', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded',\n                    },\n                    body: `grant_type=refresh_token&refresh_token=${tokenStructure.refresh_token}&client_id=ioBroker&stayloggedin=${tokenStructure.stayLoggedIn}`,\n                })\n                    .then(response => {\n                        if (response.ok) {\n                            return response.json();\n                        }\n                        throw new Error('Cannot refresh access token');\n                    })\n                    .then((data: OAuth2Response): void => {\n                        if (data.access_token) {\n                            console.log(\n                                `[REFRESH/${new Date().toISOString()}] received new token: ${data.access_token}`,\n                            );\n                            this.saveTokens(data, tokenStructure.stayLoggedIn);\n\n                            this.releaseTokenLock();\n\n                            this.updateTokenExpiration(data.access_token);\n                        } else {\n                            throw new Error('Cannot get access token');\n                        }\n                    })\n                    .catch(err => {\n                        console.warn(`[REFRESH/${new Date().toISOString()}] cannot refresh token: ${err}`);\n                        this.releaseTokenLock();\n                        this.deleteTokens(tokenStructure.stayLoggedIn);\n                        console.error(err);\n                        globalThis.location.reload();\n                    });\n            } else {\n                console.log(\n                    `[REFRESH/${new Date().toISOString()}] Someone else is updating the token, so wait for the next check`,\n                );\n                // Someone else is updating the token, so wait for the next check\n                this.checkAccessTokenExpire();\n            }\n        } else if (this.lastAccessToken !== tokenStructure.access_token) {\n            this.updateTokenExpiration(tokenStructure.access_token);\n        }\n    }\n\n    /**\n     * Attempts to acquire the semaphore lock.\n     *\n     * @returns True if the lock was acquired successfully; otherwise, false.\n     */\n    acquireTokenLock(): boolean {\n        const now = Date.now();\n        const lock = globalThis.localStorage.getItem('iob_token_semaphore');\n\n        if (lock) {\n            try {\n                const lockData: { expiry: number; connId: string } = JSON.parse(lock);\n                // If the current lock is still valid, we cannot acquire the lock.\n                if (now < lockData.expiry) {\n                    return false;\n                }\n                // Otherwise, the lock has expired and we can override it.\n            } catch {\n                // ignore\n            }\n        }\n\n        // Create a new lock with expiry 10 seconds from now.\n        const newLock: { expiry: number; connId: string } = {\n            connId: this.connId,\n            expiry: now + 10 * 1000, // 10 seconds in milliseconds\n        };\n\n        globalThis.localStorage.setItem('iob_token_semaphore', JSON.stringify(newLock));\n        return true;\n    }\n\n    /** Releases the semaphore lock if it's owned by the given connection ID. */\n    releaseTokenLock(): void {\n        const lock = globalThis.localStorage.getItem('iob_token_semaphore');\n        if (lock) {\n            try {\n                const lockData: { expiry: number; connId: string } = JSON.parse(lock);\n                // Only remove the lock if it's owned by the current connection.\n                if (lockData.connId === this.connId) {\n                    globalThis.localStorage.removeItem('iob_token_semaphore');\n                }\n            } catch {\n                // If parsing fails, remove the lock just in case.\n                globalThis.localStorage.removeItem('iob_token_semaphore');\n            }\n        }\n    }\n\n    private checkAccessTokenExpire(): void {\n        if (this._refreshTimer) {\n            clearTimeout(this._refreshTimer);\n            this._refreshTimer = null;\n        }\n        if (this.isSecure) {\n            const tokens = Connection.readTokens();\n            if (tokens) {\n                const accessExpireInUnixMs = tokens.expires_in.getTime();\n                // Check if the access token expires in the next 30 seconds\n                if (accessExpireInUnixMs < Date.now() + 30_000) {\n                    const takeOwnership = accessExpireInUnixMs < Date.now() + 5_500;\n                    console.log(`[TOKEN/${new Date().toISOString()}] Updating refresh token ${tokens.access_token}`);\n                    if (!tokens.refresh_token) {\n                        console.log(\n                            `[TOKEN/${new Date().toISOString()}] We do not have a refresh token, so we need to reauthenticate`,\n                        );\n                        // Refresh the page, as we cannot refresh the token\n                        setTimeout(\n                            () => globalThis.location.reload(),\n                            Date.now() > accessExpireInUnixMs ? 500 : accessExpireInUnixMs - Date.now(),\n                        );\n                    } else if (\n                        tokens.owner === this.connId ||\n                        // We gave 25 seconds to the owner to update the token, and now we will do it and take the ownership\n                        takeOwnership\n                    ) {\n                        if (tokens.owner === this.connId) {\n                            console.log(`[TOKEN/${new Date().toISOString()}] We are the owner of the token`);\n                        } else {\n                            console.log(\n                                `[TOKEN/${new Date().toISOString()}] We are not the owner of the token, but we will take ownership`,\n                            );\n                        }\n                        // Handle token expiration if the connection is the owner of the token\n                        if (this.props.tokenTimeoutHandler) {\n                            console.log(\n                                `[TOKEN/${new Date().toISOString()}] Asking GUI if we should prolong the token`,\n                            );\n                            // Asc if the user wants to stay logged in\n                            void this.props.tokenTimeoutHandler(accessExpireInUnixMs).then(prolong => {\n                                if (prolong) {\n                                    console.log(`[TOKEN/${new Date().toISOString()}] Token will be prolonged`);\n                                    this.refreshTokens(tokens, takeOwnership);\n                                } else {\n                                    console.log(\n                                        `[TOKEN/${new Date().toISOString()}] Token will not be prolonged. Reloading the page`,\n                                    );\n                                    // Refresh the page, as we cannot refresh the token\n                                    setTimeout(\n                                        () => globalThis.location.reload(),\n                                        Date.now() > accessExpireInUnixMs ? 500 : accessExpireInUnixMs - Date.now(),\n                                    );\n                                }\n                            });\n                        } else {\n                            console.log(\n                                `[TOKEN/${new Date().toISOString()}] No tokenTimeoutHandler defined. Prolonging the token`,\n                            );\n                            this.refreshTokens(tokens, takeOwnership);\n                        }\n                    } else if (this.lastAccessToken !== tokens.access_token) {\n                        console.log(\n                            `[TOKEN/${new Date().toISOString()}] We are not the owner of the token, but we will inform the server about new token`,\n                        );\n                        // The connection is not the owner, so just check if access_token changed, so inform the server about it\n                        this.refreshTokens(tokens);\n                    } else {\n                        console.log(\n                            `[TOKEN/${new Date().toISOString()}] We are not the owner of the token and the token did not change. Check in 3 seconds if the owner updated the token`,\n                        );\n                        // What 3 seconds and check again, maybe the owner connection will update the token\n                        this._refreshTimer = setTimeout(() => {\n                            this._refreshTimer = null;\n                            this.checkAccessTokenExpire();\n                        }, 3_000);\n                    }\n                } else {\n                    this._refreshTimer = setTimeout(\n                        () => {\n                            this._refreshTimer = null;\n                            this.checkAccessTokenExpire();\n                        },\n                        accessExpireInUnixMs - Date.now() - 30_000 > 120_000\n                            ? 120_000\n                            : accessExpireInUnixMs - Date.now() - 30_000,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if running in ioBroker cloud\n     */\n    static isCloud(): boolean {\n        if (\n            globalThis.location.hostname.includes('amazonaws.com') ||\n            globalThis.location.hostname.includes('iobroker.in')\n        ) {\n            return true;\n        }\n        if (typeof (globalThis as any).socketUrl === 'undefined') {\n            return false;\n        }\n        return (\n            (globalThis as any).socketUrl.includes('iobroker.in') || (globalThis as any).socketUrl.includes('amazonaws')\n        );\n    }\n\n    /**\n     * Checks if the socket is connected.\n     *\n     * @returns true if connected.\n     */\n    isConnected(): boolean {\n        return this.connected;\n    }\n\n    /**\n     * Returns a promise which is resolved when the socket is connected.\n     */\n    waitForFirstConnection(): Promise<void> {\n        return this._waitForFirstConnectionPromise;\n    }\n\n    /**\n     * Called internally.\n     */\n    private async getUserPermissions(): Promise<SocketACL | null> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getUserPermissions', (err, acl?: SocketACL | null): void => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(acl || null);\n                    }\n                });\n            },\n        });\n    }\n\n    /** Loads the important data and retries a couple of times if it takes too long */\n    private async loadData(): Promise<void> {\n        if (this.loaded) {\n            return;\n        }\n        const maxAttempts = 10;\n        for (let i = 1; i <= maxAttempts; i++) {\n            void this.doLoadData().catch(e => console.error(`Cannot load data: ${e}`));\n            if (this.loaded) {\n                return;\n            }\n            // give more time via remote connection\n            await wait(Connection.isCloud() ? 5000 : 1000);\n        }\n    }\n\n    /**\n     * Called after the socket is connected. Loads the necessary data.\n     */\n    private async doLoadData(): Promise<void> {\n        if (this.loaded) {\n            return;\n        }\n\n        // Load ACL if not disabled\n        if (!this.props.doNotLoadACL) {\n            try {\n                this.acl = await this.getUserPermissions();\n            } catch (e) {\n                this.onError(`Cannot read user permissions: ${e}`);\n                return;\n            }\n        }\n\n        // Load system config if not disabled\n        try {\n            if (\n                this.props.admin5only &&\n                !Connection.isWeb() &&\n                (!(globalThis as any).vendorPrefix || (globalThis as any).vendorPrefix === '@@vendorPrefix@@')\n            ) {\n                this._systemConfig = await this.getCompactSystemConfig();\n            } else {\n                this._systemConfig = await this.getSystemConfig();\n            }\n        } catch (e) {\n            this.onError(`Cannot read system config: ${e}`);\n            return;\n        }\n\n        // Detect the system language\n        if (this._systemConfig) {\n            this.systemLang = this._systemConfig.common?.language;\n            if (!this.systemLang) {\n                this.systemLang = ((globalThis.navigator as any).userLanguage || globalThis.navigator.language) as any;\n                // Browsers may report languages like \"de-DE\", \"en-US\", etc.\n                // ioBroker expects \"de\", \"en\", ...\n                if (/^(en|de|ru|pt|nl|fr|it|es|pl|uk)-?/.test(this.systemLang)) {\n                    this.systemLang = this.systemLang.substring(0, 2) as any;\n                } else if (!/^(en|de|ru|pt|nl|fr|it|es|pl|uk|zh-cn)$/.test(this.systemLang)) {\n                    this.systemLang = 'en';\n                }\n                this._systemConfig.common.language = this.systemLang;\n            }\n        }\n        this.props.onLanguage?.(this.systemLang);\n\n        // We are now connected\n        this.loaded = true;\n        this.props.onProgress?.(PROGRESS.CONNECTED);\n        this.firstConnect = false;\n\n        // Load all objects if desired\n        if (!this.props.doNotLoadAllObjects) {\n            this.objects = await this.getObjects();\n        } else if (this.props.admin5only) {\n            this.objects = {};\n        } else {\n            this.objects = { 'system.config': this._systemConfig };\n        }\n\n        this.props.onProgress?.(PROGRESS.READY);\n        if (!this.onReadyDone) {\n            this.onReadyDone = true;\n            this.props.onReady?.(this.objects);\n        }\n    }\n\n    /**\n     * Called internally.\n     */\n    private authenticate(): void {\n        if (globalThis.location.search.includes('&href=')) {\n            globalThis.location.href = `${globalThis.location.protocol}//${globalThis.location.host}${globalThis.location.pathname}${globalThis.location.search}`;\n        } else {\n            globalThis.location.href = `${globalThis.location.protocol}//${globalThis.location.host}${globalThis.location.pathname}?login&href=${encodeURIComponent(globalThis.location.search + globalThis.location.hash)}`;\n        }\n    }\n\n    /**\n     * Subscribe to the changes of the given state.\n     * In compare to the subscribeObject method,\n     * this method calls the handler with the current state value immediately after subscribing.\n     *\n     * @param id The ioBroker state ID or array of state IDs.\n     * @param binary Set to true if the given state is binary and requires Base64 decoding.\n     * @param cb The callback.\n     */\n    subscribeState(id: string | string[], binary: true, cb: BinaryStateChangeHandler): Promise<void>;\n\n    subscribeState(id: string | string[], binary: false, cb: ioBroker.StateChangeHandler): Promise<void>;\n\n    subscribeState(id: string | string[], cb: ioBroker.StateChangeHandler): Promise<void>;\n\n    async subscribeState(\n        ...args:\n            | [id: string | string[], binary: true, cb: BinaryStateChangeHandler]\n            | [id: string | string[], binary: false, cb: ioBroker.StateChangeHandler]\n            | [id: string | string[], cb: ioBroker.StateChangeHandler]\n    ): Promise<void> {\n        let id: string | string[];\n        let binary: boolean;\n        let cb: ioBroker.StateChangeHandler | BinaryStateChangeHandler;\n        if (args.length === 3) {\n            [id, binary, cb] = args;\n        } else {\n            [id, cb] = args;\n            binary = false;\n        }\n        let ids: string[];\n        if (!Array.isArray(id)) {\n            ids = [id];\n        } else {\n            ids = id;\n        }\n\n        if (typeof cb !== 'function') {\n            throw new Error('The state change handler must be a function!');\n        }\n        const toSubscribe: string[] = [];\n        for (let i = 0; i < ids.length; i++) {\n            const _id = ids[i];\n            if (!this.statesSubscribes[_id]) {\n                this.statesSubscribes[_id] = {\n                    reg: new RegExp(pattern2RegEx(_id)),\n                    cbs: [cb],\n                };\n                if (id !== this.ignoreState) {\n                    toSubscribe.push(_id);\n                }\n            } else {\n                !this.statesSubscribes[_id].cbs.includes(cb) && this.statesSubscribes[_id].cbs.push(cb);\n            }\n        }\n\n        if (!this.connected) {\n            return;\n        }\n\n        if (toSubscribe.length) {\n            // no answer from server required\n            this._socket.emit('subscribe', toSubscribe);\n        }\n\n        // Try to get the current value(s) of the state(s) and call the change handlers\n        if (binary) {\n            let base64: string | undefined;\n            for (let i = 0; i < ids.length; i++) {\n                try {\n                    // binary states are deprecated\n                    base64 = await this.getBinaryState(ids[i]);\n                } catch (e) {\n                    console.error(`Cannot getBinaryState \"${ids[i]}\": ${JSON.stringify(e)}`);\n                    base64 = undefined;\n                }\n                if (base64 != undefined) {\n                    (cb as BinaryStateChangeHandler)(ids[i], base64);\n                }\n            }\n        } else if (ids.find(_id => _id.includes('*'))) {\n            let states: Record<string, ioBroker.State> | undefined;\n            for (let i = 0; i < ids.length; i++) {\n                try {\n                    states = await this.getForeignStates(ids[i]);\n                } catch (e) {\n                    console.error(`Cannot getForeignStates \"${ids[i]}\": ${JSON.stringify(e)}`);\n                    return;\n                }\n                if (states) {\n                    for (const [id, state] of Object.entries(states)) {\n                        const mayBePromise = (cb as ioBroker.StateChangeHandler)(id, state);\n                        if (mayBePromise instanceof Promise) {\n                            void mayBePromise.catch(e => console.error(`Cannot call state change handler: ${e}`));\n                        }\n                    }\n                }\n            }\n        } else {\n            try {\n                const states = await (Connection.isWeb() ? this.getStates(ids) : this.getForeignStates(ids));\n                if (states) {\n                    for (const [id, state] of Object.entries(states)) {\n                        const mayBePromise = (cb as ioBroker.StateChangeHandler)(id, state);\n                        if (mayBePromise instanceof Promise) {\n                            void mayBePromise.catch(e => console.error(`Cannot call state change handler: ${e}`));\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(`Cannot getState \"${ids.join(', ')}\": ${e.message}`);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Subscribe to the changes of the given state and wait for answer.\n     *\n     * @param id The ioBroker state ID.\n     * @param cb The callback.\n     */\n    async subscribeStateAsync(id: string | string[], cb: ioBroker.StateChangeHandler): Promise<void> {\n        return this.subscribeState(id, cb);\n    }\n\n    /**\n     * Unsubscribes the given callback from changes of the given state.\n     *\n     * @param id The ioBroker state ID or array of state IDs.\n     * @param cb The callback.\n     */\n    unsubscribeState(id: string | string[], cb?: ioBroker.StateChangeHandler): void {\n        let ids: string[];\n        if (!Array.isArray(id)) {\n            ids = [id];\n        } else {\n            ids = id;\n        }\n        const toUnsubscribe = [];\n        for (let i = 0; i < ids.length; i++) {\n            const _id = ids[i];\n\n            if (this.statesSubscribes[_id]) {\n                const sub = this.statesSubscribes[_id];\n                if (cb) {\n                    const pos = sub.cbs.indexOf(cb);\n                    pos !== -1 && sub.cbs.splice(pos, 1);\n                } else {\n                    sub.cbs = [];\n                }\n\n                if (!sub.cbs?.length) {\n                    delete this.statesSubscribes[_id];\n                    if (_id !== this.ignoreState) {\n                        toUnsubscribe.push(_id);\n                    }\n                }\n            }\n        }\n        if (this.connected && toUnsubscribe.length) {\n            this._socket.emit('unsubscribe', ids);\n        }\n    }\n\n    /**\n     * Subscribe to changes of the given object.\n     * In compare to the subscribeState method,\n     * this method does not call the handler with the current value immediately after subscribe.\n     *\n     * the current value.\n     *\n     * @param id The ioBroker object ID.\n     * @param cb The callback.\n     */\n    subscribeObject(id: string | string[], cb: ObjectChangeHandler): Promise<void> {\n        let ids: string[];\n        if (!Array.isArray(id)) {\n            ids = [id];\n        } else {\n            ids = id;\n        }\n\n        if (typeof cb !== 'function') {\n            throw new Error('The object change handler must be a function!');\n        }\n\n        const toSubscribe: string[] = [];\n        for (let i = 0; i < ids.length; i++) {\n            const _id = ids[i];\n            if (!this.objectsSubscribes[_id]) {\n                this.objectsSubscribes[_id] = {\n                    reg: new RegExp(pattern2RegEx(_id)),\n                    cbs: [cb],\n                };\n                toSubscribe.push(_id);\n            } else {\n                !this.objectsSubscribes[_id].cbs.includes(cb) && this.objectsSubscribes[_id].cbs.push(cb);\n            }\n        }\n\n        if (this.connected && toSubscribe.length) {\n            this._socket.emit('subscribeObjects', toSubscribe);\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Unsubscribes all callbacks from changes of the given object.\n     *\n     * @param id The ioBroker object ID.\n     */\n    /**\n     * Unsubscribes the given callback from changes of the given object.\n     *\n     * @param id The ioBroker object ID.\n     * @param cb The callback.\n     */\n    unsubscribeObject(id: string | string[], cb?: ObjectChangeHandler): Promise<void> {\n        let ids: string[];\n        if (!Array.isArray(id)) {\n            ids = [id];\n        } else {\n            ids = id;\n        }\n        const toUnsubscribe: string[] = [];\n        for (let i = 0; i < ids.length; i++) {\n            const _id = ids[i];\n            if (this.objectsSubscribes[_id]) {\n                const sub = this.objectsSubscribes[_id];\n                if (cb) {\n                    const pos = sub.cbs.indexOf(cb);\n                    pos !== -1 && sub.cbs.splice(pos, 1);\n                } else {\n                    sub.cbs = [];\n                }\n\n                if (!sub.cbs?.length) {\n                    delete this.objectsSubscribes[_id];\n                    toUnsubscribe.push(_id);\n                }\n            }\n        }\n        if (this.connected && toUnsubscribe.length) {\n            this._socket.emit('unsubscribeObjects', toUnsubscribe);\n        }\n        return Promise.resolve();\n    }\n\n    /**\n     * Called internally.\n     *\n     * @param id The ioBroker object ID.\n     * @param obj The new object.\n     */\n    private objectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n        // update main.objects cache\n\n        // Remember the id and type of th old object\n        let oldObj: OldObject | undefined;\n        if (this.objects[id]) {\n            oldObj = { _id: id, type: this.objects[id].type };\n        }\n\n        let changed = false;\n        if (obj) {\n            // The object was added, updated or changed\n\n            // Copy the _rev property (whatever that is)\n            if ((obj as any)._rev && this.objects[id]) {\n                (this.objects[id] as any)._rev = (obj as any)._rev;\n            }\n\n            // Detect if there was a change\n            if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {\n                this.objects[id] = obj;\n                changed = true;\n            }\n        } else if (this.objects[id]) {\n            // The object was deleted\n            delete this.objects[id];\n            changed = true;\n        }\n\n        // Notify all subscribed listeners\n        for (const [_id, sub] of Object.entries(this.objectsSubscribes)) {\n            if (_id === id || sub.reg.test(id)) {\n                sub.cbs.forEach(cb => {\n                    try {\n                        const mayBePromise = cb(id, obj, oldObj);\n                        if (mayBePromise instanceof Promise) {\n                            void mayBePromise.catch(e => console.error(`Cannot call object change handler: ${e}`));\n                        }\n                    } catch (e) {\n                        console.error(`Error by callback of objectChange: ${e}`);\n                    }\n                });\n            }\n        }\n\n        // Notify the default listener on change\n        if (changed) {\n            const mayBePromise = this.props.onObjectChange?.(id, obj);\n            if (mayBePromise instanceof Promise) {\n                void mayBePromise.catch(e => console.error(`Cannot call object change handler: ${e}`));\n            }\n        }\n    }\n\n    /**\n     * Called internally.\n     *\n     * @param id The ioBroker state ID.\n     * @param state The new state value.\n     */\n    private stateChange(id: string, state: ioBroker.State | null | undefined): void {\n        for (const sub of Object.values(this.statesSubscribes)) {\n            if (sub.reg.test(id)) {\n                for (const cb of sub.cbs) {\n                    try {\n                        const mayBePromise = cb(id, (state ?? null) as any);\n                        if (mayBePromise instanceof Promise) {\n                            void mayBePromise.catch(e => console.error(`Cannot call state change handler: ${e}`));\n                        }\n                    } catch (e) {\n                        console.error(`Error by callback of stateChanged: ${e}`);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Called internally.\n     *\n     * @param messageType The message type from the instance\n     * @param sourceInstance The source instance\n     * @param data The message data\n     */\n    private instanceMessage(messageType: string, sourceInstance: string, data: any): void {\n        this._instanceSubscriptions[sourceInstance]?.forEach(sub => {\n            if (sub.messageType === messageType) {\n                const mayBePromise = sub.callback(data, sourceInstance, messageType);\n                if (mayBePromise instanceof Promise) {\n                    void mayBePromise.catch(e => console.error(`Cannot call instance message handler: ${e}`));\n                }\n            }\n        });\n    }\n\n    /**\n     * Called internally.\n     *\n     * @param id The ioBroker object ID of type 'meta'.\n     * @param fileName - file name\n     * @param size - size of the file\n     */\n    private fileChange(id: string, fileName: string, size: number | null): void {\n        for (const sub of Object.values(this.filesSubscribes)) {\n            if (sub.regId.test(id) && sub.regFilePattern.test(fileName)) {\n                for (const cb of sub.cbs) {\n                    try {\n                        cb(id, fileName, size);\n                    } catch (e) {\n                        console.error(`Error by callback of fileChange: ${e}`);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Subscribe to changes of the files.\n     *\n     * @param id The ioBroker state ID for a \"meta\" object. Could be a pattern\n     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`\n     * @param cb The callback.\n     */\n    async subscribeFiles(id: string, filePattern: string | string[], cb: FileChangeHandler): Promise<void> {\n        if (typeof cb !== 'function') {\n            throw new Error('The state change handler must be a function!');\n        }\n\n        let filePatterns: string[];\n        if (Array.isArray(filePattern)) {\n            filePatterns = filePattern;\n        } else {\n            filePatterns = [filePattern];\n        }\n\n        const toSubscribe = [];\n        for (let f = 0; f < filePatterns.length; f++) {\n            const pattern = filePatterns[f];\n            const key = `${id}$%$${pattern}`;\n\n            if (!this.filesSubscribes[key]) {\n                this.filesSubscribes[key] = {\n                    regId: new RegExp(pattern2RegEx(id)),\n                    regFilePattern: new RegExp(pattern2RegEx(pattern)),\n                    cbs: [cb],\n                };\n                toSubscribe.push(pattern);\n            } else {\n                !this.filesSubscribes[key].cbs.includes(cb) && this.filesSubscribes[key].cbs.push(cb);\n            }\n        }\n        if (this.connected && toSubscribe.length) {\n            this._socket.emit('subscribeFiles', id, toSubscribe);\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Unsubscribes the given callback from changes of files.\n     *\n     * @param id The ioBroker state ID.\n     * @param filePattern Pattern or file name, like 'main/*' or 'main/visViews.json`\n     * @param cb The callback.\n     */\n    unsubscribeFiles(id: string, filePattern: string | string[], cb?: FileChangeHandler): void {\n        let filePatterns: string[];\n        if (Array.isArray(filePattern)) {\n            filePatterns = filePattern;\n        } else {\n            filePatterns = [filePattern];\n        }\n        const toUnsubscribe = [];\n        for (let f = 0; f < filePatterns.length; f++) {\n            const pattern = filePatterns[f];\n            const key = `${id}$%$${pattern}`;\n            if (this.filesSubscribes[key]) {\n                const sub = this.filesSubscribes[key];\n                if (cb) {\n                    const pos = sub.cbs.indexOf(cb);\n                    pos !== -1 && sub.cbs.splice(pos, 1);\n                } else {\n                    sub.cbs = [];\n                }\n\n                if (!sub.cbs?.length) {\n                    delete this.filesSubscribes[key];\n                    toUnsubscribe.push(pattern);\n                }\n            }\n        }\n        if (this.connected && toUnsubscribe.length) {\n            this._socket.emit('unsubscribeFiles', id, toUnsubscribe);\n        }\n    }\n\n    /** Requests data from the server or reads it from the cache */\n    protected async request<T>({\n        cacheKey,\n        forceUpdate,\n        commandTimeout,\n        onTimeout,\n        requireAdmin,\n        requireFeatures,\n        // requestName,\n        executor,\n    }: RequestOptions<T>): Promise<T> {\n        // TODO: mention requestName in errors\n\n        // If the command requires the admin adapter, enforce it\n        if (requireAdmin && Connection.isWeb()) {\n            return Promise.reject(new Error(ERRORS.NOT_ADMIN));\n        }\n\n        // Return the cached value if allowed\n        if (cacheKey && !forceUpdate && cacheKey in this._promises) {\n            return this._promises[cacheKey];\n        }\n\n        // Require the socket to be connected\n        if (!this.connected) {\n            return Promise.reject(new Error(ERRORS.NOT_CONNECTED));\n        }\n\n        // Check if all required features are supported\n        if (requireFeatures?.length) {\n            for (const feature of requireFeatures) {\n                if (!(await this.checkFeatureSupported(feature))) {\n                    throw new Error(ERRORS.NOT_SUPPORTED);\n                }\n            }\n        }\n\n        // eslint-disable-next-line no-async-promise-executor\n        const promise = new Promise<T>(async (resolve, reject) => {\n            const timeoutControl = {\n                elapsed: false,\n                clearTimeout: () => {\n                    // no-op unless there is a timeout\n                },\n            };\n            let timeout: ReturnType<typeof setTimeout> | undefined;\n            if (commandTimeout !== false) {\n                timeout = setTimeout(() => {\n                    timeoutControl.elapsed = true;\n                    // Let the caller know that the timeout elapsed\n                    onTimeout?.();\n\n                    // do not cache responses with timeout or no connection\n                    if (cacheKey && this._promises[cacheKey] instanceof Promise) {\n                        delete this._promises[cacheKey];\n                    }\n                    reject(new Error(ERRORS.TIMEOUT));\n                }, commandTimeout ?? this.props.cmdTimeout);\n                timeoutControl.clearTimeout = () => {\n                    clearTimeout(timeout);\n                };\n            }\n            // Call the actual function - awaiting it allows us to catch sync and async errors\n            // no matter if the executor is async or not\n            try {\n                await executor(resolve, reject, timeoutControl);\n            } catch (e) {\n                // do not cache responses with timeout or no connection\n                if (cacheKey && this._promises[cacheKey] instanceof Promise) {\n                    delete this._promises[cacheKey];\n                }\n                reject(new Error(e.toString()));\n            }\n        });\n        if (cacheKey) {\n            this._promises[cacheKey] = promise;\n        }\n        return promise;\n    }\n\n    /**\n     * Deletes cached promise.\n     * So next time the information will be requested anew\n     */\n    resetCache(key: string, isAll?: boolean): void {\n        if (isAll) {\n            Object.keys(this._promises)\n                .filter(k => k.startsWith(key))\n                .forEach(k => {\n                    delete this._promises[k];\n                });\n        } else {\n            delete this._promises[key];\n        }\n    }\n\n    /**\n     * Gets all states.\n     *\n     * @param pattern Pattern of states or array of IDs\n     */\n    getStates(pattern?: string | string[]): Promise<Record<string, ioBroker.State>> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getStates', pattern, (err, res) => {\n                    this.states = res ?? {};\n\n                    // if (!disableProgressUpdate) {\n                    // \tthis.props.onProgress?.(PROGRESS.STATES_LOADED);\n                    // }\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(this.states);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the given state.\n     *\n     * @param id The state ID.\n     */\n    getState(id: string): Promise<ioBroker.State | null | undefined> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                if (id && id === this.ignoreState) {\n                    resolve(this.simStates[id] || { val: null, ack: true });\n                    return;\n                }\n                this._socket.emit('getState', id, (err, state) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(state);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the given binary state Base64 encoded.\n     *\n     * @deprecated since js-controller 5.0. Use files instead.\n     * @param id The state ID.\n     */\n    getBinaryState(id: string): Promise<string | undefined> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getBinaryState', id, (err, state) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(state);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Sets the given binary state.\n     *\n     * @deprecated since js-controller 5.0. Use files instead.\n     * @param id The state ID.\n     * @param base64 The Base64 encoded binary data.\n     */\n    setBinaryState(id: string, base64: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('setBinaryState', id, base64, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Sets the given state value.\n     *\n     * @param id The state ID.\n     * @param val The state value.\n     * @param ack Acknowledgement flag.\n     */\n    setState(\n        id: string,\n        val: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState,\n        ack?: boolean,\n    ): Promise<void> {\n        if (typeof ack === 'boolean') {\n            val = { val: val as ioBroker.StateValue, ack };\n        }\n\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                // extra handling for \"nothing_selected\" state for vis\n                if (id && id === this.ignoreState) {\n                    let state: ioBroker.State;\n\n                    if (typeof ack === 'boolean') {\n                        state = val as ioBroker.State;\n                    } else if (typeof val === 'object' && (val as ioBroker.State).val !== undefined) {\n                        state = val as ioBroker.State;\n                    } else {\n                        state = {\n                            val: val as ioBroker.StateValue,\n                            ack: false,\n                            ts: Date.now(),\n                            lc: Date.now(),\n                            from: 'system.adapter.vis.0',\n                        };\n                    }\n\n                    this.simStates[id] = state;\n\n                    // inform subscribers about changes\n                    if (this.statesSubscribes[id]) {\n                        for (const cb of this.statesSubscribes[id].cbs) {\n                            try {\n                                const mayBePromise = cb(id, state as any);\n                                if (mayBePromise instanceof Promise) {\n                                    void mayBePromise.catch(e =>\n                                        console.error(`Cannot call state change handler: ${e}`),\n                                    );\n                                }\n                            } catch (e) {\n                                console.error(`Error by callback of stateChanged: ${e}`);\n                            }\n                        }\n                    }\n                    resolve();\n                    return;\n                }\n                this._socket.emit('setState', id, val, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets all objects.\n     *\n     * @param update Callback that is executed when all objects are retrieved.\n     */\n    /**\n     * Gets all objects.\n     *\n     * @param update Set to true to retrieve all objects from the server (instead of using the local cache).\n     * @param disableProgressUpdate don't call onProgress() when done\n     */\n    getObjects(update?: boolean, disableProgressUpdate?: boolean): Promise<Record<string, ioBroker.Object>> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                if (!update && this.objects) {\n                    resolve(this.objects);\n                    return;\n                }\n\n                this._socket.emit(Connection.isWeb() ? 'getObjects' : 'getAllObjects', (err, res) => {\n                    if (!disableProgressUpdate) {\n                        this.props.onProgress?.(PROGRESS.OBJECTS_LOADED);\n                    }\n                    if (err) {\n                        reject(err);\n                    } else {\n                        this.objects = res ?? {};\n                        resolve(this.objects);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the list of objects by ID.\n     *\n     * @param list array of IDs to retrieve\n     */\n    getObjectsById(list: string[]): Promise<Record<string, ioBroker.Object> | undefined> {\n        return this.request({\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getObjects', list, (err, res) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(res);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Called internally.\n     *\n     * @param isEnable Set to true if subscribing, false to unsubscribe.\n     */\n    private _subscribe(isEnable: boolean): void {\n        if (isEnable && !this.subscribed) {\n            this.subscribed = true;\n            if (this.props.autoSubscribes?.length) {\n                this._socket.emit('subscribeObjects', this.props.autoSubscribes);\n            }\n            // re subscribe objects\n            const ids = Object.keys(this.objectsSubscribes);\n            if (ids.length) {\n                this._socket.emit('subscribeObjects', ids);\n            }\n            Object.keys(this.objectsSubscribes).forEach(id => this._socket.emit('subscribeObjects', id));\n            // re-subscribe logs\n            this.props.autoSubscribeLog && this._socket.emit('requireLog', true);\n            // re subscribe states\n            Object.keys(this.statesSubscribes).forEach(id => this._socket.emit('subscribe', id));\n            // re-subscribe files\n            Object.keys(this.filesSubscribes).forEach(key => {\n                const [id, filePattern] = key.split('$%$');\n                this._socket.emit('subscribeFiles', id, filePattern);\n            });\n        } else if (!isEnable && this.subscribed) {\n            this.subscribed = false;\n            // un-subscribe objects\n            if (this.props.autoSubscribes?.length) {\n                this._socket.emit('unsubscribeObjects', this.props.autoSubscribes);\n            }\n            const ids = Object.keys(this.objectsSubscribes);\n            if (ids.length) {\n                this._socket.emit('unsubscribeObjects', ids);\n            }\n            // un-subscribe logs\n            this.props.autoSubscribeLog && this._socket.emit('requireLog', false);\n\n            // un-subscribe states\n            Object.keys(this.statesSubscribes).forEach(id => this._socket.emit('unsubscribe', id));\n            // re-subscribe files\n            Object.keys(this.filesSubscribes).forEach(key => {\n                const [id, filePattern] = key.split('$%$');\n                this._socket.emit('unsubscribeFiles', id, filePattern);\n            });\n        }\n    }\n\n    /**\n     * Requests log updates.\n     *\n     * @param isEnabled Set to true to get logs.\n     */\n    requireLog(isEnabled: boolean): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('requireLog', isEnabled, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Deletes the given object.\n     *\n     * @param id The object ID.\n     * @param maintenance Force deletion of non conform IDs.\n     */\n    delObject(id: string, maintenance: boolean = false): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('delObject', id, { maintenance }, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Deletes the given object and all its children.\n     *\n     * @param id The object ID.\n     * @param maintenance Force deletion of non conform IDs.\n     */\n    delObjects(id: string, maintenance: boolean): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('delObjects', id, { maintenance }, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Sets the object.\n     *\n     * @param id The object ID.\n     * @param obj The object.\n     */\n    setObject(id: string, obj: ioBroker.SettableObject): Promise<void> {\n        if (!obj) {\n            return Promise.reject(new Error('Null object is not allowed'));\n        }\n\n        obj = JSON.parse(JSON.stringify(obj));\n        delete obj.from;\n        delete obj.user;\n        delete obj.ts;\n\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('setObject', id, obj, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the object with the given id from the server.\n     *\n     * @param id The object ID.\n     * @returns The object.\n     */\n    getObject<T extends string>(id: T): ioBroker.GetObjectPromise<T> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                if (id && id === this.ignoreState) {\n                    resolve({\n                        _id: this.ignoreState,\n                        type: 'state',\n                        common: {\n                            name: 'ignored state',\n                            type: 'mixed',\n                        },\n                    } as any);\n                    return;\n                }\n                this._socket.emit('getObject', id, (err, obj) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(obj as any);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Sends a message to a specific instance or all instances of some specific adapter.\n     *\n     * @param instance The instance to send this message to.\n     * @param command Command name of the target instance.\n     * @param data The message data to send.\n     */\n    sendTo<T = any>(instance: string, command: string, data?: any): Promise<T> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: resolve => {\n                this._socket.emit('sendTo', instance, command, data, (result: any) => {\n                    resolve(result);\n                });\n            },\n        });\n    }\n\n    /**\n     * Extend an object and create it if it might not exist.\n     *\n     * @param id The id.\n     * @param obj The object.\n     */\n    extendObject(id: string, obj: ioBroker.PartialObject): Promise<void> {\n        if (!obj) {\n            return Promise.reject(new Error('Null object is not allowed'));\n        }\n\n        obj = JSON.parse(JSON.stringify(obj));\n        delete obj.from;\n        delete obj.user;\n        delete obj.ts;\n\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('extendObject', id, obj, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Register a handler for log messages.\n     *\n     * @param handler The handler.\n     */\n    registerLogHandler(handler: (message: LogMessage) => void): void {\n        if (!this.onLogHandlers.includes(handler)) {\n            this.onLogHandlers.push(handler);\n        }\n    }\n\n    /**\n     * Unregister a handler for log messages.\n     *\n     * @param handler The handler.\n     */\n    unregisterLogHandler(handler: (message: LogMessage) => void): void {\n        const pos = this.onLogHandlers.indexOf(handler);\n        pos !== -1 && this.onLogHandlers.splice(pos, 1);\n    }\n\n    /**\n     * Register a handler for the connection state.\n     *\n     * @param handler The handler.\n     */\n    registerConnectionHandler(handler: (connected: boolean) => void): void {\n        if (!this.onConnectionHandlers.includes(handler)) {\n            this.onConnectionHandlers.push(handler);\n        }\n    }\n\n    /**\n     * Unregister a handler for the connection state.\n     *\n     * @param handler The handler.\n     */\n    unregisterConnectionHandler(handler: (connected: boolean) => void): void {\n        const pos = this.onConnectionHandlers.indexOf(handler);\n        pos !== -1 && this.onConnectionHandlers.splice(pos, 1);\n    }\n\n    /**\n     * Set the handler for standard output of a command.\n     *\n     * @param handler The handler.\n     */\n    registerCmdStdoutHandler(handler: (id: string, text: string) => void): void {\n        this.onCmdStdoutHandler = handler;\n    }\n\n    /**\n     * Unset the handler for standard output of a command.\n     */\n    unregisterCmdStdoutHandler(): void {\n        this.onCmdStdoutHandler = undefined;\n    }\n\n    /**\n     * Set the handler for standard error of a command.\n     *\n     * @param handler The handler.\n     */\n    registerCmdStderrHandler(handler: (id: string, text: string) => void): void {\n        this.onCmdStderrHandler = handler;\n    }\n\n    /**\n     * Unset the handler for standard error of a command.\n     */\n    unregisterCmdStderrHandler(): void {\n        this.onCmdStderrHandler = undefined;\n    }\n\n    /**\n     * Set the handler for exit of a command.\n     *\n     * @param handler The handler.\n     */\n    registerCmdExitHandler(handler: (id: string, exitCode: number) => void): void {\n        this.onCmdExitHandler = handler;\n    }\n\n    /**\n     * Unset the handler for exit of a command.\n     */\n    unregisterCmdExitHandler(): void {\n        this.onCmdExitHandler = undefined;\n    }\n\n    /**\n     * Get all enums with the given name.\n     *\n     * @param _enum The name of the enum, like `rooms` or `functions`\n     * @param update Force update.\n     */\n    getEnums(_enum?: string, update?: boolean): Promise<Record<string, ioBroker.EnumObject>> {\n        return this.request({\n            cacheKey: `enums_${_enum || 'all'}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'getObjectView',\n                    'system',\n                    'enum',\n                    {\n                        startkey: `enum.${_enum || ''}`,\n                        endkey: _enum ? `enum.${_enum}.\\u9999` : `enum.\\u9999`,\n                    },\n                    (err, res) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            const _res: Record<string, ioBroker.EnumObject> = {};\n                            if (res) {\n                                for (let i = 0; i < res.rows.length; i++) {\n                                    if (_enum && res.rows[i].id === `enum.${_enum}`) {\n                                        continue;\n                                    }\n                                    _res[res.rows[i].id] = res.rows[i].value as ioBroker.EnumObject;\n                                }\n                            }\n                            resolve(_res);\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * @deprecated since version 1.1.15, cause parameter order does not match backend\n     * Query a predefined object view.\n     * @param start The start ID.\n     * @param end The end ID.\n     * @param type The type of object.\n     */\n    getObjectView<T extends ioBroker.ObjectType>(\n        start: string | undefined,\n        end: string | undefined,\n        type: T,\n    ): Promise<Record<string, ioBroker.AnyObject & { type: T }>> {\n        return this.getObjectViewCustom('system', type, start, end);\n    }\n\n    /**\n     * Query a predefined object view.\n     *\n     * @param type The type of object.\n     * @param start The start ID.\n     * @param [end] The end ID.\n     */\n    async getObjectViewSystem<T extends ioBroker.ObjectType>(\n        type: T,\n        start?: string,\n        end?: string,\n    ): Promise<Record<string, ioBroker.AnyObject & { type: T }>> {\n        const key = `${type}_${start || ''}_${end || ''}`;\n        const result = await this.getObjectViewCustom('system', type, start, end);\n        if (this.objectViewCached?.[key]) {\n            // update cached value\n            this.objectViewCached[key] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Query a predefined object view.\n     *\n     * @param type The type of object.\n     * @param start The start ID.\n     * @param [end] The end ID.\n     */\n    async getObjectViewSystemCached<T extends ioBroker.ObjectType>(\n        type: T,\n        start?: string,\n        end?: string,\n    ): Promise<Record<string, ioBroker.AnyObject & { type: T }>> {\n        const key = `${type}_${start || ''}_${end || ''}`;\n        if (this.objectViewCached?.[key]) {\n            return Promise.resolve(this.objectViewCached[key] as any);\n        }\n\n        const result = await this.getObjectViewCustom('system', type, start, end);\n        this.objectViewCached ||= {};\n        this.objectViewCached[key] = result;\n        return result;\n    }\n\n    /**\n     * Query a predefined object view.\n     *\n     * @param design design - 'system' or other designs like `custom`.\n     * @param type The type of object.\n     * @param start The start ID.\n     * @param [end] The end ID.\n     */\n    getObjectViewCustom<T extends ioBroker.ObjectType>(\n        design: string,\n        type: T,\n        start?: string,\n        end?: string,\n    ): Promise<Record<string, ioBroker.AnyObject & { type: T }>> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                start ||= '';\n                end ||= '\\u9999';\n\n                this._socket.emit('getObjectView', design, type, { startkey: start, endkey: end }, (err, res) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        const _res: Record<string, ioBroker.AnyObject & { type: T }> = {};\n                        if (res && res.rows) {\n                            for (let i = 0; i < res.rows.length; i++) {\n                                _res[res.rows[i].id] = res.rows[i].value;\n                            }\n                        }\n                        resolve(_res);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Read the meta items.\n     */\n    readMetaItems(): Promise<ioBroker.Object[]> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'getObjectView',\n                    'system',\n                    'meta',\n                    { startkey: '', endkey: '\\u9999' },\n                    (err, objs) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(objs!.rows?.map(obj => obj.value).filter((val): val is ioBroker.Object => !!val));\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Read the directory of an adapter.\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param path The directory name.\n     */\n    readDir(namespace: string | null, path: string): Promise<ioBroker.ReadDirResult[]> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('readDir', namespace, path, (err, files) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(files!);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Read a file of an adapter.\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param fileName The file name.\n     * @param base64 If it must be a base64 format\n     */\n    readFile(\n        namespace: string | null,\n        fileName: string,\n        base64?: boolean,\n    ): Promise<{ file: string; mimeType: string }> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(base64 ? 'readFile64' : 'readFile', namespace, fileName, (err, data, type) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve({ file: data as string, mimeType: type! });\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Write a file of an adapter.\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param fileName The file name.\n     * @param data The data (if it's a Buffer, it will be converted to Base64).\n     */\n    writeFile64(namespace: string, fileName: string, data: ArrayBuffer | string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                if (typeof data === 'string') {\n                    this._socket.emit('writeFile', namespace, fileName, data, err => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve();\n                        }\n                    });\n                } else {\n                    const base64 = btoa(\n                        new Uint8Array(data).reduce((data, byte) => data + String.fromCharCode(byte), ''),\n                    );\n\n                    this._socket.emit('writeFile64', namespace, fileName, base64, err => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve();\n                        }\n                    });\n                }\n            },\n        });\n    }\n\n    /**\n     * Delete a file of an adapter.\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param fileName The file name.\n     */\n    deleteFile(namespace: string, fileName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('deleteFile', namespace, fileName, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Delete a folder of an adapter.\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param folderName The folder name.\n     */\n    deleteFolder(namespace: string, folderName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('deleteFolder', namespace, folderName, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Rename file or folder in ioBroker DB\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param oldName current file name, e.g., main/vis-views.json\n     * @param newName new file name, e.g., main/vis-views-new.json\n     */\n    rename(namespace: string, oldName: string, newName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('rename', namespace, oldName, newName, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Rename file in ioBroker DB\n     *\n     * @param namespace (this may be the adapter name, the instance name or the name of a storage object within the adapter).\n     * @param oldName current file name, e.g., main/vis-views.json\n     * @param newName new file name, e.g., main/vis-views-new.json\n     */\n    renameFile(namespace: string, oldName: string, newName: string): Promise<void> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('renameFile', namespace, oldName, newName, err => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Execute a command on a host.\n     */\n    cmdExec(\n        /** Host name */\n        host: string,\n        /** Command to execute */\n        cmd: string,\n        /** Command ID */\n        cmdId: number,\n        /** Timeout of command in ms */\n        cmdTimeout?: number,\n    ): Promise<void> {\n        return this.request({\n            commandTimeout: cmdTimeout,\n            executor: (resolve, reject, timeout) => {\n                host = normalizeHostId(host);\n\n                this._socket.emit('cmdExec', host, cmdId, cmd, err => {\n                    if (timeout.elapsed) {\n                        return;\n                    }\n                    timeout.clearTimeout();\n\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the system configuration.\n     *\n     * @param update Force update.\n     */\n    getSystemConfig(update?: boolean): Promise<ioBroker.SystemConfigObject> {\n        return this.request({\n            cacheKey: 'systemConfig',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                let systemConfig = await this.getObject('system.config');\n                (systemConfig as any) ??= {};\n                (systemConfig as any).common ??= {};\n                (systemConfig as any).native ??= {};\n\n                resolve(systemConfig!);\n            },\n        });\n    }\n\n    // returns very optimized information for adapters to minimize a connection load\n    getCompactSystemConfig(update?: boolean): Promise<ioBroker.SystemConfigObject> {\n        return this.request({\n            cacheKey: 'systemConfigCommon',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            requireAdmin: true,\n            executor: (resolve, reject) => {\n                this._socket.emit('getCompactSystemConfig', (err, systemConfig) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        (systemConfig as any) ??= {};\n                        (systemConfig as any).common ??= {};\n                        (systemConfig as any).native ??= {};\n                        resolve(systemConfig!);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Read all states (which might not belong to this adapter) which match the given pattern.\n     *\n     * @param pattern The pattern to match.\n     */\n    getForeignStates(pattern?: string | string[] | null): ioBroker.GetStatesPromise {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getForeignStates', pattern || '*', (err, states) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(states ?? {});\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get foreign objects by pattern, by specific type and resolve their enums.\n     *\n     * @param pattern The pattern to match.\n     * @param type The type of the object.\n     */\n    getForeignObjects<T extends ioBroker.ObjectType>(\n        pattern: string | null | undefined,\n        type: T,\n    ): Promise<Record<string, ioBroker.AnyObject & { type: T }>> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getForeignObjects', pattern || '*', type, (err, objects) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(objects as any);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Sets the system configuration.\n     *\n     * @param obj The new system configuration.\n     */\n    setSystemConfig(obj: ioBroker.SystemConfigObject): Promise<void> {\n        return this.setObject('system.config', obj);\n    }\n\n    /**\n     * Get the raw socket.io socket.\n     */\n    getRawSocket(): any {\n        return this._socket;\n    }\n\n    /**\n     * Get the history of a given state.\n     *\n     * @param id The state ID.\n     * @param options The query options.\n     */\n    getHistory(id: string, options: ioBroker.GetHistoryOptions): Promise<ioBroker.GetHistoryResult> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getHistory', id, options, (err, values) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(values!);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the history of a given state.\n     *\n     * @param id The state ID.\n     * @param options The query options.\n     */\n    getHistoryEx(\n        id: string,\n        options: ioBroker.GetHistoryOptions,\n    ): Promise<{\n        values: ioBroker.GetHistoryResult;\n        sessionId: number;\n        step: number;\n    }> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getHistory', id, options, (err, values, step, sessionId) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve({\n                            values: values!,\n                            sessionId: sessionId!,\n                            step: step!,\n                        });\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get the IP addresses of the given host.\n     *\n     * @param host The host name.\n     * @param update Force update.\n     */\n    getIpAddresses(host: string, update?: boolean): Promise<string[]> {\n        host = normalizeHostId(host);\n        return this.request({\n            cacheKey: `IPs_${host}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const obj = await this.getObject(host);\n                resolve(obj?.common.address ?? []);\n            },\n        });\n    }\n\n    /**\n     * Gets the version.\n     */\n    getVersion(update?: boolean): Promise<{ version: string; serverName: string }> {\n        return this.request({\n            cacheKey: 'version',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getVersion', (err, version, serverName) => {\n                    // Old socket.io had no error parameter\n                    if (err && !version && typeof err === 'string' && err.match(/\\d+\\.\\d+\\.\\d+/)) {\n                        resolve({ version: err, serverName: 'socketio' });\n                    } else {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve({\n                                version: version!,\n                                serverName: serverName!,\n                            });\n                        }\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Gets the web server name.\n     */\n    getWebServerName(): Promise<string> {\n        return this.request({\n            cacheKey: 'webName',\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('getAdapterName', (err, name) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(name!);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Check if the file exists\n     *\n     * @param adapter adapter name\n     * @param filename file name with the full path. it could be like vis.0/*\n     */\n    fileExists(adapter: string, filename: string): Promise<boolean> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('fileExists', adapter, filename, (err, exists) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(!!exists);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Read current user\n     */\n    getCurrentUser(): Promise<string> {\n        return this.request({\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: resolve => {\n                this._socket.emit('authEnabled', (_isSecure, user) => {\n                    resolve(user);\n                });\n            },\n        });\n    }\n\n    /**\n     * Get uuid\n     */\n    getUuid(): Promise<string> {\n        return this.request({\n            cacheKey: 'uuid',\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const obj = await this.getObject('system.meta.uuid');\n                resolve(obj?.native?.uuid);\n            },\n        });\n    }\n\n    /**\n     * Checks if a given feature is supported.\n     *\n     * @param feature The feature to check.\n     * @param update Force update.\n     */\n    checkFeatureSupported(feature: string, update?: boolean): Promise<any> {\n        return this.request({\n            cacheKey: `supportedFeatures_${feature}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('checkFeatureSupported', feature, (err, features) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(features);\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Get all adapter instances.\n     *\n     * @param update Force update.\n     */\n    /**\n     * Get all instances of the given adapter.\n     *\n     * @param adapter The name of the adapter.\n     * @param update Force update.\n     */\n    getAdapterInstances(adapter?: string | boolean, update?: boolean): Promise<ioBroker.InstanceObject[]> {\n        if (typeof adapter === 'boolean') {\n            update = adapter;\n            adapter = '';\n        }\n        adapter ||= '';\n\n        return this.request({\n            cacheKey: `instances_${adapter}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const startKey = adapter ? `system.adapter.${adapter}.` : 'system.adapter.';\n                const endKey = `${startKey}\\u9999`;\n\n                const instances = await this.getObjectViewSystem('instance', startKey, endKey);\n                const instanceObjects = Object.values(instances);\n                if (adapter) {\n                    resolve(instanceObjects.filter(o => o.common.name === adapter));\n                } else {\n                    resolve(instanceObjects);\n                }\n            },\n        });\n    }\n\n    /**\n     * Get adapters with the given name.\n     *\n     * @param adapter The name of the adapter.\n     * @param update Force update.\n     */\n    getAdapters(adapter?: string, update?: boolean): Promise<ioBroker.AdapterObject[]> {\n        if (typeof adapter === 'boolean') {\n            update = adapter;\n            adapter = '';\n        }\n        adapter ||= '';\n\n        return this.request({\n            cacheKey: `adapter_${adapter}`,\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: async resolve => {\n                const adapters = await this.getObjectViewSystem(\n                    'adapter',\n                    `system.adapter.${adapter || ''}`,\n                    `system.adapter.${adapter || '\\u9999'}`,\n                );\n                const adapterObjects = Object.values(adapters);\n                if (adapter) {\n                    resolve(adapterObjects.filter(o => o.common.name === adapter));\n                } else {\n                    resolve(adapterObjects);\n                }\n            },\n        });\n    }\n\n    /**\n     * Get the list of all groups.\n     *\n     * @param update Force update.\n     */\n    getGroups(update?: boolean): Promise<ioBroker.GroupObject[]> {\n        return this.request({\n            cacheKey: 'groups',\n            forceUpdate: update,\n            // TODO: check if this should time out\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit(\n                    'getObjectView',\n                    'system',\n                    'group',\n                    {\n                        startkey: 'system.group.',\n                        endkey: 'system.group.\\u9999',\n                    },\n                    (err, doc) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(getObjectViewResultToArray<ioBroker.GroupObject>(doc));\n                        }\n                    },\n                );\n            },\n        });\n    }\n\n    /**\n     * Logout current user\n     */\n    logout(): Promise<string | null> {\n        return this.request({\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('logout', err => {\n                    err ? reject(err) : resolve(null);\n                });\n            },\n        });\n    }\n\n    /**\n     * Subscribe on instance message\n     *\n     * @param targetInstance instance, like 'cameras.0'\n     * @param messageType message type like 'startCamera/cam3'\n     * @param data optional data object\n     * @param callback message handler\n     */\n    subscribeOnInstance(\n        targetInstance: string,\n        messageType: string,\n        data: any,\n        callback: InstanceMessageCallback,\n    ): Promise<{\n        error?: string;\n        accepted?: boolean;\n        heartbeat?: number;\n    } | null> {\n        return this.request({\n            commandTimeout: false,\n            executor: (resolve, reject) => {\n                this._socket.emit('clientSubscribe', targetInstance, messageType, data, (err, subscribeResult) => {\n                    if (err) {\n                        reject(err);\n                    } else if (subscribeResult) {\n                        if (subscribeResult.error) {\n                            reject(subscribeResult.error);\n                        } else {\n                            if (!targetInstance.startsWith('system.adapter.')) {\n                                targetInstance = `system.adapter.${targetInstance}`;\n                            }\n                            // save callback\n                            this._instanceSubscriptions[targetInstance] =\n                                this._instanceSubscriptions[targetInstance] || [];\n\n                            if (\n                                !this._instanceSubscriptions[targetInstance].find(\n                                    subscription =>\n                                        subscription.messageType === messageType && subscription.callback === callback,\n                                )\n                            ) {\n                                this._instanceSubscriptions[targetInstance].push({\n                                    messageType,\n                                    callback,\n                                });\n                            }\n                            resolve(subscribeResult);\n                        }\n                    }\n                });\n            },\n        });\n    }\n\n    /**\n     * Unsubscribe from instance message\n     *\n     * @param targetInstance instance, like 'cameras.0'\n     * @param messageType message type like 'startCamera/cam3'\n     * @param callback message handler\n     */\n    unsubscribeFromInstance(\n        targetInstance: string,\n        messageType: string,\n        callback: InstanceMessageCallback,\n    ): Promise<boolean> {\n        if (!targetInstance.startsWith('system.adapter.')) {\n            targetInstance = `system.adapter.${targetInstance}`;\n        }\n\n        let deleted;\n        const promiseResults = [];\n        do {\n            deleted = false;\n            const index = this._instanceSubscriptions[targetInstance]?.findIndex(\n                sub => (!messageType || sub.messageType === messageType) && (!callback || sub.callback === callback),\n            );\n\n            if (index !== undefined && index !== null && index !== -1) {\n                deleted = true;\n                // remember messageType\n                const _messageType = this._instanceSubscriptions[targetInstance][index].messageType;\n\n                this._instanceSubscriptions[targetInstance].splice(index, 1);\n                if (!this._instanceSubscriptions[targetInstance].length) {\n                    delete this._instanceSubscriptions[targetInstance];\n                }\n\n                // try to find another subscription for this instance and messageType\n                const found =\n                    this._instanceSubscriptions[targetInstance] &&\n                    this._instanceSubscriptions[targetInstance].find(sub => sub.messageType === _messageType);\n\n                if (!found) {\n                    promiseResults.push(\n                        this.request({\n                            commandTimeout: false,\n                            executor: (resolve, reject) => {\n                                this._socket.emit(\n                                    'clientUnsubscribe',\n                                    targetInstance,\n                                    messageType,\n                                    (err, wasSubscribed) => (err ? reject(err) : resolve(wasSubscribed)),\n                                );\n                            },\n                        }),\n                    );\n                }\n            }\n        } while (deleted && (!callback || !messageType));\n\n        if (promiseResults.length) {\n            return Promise.all(promiseResults).then(results => !!results.find(result => result));\n        }\n\n        return Promise.resolve(false);\n    }\n\n    /**\n     * Send log to ioBroker log\n     *\n     * @param text Log text\n     * @param level `info`, `debug`, `warn`, `error` or `silly`\n     */\n    log(text: string, level?: string): Promise<null> {\n        return text\n            ? this.request({\n                  commandTimeout: false,\n                  executor: resolve => {\n                      this._socket.emit('log', text, level);\n                      return resolve(null);\n                  },\n              })\n            : Promise.resolve(null);\n    }\n\n    /**\n     * This is a special method for vis.\n     * It is used to not send to server the changes about \"nothing_selected\" state\n     *\n     * @param id The state that has to be ignored by communication\n     */\n    setStateToIgnore(id: string): void {\n        this.ignoreState = id;\n    }\n}\n"],
  "mappings": "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",
  "names": ["PROGRESS", "ERRORS", "id", "data"]
}
