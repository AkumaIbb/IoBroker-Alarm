"use strict";
/**
 * Copyright 2018-2025 bluefox <dogafox@gmail.com>
 *
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkEnum = checkEnum;
exports.roleOrEnum = roleOrEnum;
exports.roleOrEnumLight = roleOrEnumLight;
exports.roleOrEnumBlind = roleOrEnumBlind;
exports.roleOrEnumGate = roleOrEnumGate;
exports.roleOrEnumWindow = roleOrEnumWindow;
exports.roleOrEnumDoor = roleOrEnumDoor;
exports.getEnums = getEnums;
exports.getAllStatesInChannel = getAllStatesInChannel;
exports.getAllStatesInDevice = getAllStatesInDevice;
exports.getObjectsBelowId = getObjectsBelowId;
exports.getFunctionEnums = getFunctionEnums;
exports.getParentId = getParentId;
function checkEnum(enums, words) {
    let found = false;
    if (enums) {
        enums.forEach(en => {
            const pos = en.lastIndexOf('.');
            if (pos !== -1) {
                en = en.substring(pos + 1);
            }
            for (const lang in words) {
                if (Object.prototype.hasOwnProperty.call(words, lang)) {
                    if (words[lang].find(reg => reg.test(en))) {
                        found = true;
                        return false;
                    }
                }
            }
        });
    }
    return found;
}
function roleOrEnum(obj, enums, roles, words) {
    if (obj.common.role && (roles === null || roles === void 0 ? void 0 : roles.includes(obj.common.role))) {
        return true;
    }
    return checkEnum(enums, words);
}
// -------------- LIGHT -----------------------------------------
const lightWords = {
    en: [/lights?/i, /lamps?/i, /ceilings?/i],
    de: [/licht(er)?/i, /lampen?/i, /beleuchtung(en)?/i],
    ru: [/свет/i, /ламп[аы]/i, /торшеры?/, /подсветк[аи]/i, /лампочк[аи]/i, /светильники?/i],
};
const lightRoles = ['switch.light', 'dimmer', 'value.dimmer', 'level.dimmer', 'sensor.light', 'state.light'];
function roleOrEnumLight(obj, enums) {
    return roleOrEnum(obj, enums, lightRoles, lightWords);
}
// -------------- BLINDS -----------------------------------------
const blindWords = {
    en: [/blinds?/i, /windows?/i, /shutters?/i],
    de: [/rollladen?/i, /fenstern?/i, /beschattung(en)?/i, /jalousien?/i],
    ru: [/ставни/i, /рольставни/i, /окна|окно/, /жалюзи/i],
};
const blindRoles = [
    'blind',
    'level.blind',
    'value.blind',
    'action.stop',
    'button.stop',
    'button.stop.blind',
    'button.open.blind',
    'button.close.blind',
    'level.tilt',
    'value.tilt',
    'button.tilt.open',
    'button.tilt.close',
    'button.tilt.stop',
];
function roleOrEnumBlind(obj, enums) {
    return roleOrEnum(obj, enums, blindRoles, blindWords);
}
// -------------- GATES ------------------------------------------
const gateWords = {
    en: [/gates?/i],
    de: [/^toren$/i, /^tor$/i], // "^" because of Actor
    ru: [/ворота/i],
};
const gateRoles = ['gate', 'value.gate', 'switch.gate', 'action.stop', 'button.stop'];
function roleOrEnumGate(obj, enums) {
    return roleOrEnum(obj, enums, gateRoles, gateWords);
}
// -------------- WINDOWS -----------------------------------------
const windowRoles = ['window', 'state.window', 'sensor.window', 'value.window'];
function roleOrEnumWindow(obj, enums) {
    return roleOrEnum(obj, enums, windowRoles, blindWords);
}
// -------------- DOORS -----------------------------------------
const doorsWords = {
    en: [/doors?/i, /gates?/i, /wickets?/i, /entry|entries/i],
    de: [/^türe?/i, /^tuere?/i, /^tore?$/i, /einfahrt(en)?/i, /pforten?/i], // "^" because of Actor
    ru: [/двери|дверь/i, /ворота/i, /калитка|калитки/, /въезды?/i, /входы?/i],
};
const doorsRoles = ['door', 'state.door', 'sensor.door'];
function roleOrEnumDoor(obj, enums) {
    return roleOrEnum(obj, enums, doorsRoles, doorsWords);
}
function getEnums() {
    return {
        door: {
            roles: doorsRoles,
            words: doorsWords,
        },
        window: {
            roles: windowRoles,
            words: blindWords,
        },
        blind: {
            roles: blindRoles,
            words: blindWords,
        },
        gate: {
            roles: gateRoles,
            words: gateWords,
        },
        light: {
            roles: lightRoles,
            words: lightWords,
        },
    };
}
function getAllStatesInChannel(keys, channelId) {
    const list = [];
    const reg = new RegExp(`^${channelId.replace(/([$^.)([\]{}])/g, '\\$1')}\\.[^.]+$`);
    keys.forEach(_id => reg.test(_id) && list.push(_id));
    return list;
}
function getAllStatesInDevice(keys, channelId) {
    const list = [];
    const reg = new RegExp(`^${channelId.replace(/([$^.)([\]{}])/g, '\\$1')}\\.[^.]+\\.[^.]+$`);
    keys.forEach(_id => reg.test(_id) && list.push(_id));
    return list;
}
/**
 * Finds all objects "below" a certain ID and the ID itself. It is irrelevant how many levels deep these are
 */
function getObjectsBelowId(sortedKeys, startId) {
    const list = [];
    startId += '.';
    // Find the starting index using binary search
    let left = 0;
    let right = sortedKeys.length - 1;
    let startIndex = -1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (sortedKeys[mid] < startId) {
            left = mid + 1;
        }
        else {
            startIndex = mid;
            right = mid - 1;
        }
    }
    // If no keys are >= startId, return empty array
    if (startIndex === -1 || startIndex >= sortedKeys.length) {
        return list;
    }
    // Iterate from startIndex, collecting keys that match or start with startId
    for (let i = startIndex; i < sortedKeys.length; i++) {
        const id = sortedKeys[i];
        if (id === startId || id.startsWith(startId)) {
            list.push(id);
        }
        else {
            // Since the keys are sorted, we can break early
            break;
        }
    }
    return list;
}
function getFunctionEnums(objects, sortedKeys) {
    var _a, _b, _c;
    const enums = [];
    const reg = /^enum\.functions\./;
    const enumKeys = getObjectsBelowId(sortedKeys, 'enum');
    for (const id of enumKeys) {
        if (Object.prototype.hasOwnProperty.call(objects, id) &&
            reg.test(id) &&
            ((_a = objects[id]) === null || _a === void 0 ? void 0 : _a.type) === 'enum' &&
            ((_c = (_b = objects[id].common) === null || _b === void 0 ? void 0 : _b.members) === null || _c === void 0 ? void 0 : _c.length)) {
            enums.push(id);
        }
    }
    return enums;
}
function getParentId(id) {
    const pos = id.lastIndexOf('.');
    if (pos !== -1) {
        return id.substring(0, pos);
    }
    return id;
}
//# sourceMappingURL=roleEnumUtils.js.map