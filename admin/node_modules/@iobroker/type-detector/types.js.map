{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;GAsBG;;;AA6CH,4EAA4E;AAC5E,yCAAyC;AACzC,wEAAwE;AACxE,IAAY,KA2CX;AA3CD,WAAY,KAAK;IACb,4BAAmB,CAAA;IACnB,sCAA6B,CAAA;IAC7B,wBAAe,CAAA;IACf,sCAA6B,CAAA;IAC7B,0BAAiB,CAAA;IACjB,sCAA6B,CAAA;IAC7B,0BAAiB,CAAA;IACjB,wBAAe,CAAA;IACf,oBAAW,CAAA;IACX,kBAAS,CAAA;IACT,0BAAiB,CAAA;IACjB,sBAAa,CAAA;IACb,gCAAuB,CAAA;IACvB,kCAAyB,CAAA;IACzB,sBAAa,CAAA;IACb,oBAAW,CAAA;IACX,8BAAqB,CAAA;IACrB,oCAA2B,CAAA;IAC3B,wBAAe,CAAA;IACf,sBAAa,CAAA;IACb,8BAAqB,CAAA;IACrB,wBAAe,CAAA;IACf,8BAAqB,CAAA;IACrB,oCAA2B,CAAA;IAC3B,sBAAa,CAAA;IACb,wBAAe,CAAA;IACf,0BAAiB,CAAA;IACjB,oBAAW,CAAA;IACX,gCAAuB,CAAA;IACvB,kCAAyB,CAAA;IACzB,0BAAiB,CAAA;IACjB,0BAAiB,CAAA;IACjB,oCAA2B,CAAA;IAC3B,kCAAyB,CAAA;IACzB,wCAA+B,CAAA;IAC/B,0BAAiB,CAAA;IACjB,oCAA2B,CAAA;IAC3B,4BAAmB,CAAA;IACnB,0CAAiC,CAAA;IACjC,4CAAmC,CAAA;IACnC,0BAAiB,CAAA;IACjB,kCAAyB,CAAA;AAC7B,CAAC,EA3CW,KAAK,qBAAL,KAAK,QA2ChB;AAED,IAAY,SAIX;AAJD,WAAY,SAAS;IACjB,8BAAiB,CAAA;IACjB,8BAAiB,CAAA;IACjB,gCAAmB,CAAA;AACvB,CAAC,EAJW,SAAS,yBAAT,SAAS,QAIpB","sourcesContent":["/**\n * Copyright 2018-2025 bluefox <dogafox@gmail.com>\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/** These are the names of the patterns as used internally */\nexport type PatternName =\n    | 'chart'\n    | 'mediaPlayer'\n    | 'weatherForecast'\n    | 'rgb'\n    | 'rgbwSingle'\n    | 'rgbSingle'\n    | 'cie'\n    | 'hue'\n    | 'ct'\n    | 'warning'\n    | 'airCondition'\n    | 'thermostat'\n    | 'vacuumCleaner'\n    | 'blinds'\n    | 'blindButtons'\n    | 'gate'\n    | 'weatherCurrent'\n    | 'camera'\n    | 'lock'\n    | 'motion'\n    | 'window'\n    | 'windowTilt'\n    | 'fireAlarm'\n    | 'floodAlarm'\n    | 'door'\n    | 'dimmer'\n    | 'light'\n    | 'volume'\n    | 'locationOne'\n    | 'location'\n    | 'volumeGroup'\n    | 'levelSlider'\n    | 'socket'\n    | 'button'\n    | 'buttonSensor'\n    | 'temperature'\n    | 'humidity'\n    | 'illuminance'\n    | 'image'\n    | 'unknown';\n\n// Make sure when you add a new entry here to also add in lib/types with the\n// end user facing name for documentation\n/** These are the types of patterns as used externally and internally */\nexport enum Types {\n    unknown = 'unknown',\n    airCondition = 'airCondition',\n    blind = 'blind',\n    blindButtons = 'blindButtons',\n    button = 'button',\n    buttonSensor = 'buttonSensor',\n    camera = 'camera',\n    chart = 'chart',\n    cie = 'cie',\n    ct = 'ct',\n    dimmer = 'dimmer',\n    door = 'door',\n    fireAlarm = 'fireAlarm',\n    floodAlarm = 'floodAlarm',\n    gate = 'gate',\n    hue = 'hue',\n    humidity = 'humidity',\n    illuminance = 'illuminance',\n    image = 'image',\n    info = 'info',\n    instance = 'instance',\n    light = 'light',\n    location = 'location',\n    locationOne = 'locationOne',\n    lock = 'lock',\n    media = 'media',\n    motion = 'motion',\n    rgb = 'rgb',\n    rgbSingle = 'rgbSingle',\n    rgbwSingle = 'rgbwSingle',\n    slider = 'slider',\n    socket = 'socket',\n    temperature = 'temperature',\n    thermostat = 'thermostat',\n    vacuumCleaner = 'vacuumCleaner',\n    volume = 'volume',\n    volumeGroup = 'volumeGroup',\n    warning = 'warning',\n    weatherCurrent = 'weatherCurrent',\n    weatherForecast = 'weatherForecast',\n    window = 'window',\n    windowTilt = 'windowTilt',\n}\n\nexport enum StateType {\n    Number = 'number',\n    String = 'string',\n    Boolean = 'boolean',\n}\n\nexport interface InternalDetectorState {\n    /** RegEx to detect role */\n    role?: RegExp;\n\n    /** RegEx to detect channel role of state */\n    channelRole?: RegExp;\n\n    /** RegEx to ignore some specific roles */\n    ignoreRole?: RegExp;\n\n    /** Is it will be shown like a small icon or as a value */\n    indicator?: boolean;\n\n    /** State type: 'number', 'string' or 'boolean' or array of possible values */\n    type?: StateType | StateType[];\n\n    /** Own TAG of the state to process it in the logic */\n    name: string;\n\n    /** If set to true or false, it will be checked the write attribute, if no attribute, so \"false\" will be assumed */\n    write?: boolean;\n\n    /** If set to true or false, it will be checked the write attribute, if no attribute, so \"true\" will be assumed */\n    read?: boolean;\n\n    /** Type of attribute: number', 'string' or 'boolean'. This attribute must exist in common */\n    min?: StateType;\n\n    /** Type of attribute: number', 'string' or 'boolean'. This attribute must exist in common */\n    max?: StateType;\n\n    /** If required to detect the pattern as valid */\n    required?: boolean;\n\n    /** No automatic subscription for this state (e.g., if write-only) */\n    noSubscribe?: boolean;\n\n    /** If this pattern should be searched in a device too and not only in channel */\n    searchInParent?: boolean;\n\n    /** Function to execute custom category detection */\n    enums?: (obj: ioBroker.Object, enums: string[]) => boolean;\n\n    /** If more than one state may have this pattern in channel */\n    multiple?: boolean;\n\n    /** Do not search indicators in a parent device */\n    noDeviceDetection?: boolean;\n\n    /** This state may belong to more than one tile simultaneously (e.g., volume tile and media with volume) */\n    notSingle?: boolean;\n\n    /** If the state of indicator must be inverted */\n    inverted?: boolean;\n\n    /** Regex for state names (IDs). Not suggested */\n    stateName?: RegExp;\n\n    /** Is irrelevant for detection, but will be used by `ioBroker.devices` and `ioBroker.matter`. */\n    defaultStates?: { [key: string]: string };\n\n    /**\n     * It is used to enhance detection by laxing some rules if matching, else will be used by\n     * `ioBroker.devices` and `ioBroker.matter`\n     * Only states WITH defaultRole will show up in the UI.\n     */\n    defaultRole?: string;\n\n    /**\n     * It is used to enhance detection by laxing some rules if matching, else will be used by\n     * `ioBroker.devices` and `ioBroker.matter`.\n     */\n    defaultUnit?: string;\n\n    /** Is irrelevant for detection, but will be used by `ioBroker.devices` and `ioBroker.matter`. */\n    defaultType?: StateType;\n\n    /** Is irrelevant for detection, but will be used by `ioBroker.devices` and `ioBroker.matter`. */\n    defaultChannelRole?: string;\n\n    /** If set, then the unit needs to match. */\n    unit?: string;\n\n    /** If set, then the object type needs to match. */\n    objectType?: string;\n\n    /**\n     * If set then the regex needs to match with the last-level-state-name (the one after the\n     * last \".\")\n     */\n    state?: RegExp;\n}\n\nexport interface DetectorState extends InternalDetectorState {\n    original?: InternalDetectorState;\n    id: string;\n}\nexport interface ExternalDetectorState extends Omit<InternalDetectorState, 'enums' | 'role'> {\n    enums?: boolean;\n    role?: string;\n}\n\nexport interface DetectOptions {\n    /** All objects */\n    objects: Record<string, ioBroker.Object>;\n\n    /** ID to detect of state, device or channel */\n    id: string;\n\n    /** List of state names, that will be ignored. e.g., ['UNREACH_STICKY'] */\n    ignoreIndicators?: string[];\n\n    /** List of allowed types. e.g., ['slider', 'rgbSingle'] */\n    allowedTypes?: Types[];\n\n    /** List of excluded types. e.g., ['rgb', 'rgbSingle'] */\n    excludedTypes?: Types[];\n\n    /**\n     * List of types that when detected also limit other types,\n     * e.g. [[Types.light, Types.ct, Types.rgb, Types.rgbSingle, Types.rgbwSingle, Types.hue, Types.cie]] limits detection to one lighting type.\n     */\n    limitTypesToOneOf?: PatternName[][];\n\n    /**\n     * List of Types to prioritize before the others.\n     * Example: [[Types.hue, Types.rgb], [Types.RgbSingle, Types.RGB]] moves Hue before RGB and RGBSingle also before RGB\n     */\n    prioritizedTypes?: [moveThisType: PatternName, beforeThatType: PatternName][];\n\n    /**\n      If true, the cache will be ignored\n     */\n    ignoreCache?: boolean;\n\n    /**\n     * If true, the enums will be ignored. Will be set to true automatically if allowedTypes has exactly 1 entry\n     */\n    ignoreEnums?: boolean;\n\n    /**\n     * If true, the usedIds will be ignored and all wanted types are detected with all available states. Only use for\n     * limited object cases. It automatically excludes \"info\" type\n     */\n    detectAllPossibleDevices?: boolean;\n\n    /**\n     * Adjusts the logic to try to find a device object and consider all state in there, else a channel\n     */\n    detectParent?: boolean;\n\n    /** Look only in one level above. The flag will be ignored if detectParent is set */\n    detectOnlyChannel?: boolean;\n\n    // Internally used infos and caches\n\n    /** For optimization, it is Object.keys(objects) */\n    _keysOptional?: string[];\n\n    /** For optimization, if the provided _keysOptional are sorted */\n    _keysOptionalSorted?: boolean;\n\n    /** For optimization, initially it is empty array */\n    _usedIdsOptional?: string[];\n\n    /** For optimization, initially it is empty array */\n    _checkedPatterns?: PatternName[];\n\n    /** For optimization, internal list of patterns order to process */\n    _patternList?: PatternName[];\n}\n\nexport interface DetectorContext {\n    objects: Record<string, ioBroker.Object>; // all objects\n    channelStates: string[];\n    usedIds: string[];\n    usedInCurrentDevice: string[];\n    ignoreIndicators: string[];\n    result?: PatternControl;\n    pattern: PatternName;\n    state: InternalDetectorState;\n    ignoreEnums: boolean;\n    sortedKeys: string[];\n    favorId?: string;\n    detectAllPossibleDevices?: boolean;\n}\n\nexport interface MatchedDetectorContext extends Omit<DetectorContext, 'result'> {\n    result: PatternControl;\n}\n\nexport interface InternalPatternControl {\n    states: InternalDetectorState[];\n    type: Types;\n    enumRequired?: boolean;\n}\nexport interface PatternControl {\n    states: DetectorState[];\n    type: Types;\n    enumRequired?: boolean;\n}\n\nexport interface ExternalPatternControl {\n    states: ExternalDetectorState[];\n    type: Types;\n    enumRequired?: boolean;\n}\n\nexport type PatternLanguages = 'en' | 'de' | 'ru';\nexport type PatternWords = Record<PatternLanguages, RegExp[]>;\n"]}