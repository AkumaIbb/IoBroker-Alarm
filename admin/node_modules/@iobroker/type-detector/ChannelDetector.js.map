{"version":3,"file":"ChannelDetector.js","sourceRoot":"","sources":["../src/ChannelDetector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2018-2025 bluefox <dogafox@gmail.com>\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nimport {\n    type DetectOptions,\n    type DetectorContext,\n    type DetectorState,\n    type ExternalDetectorState,\n    type ExternalPatternControl,\n    type InternalDetectorState,\n    type InternalPatternControl,\n    type PatternControl,\n    type MatchedDetectorContext,\n    type PatternName,\n    StateType,\n    Types,\n} from './types';\nimport { getFunctionEnums, getParentId, getEnums, getObjectsBelowId } from './roleEnumUtils';\nimport { patterns } from './typePatterns';\n\nexport class ChannelDetector {\n    private enums: string[] | null = null;\n    private readonly cache: Record<string, PatternControl[] | null> = {};\n\n    public static getEnums = getEnums;\n\n    private _applyPattern(\n        objects: Record<string, ioBroker.Object>,\n        id: string,\n        statePattern: InternalDetectorState,\n        ignoreEnums: boolean,\n        sortedKeys: string[],\n    ): boolean {\n        if (objects[id]?.common) {\n            let role = null;\n            if (statePattern.role) {\n                role = statePattern.role.test(objects[id].common.role || '');\n\n                if (role && statePattern.channelRole) {\n                    const channelId = getParentId(id);\n                    const channelRole = objects[channelId]?.common.role || '';\n                    if (\n                        channelRole &&\n                        (objects[channelId].type === 'channel' || objects[channelId].type === 'device')\n                    ) {\n                        role = statePattern.channelRole.test(channelRole);\n                    } else {\n                        role = false;\n                    }\n                }\n            }\n            if (role === false) {\n                return false;\n            }\n\n            if (statePattern.type) {\n                if (typeof statePattern.type === 'string') {\n                    if (statePattern.type !== objects[id].common.type) {\n                        return false;\n                    }\n                } else if (Array.isArray(statePattern.type)) {\n                    let oneMatched = false;\n                    for (let t = 0; t < statePattern.type.length; t++) {\n                        if (statePattern.type[t] === objects[id].common.type) {\n                            oneMatched = true;\n                            break;\n                        }\n                    }\n                    if (!oneMatched) {\n                        return false;\n                    }\n                }\n            }\n\n            if (statePattern.objectType && objects[id].type !== statePattern.objectType) {\n                return false;\n            }\n\n            if (statePattern.stateName && !statePattern.stateName.test(id)) {\n                return false;\n            }\n\n            if (statePattern.unit && statePattern.unit !== objects[id].common.unit) {\n                return false;\n            }\n\n            if (statePattern.ignoreRole) {\n                const role = objects[id].common.role || '';\n                if (role && statePattern.ignoreRole.test(role)) {\n                    return false;\n                }\n            }\n\n            if (statePattern.indicator === false && (objects[id].common.role || '').match(/^indicator(\\.[.\\w]+)?$/)) {\n                return false;\n            }\n\n            if (statePattern.state) {\n                const lastStateName = id.split('.').pop() || '';\n                if (lastStateName && !statePattern.state.test(lastStateName)) {\n                    return false;\n                }\n            }\n\n            const defaultRoleAssigned =\n                statePattern.defaultRole && objects[id].common.role === statePattern.defaultRole;\n\n            const defaultUnitAssigned = statePattern.defaultUnit\n                ? objects[id].common.unit === statePattern.defaultUnit\n                : false;\n\n            if (statePattern.min === StateType.Number && typeof objects[id].common.min !== StateType.Number) {\n                // If we have a default unit, and it matches and is % allow bypassing min/max because\n                // defined as 0..100 anyway\n                if (!defaultUnitAssigned || objects[id].common.unit !== '%') {\n                    return false;\n                }\n            }\n\n            if (statePattern.max === StateType.Number && typeof objects[id].common.max !== StateType.Number) {\n                // If we have a default unit, and it matches and is % allow bypassing min/max because\n                // defined as 0..100 anyway\n                if (!defaultUnitAssigned || objects[id].common.unit !== '%') {\n                    return false;\n                }\n            }\n\n            // When the default role is assigned, then the users should know how to handle it,\n            // so we can be a bit more laxe if read/write is not set correctly because the user\n            // created it manually. Additionally, enum check should be not needed with default role because the role already\n            // includes that.\n\n            // But otherwise, check more detailed and also the enums\n            if (!defaultRoleAssigned) {\n                if (statePattern.write !== undefined && statePattern.write !== !!objects[id].common.write) {\n                    return false;\n                }\n\n                if (\n                    statePattern.read !== undefined &&\n                    statePattern.read !== (objects[id].common.read === undefined ? true : objects[id].common.read)\n                ) {\n                    return false;\n                }\n\n                if (typeof statePattern.enums === 'function') {\n                    const enums = this._getEnumsForId(objects, id, sortedKeys);\n                    if (!ignoreEnums && !statePattern.enums(objects[id], enums || [])) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    private _getEnumsForId(\n        objects: Record<string, ioBroker.Object>,\n        id: string,\n        sortedKeys: string[],\n    ): string[] | null {\n        this.enums ||= getFunctionEnums(objects, sortedKeys);\n        const result: string[] = [];\n\n        this.enums.forEach(e => {\n            if (objects[e].common.members.includes(id)) {\n                result.push(e);\n            }\n        });\n\n        if (!result.length && objects[id]?.type === 'state') {\n            const channel = getParentId(id);\n            if (objects[channel] && (objects[channel].type === 'channel' || objects[channel].type === 'device')) {\n                this.enums.forEach(e => {\n                    if (objects[e].common.members.includes(channel)) {\n                        result.push(e);\n                    }\n                });\n            }\n        }\n\n        return result.length ? result : null;\n    }\n\n    private static copyState(oldState: InternalDetectorState, newState?: DetectorState): DetectorState {\n        const _newState: DetectorState = newState || JSON.parse(JSON.stringify(oldState));\n        _newState.original = (oldState as DetectorState).original || oldState;\n        if ('enums' in oldState && oldState.enums) {\n            _newState.enums = oldState.enums;\n        }\n        if ('role' in oldState && oldState.role) {\n            _newState.role = oldState.role;\n        }\n        if ('channelRole' in oldState && oldState.channelRole) {\n            _newState.channelRole = oldState.channelRole;\n        }\n\n        return _newState;\n    }\n\n    private _testOneState(context: DetectorContext): boolean {\n        const objects = context.objects;\n        const pattern = context.pattern;\n        const state = context.state;\n        const channelStates = context.channelStates;\n        const usedIds = context.usedIds;\n        const usedInCurrentDevice = context.usedInCurrentDevice;\n        const ignoreIndicators = context.ignoreIndicators;\n        const ignoreEnums = context.ignoreEnums;\n        const sortedKeys = context.sortedKeys;\n        let result = context.result;\n        let found = false;\n        // let count = 0;\n\n        // check every state in a channel\n        for (const stateId of channelStates) {\n            // this is only valid if no one state could be multiple\n            // if (result && count >= result.states.length) {\n            //     // do not look for more states as all possible found\n            //     return;\n            // }\n\n            // one exception: if we already found a state with name COVER, so ignore the second one\n            if (state.name === 'COVER' && result?.states.find(e => e.id && e.name === 'COVER')) {\n                continue;\n            }\n\n            if (state.indicator && ignoreIndicators) {\n                const parts = stateId.split('.');\n                const lastStateName = parts.pop() || '';\n\n                if (lastStateName && ignoreIndicators.includes(lastStateName)) {\n                    // console.log(`${stateId} ignored`);\n                    continue;\n                }\n            }\n\n            if (state.indicator) {\n                // We always detect indicators even if one used for multiple devices\n            } else if (usedInCurrentDevice.includes(stateId)) {\n                // we already used this state in the current device\n                continue;\n            } else if (state.notSingle) {\n                // we already used this state in another device but notSingle is set\n            } else if (context.detectAllPossibleDevices) {\n                // No matter if used before, we want all possible devices\n            } else if (usedIds.includes(stateId)) {\n                // we already used this state in another device\n                continue;\n            }\n\n            if (this._applyPattern(objects, stateId, state, ignoreEnums, sortedKeys)) {\n                // we detected a state, copy InternalPatternControl\n                if (!result) {\n                    result = JSON.parse(JSON.stringify(patterns[pattern])) as PatternControl; // can not be undefined here\n                    context.result = result;\n                    result?.states.forEach((state, j) => ChannelDetector.copyState(patterns[pattern].states[j], state));\n                }\n\n                // map the detected ID to the relevant state in result - if allowed\n                if (!result.states.find(({ id }) => id === stateId)) {\n                    for (const checkState of result.states) {\n                        if (checkState.name === state.name) {\n                            // If we already have a mapped ID, we need to decide if we keep this ID or overrule it\n                            if (checkState.id) {\n                                let useThisMapping: boolean | undefined; // three-state flag\n\n                                // Check if the favored state ID matches one of the available states, then this wins\n                                if (context.favorId) {\n                                    if (stateId === context.favorId) {\n                                        useThisMapping = true;\n                                    } else if (checkState.id === context.favorId) {\n                                        useThisMapping = false;\n                                    }\n                                }\n\n                                const existingIdRole = objects[checkState.id]?.common?.role ?? '';\n                                const stateIdRole = objects[stateId]?.common?.role ?? '';\n                                const defaultRole = checkState.defaultRole;\n                                if (defaultRole && useThisMapping === undefined) {\n                                    // Check if the defaultRole is matching to any of the available states, then this wins\n                                    if (stateIdRole === defaultRole) {\n                                        useThisMapping = true;\n                                    } else if (existingIdRole === defaultRole) {\n                                        useThisMapping = false;\n                                    }\n                                }\n                                if (useThisMapping === undefined) {\n                                    // If one of the roles uses state as first level or is empty, then the other one is better.\n                                    // If both are not \"state\" then check how many levels the roles have, the more, the better.\n                                    // If same then not having \"state\" as first level will override the id, else not\n                                    const stateIdRoleLevels = stateIdRole.split('.');\n                                    const stateIdRoleLevelsCount = stateIdRoleLevels.length;\n                                    const existingIdRoleLevels = existingIdRole.split('.');\n                                    const existingIdRoleLevelsCount = existingIdRoleLevels.length;\n                                    if (stateIdRole === '') {\n                                        useThisMapping = false;\n                                    } else if (\n                                        stateIdRoleLevels[0] === 'state' &&\n                                        existingIdRoleLevels[0] !== 'state'\n                                    ) {\n                                        useThisMapping = false;\n                                    } else if (\n                                        stateIdRoleLevels[0] !== 'state' &&\n                                        existingIdRoleLevels[0] === 'state'\n                                    ) {\n                                        useThisMapping = true;\n                                    } else if (stateIdRoleLevelsCount > existingIdRoleLevelsCount) {\n                                        useThisMapping = true;\n                                    } else if (stateIdRoleLevelsCount < existingIdRoleLevelsCount) {\n                                        useThisMapping = false;\n                                    } else {\n                                        useThisMapping = stateIdRoleLevels[0] !== 'state';\n                                    }\n                                }\n\n                                // We ignore the found mapping, because it's better than the current one\n                                if (!useThisMapping) {\n                                    break;\n                                }\n                            }\n\n                            // count++;\n                            checkState.id = stateId;\n                            found = true;\n                            break;\n                        }\n                    }\n                } else {\n                    found = true; // Was there before already?\n                }\n\n                if (found) {\n                    if (!state.indicator) {\n                        usedInCurrentDevice.push(stateId);\n                    }\n\n                    if (state.multiple && channelStates.length > 1) {\n                        // execute this rule for every state in this channel\n                        for (const cid of channelStates) {\n                            if (cid === stateId) {\n                                continue;\n                            }\n                            if (\n                                (state.indicator ||\n                                    (!usedInCurrentDevice.includes(cid) &&\n                                        (state.notSingle || !usedIds.includes(cid)))) &&\n                                this._applyPattern(objects, cid, state, ignoreEnums, sortedKeys)\n                            ) {\n                                if (!state.indicator) {\n                                    usedInCurrentDevice.push(cid);\n                                }\n                                if (Array.isArray(state)) {\n                                    const newState: DetectorState = ChannelDetector.copyState(state[0]);\n                                    newState.id = cid;\n                                    result.states.push(newState);\n                                } else {\n                                    const newState: DetectorState = ChannelDetector.copyState(state);\n                                    newState.id = cid;\n                                    result.states.push(newState);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return found;\n    }\n\n    /**\n     * Tries to find a device or channel (as fallback) where the state is in\n     */\n    private static findParentChannelOrDevice(\n        objects: Record<string, ioBroker.Object>,\n        id: string,\n        onlyChannel?: boolean,\n    ): string | undefined {\n        if (!objects[id]) {\n            // Object does not exist\n            return;\n        }\n        const parts = id.split('.');\n        const origId = id;\n\n        if (objects[id].type === 'state') {\n            // a state needs to be in a channel, device, folder or such, so check the level above\n            parts.pop();\n            id = parts.join('.');\n        }\n        if (parts.length <= 2) {\n            // Ok, we already reached the instance level, no need to search higher, then we go with this id\n            return id;\n        }\n\n        const obj = objects[id];\n        if (obj?.type === 'device' || (onlyChannel && obj?.type === 'channel')) {\n            // We found a device object, use this\n            return id;\n        }\n        if (onlyChannel) {\n            return undefined;\n        }\n        parts.pop();\n        const upperLevelObjectId = parts.join('.');\n        const upperObj = objects[upperLevelObjectId];\n        if (!upperObj) {\n            // Ok not existing object, so we use the existing object from before\n            return obj ? id : origId;\n        }\n        if (upperObj.type === 'device' || parts.length <= 2) {\n            // We found a device object, or ended already on instance level, use this\n            return upperLevelObjectId;\n        }\n        if (obj?.type === 'channel') {\n            // The object is (or inside) a channel, but above is no device, so lets better use the channel\n            return id;\n        }\n\n        // When we come here the state.parent or state.parent.parent is no device or channel, and we are not already on top\n        // So lets gibe it one more last chance to find something\n        parts.pop();\n        const secondUpperLevelObjectId = parts.join('.');\n        const secondUpperObj = objects[secondUpperLevelObjectId];\n        if (!secondUpperObj || (secondUpperObj.type !== 'device' && secondUpperObj.type !== 'channel')) {\n            // Ok not existing object or no channel/device, so we use the existing object from before\n            return upperLevelObjectId;\n        }\n        return secondUpperLevelObjectId;\n    }\n\n    private static getChannelOrDeviceStates(\n        objects: Record<string, ioBroker.Object>,\n        id: string,\n        keys: string[],\n        checkParent = false,\n        checkOnlyInSameChannel = false,\n    ): string[] {\n        const type = objects[id]?.type;\n        switch (type) {\n            case undefined:\n                return [...getObjectsBelowId(keys, id)];\n            case 'state':\n            case 'channel':\n            case 'device':\n            case 'folder':\n                if (checkParent && type !== 'device') {\n                    const foundId = ChannelDetector.findParentChannelOrDevice(objects, id);\n\n                    return foundId && foundId !== id ? [...getObjectsBelowId(keys, foundId)] : [id];\n                }\n                if (type !== 'state') {\n                    return [...getObjectsBelowId(keys, id)];\n                } else if (checkOnlyInSameChannel) {\n                    const foundId = ChannelDetector.findParentChannelOrDevice(objects, id, true);\n                    return foundId && foundId !== id ? [...getObjectsBelowId(keys, foundId)] : [id];\n                }\n                return [id];\n\n            default:\n                return [id];\n        }\n    }\n\n    private static patternIsAllowed(\n        pattern: InternalPatternControl,\n        allowedTypes: Types[] | undefined,\n        excludedTypes: Types[] | undefined,\n    ): boolean {\n        if (!pattern) {\n            return false;\n        }\n        if (Array.isArray(pattern.type)) {\n            for (let t = 0; t < pattern.type.length; t++) {\n                if (allowedTypes && !allowedTypes.includes(pattern.type[t])) {\n                    return false;\n                }\n                if (excludedTypes && excludedTypes.includes(pattern.type[t])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (allowedTypes && !allowedTypes.includes(pattern.type)) {\n            return false;\n        }\n\n        return !excludedTypes || !excludedTypes.includes(pattern.type);\n    }\n\n    private static allRequiredStatesFound(context: DetectorContext): context is MatchedDetectorContext {\n        if (!context.result) {\n            return false;\n        }\n\n        const states = context.result.states;\n\n        for (let a = 0; a < states.length; a++) {\n            if (states[a].required && !states[a].id) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static cleanState(state: DetectorState, objects: Record<string, ioBroker.Object>): void {\n        const role: string = objects[state.id]?.common?.role || '';\n        if (state.name.includes('%d') && state.role && state.id && role) {\n            const m = state.role.exec(role);\n            if (m) {\n                state.name = state.name.replace('%d', m[1]);\n            }\n        }\n        if (state.role) {\n            delete state.role;\n        }\n        if (state.enums) {\n            delete state.enums;\n        }\n        if (state.original) {\n            delete state.original;\n        }\n    }\n\n    /**\n     * Sorts the list of Type patterns using the definition of the prioritized ones\n     *\n     * @param typeList Types list\n     * @param prioritizedTypes Array of pairs with changed priority\n     */\n    private sortTypes(\n        typeList: PatternName[],\n        prioritizedTypes: [moveThisType: PatternName, beforeThatType: PatternName][],\n    ): PatternName[] {\n        prioritizedTypes.forEach(([moveThisType, beforeThatType]) => {\n            const fromIndex = typeList.indexOf(moveThisType);\n            const toIndex = typeList.indexOf(beforeThatType);\n            if (fromIndex === -1 || toIndex === -1) {\n                return;\n            }\n            const fromType = typeList.splice(fromIndex, 1);\n            typeList.splice(toIndex, 0, ...fromType);\n        });\n\n        return typeList;\n    }\n\n    private _detectNext(options: DetectOptions): PatternControl | null {\n        const {\n            objects,\n            id,\n            _usedIdsOptional: usedIds = [],\n            ignoreIndicators,\n            prioritizedTypes,\n            detectParent,\n            detectOnlyChannel,\n            allowedTypes,\n            excludedTypes,\n            _keysOptional, // sorted keys\n            detectAllPossibleDevices,\n        } = options;\n        let { _patternList } = options;\n\n        options._usedIdsOptional = usedIds;\n\n        const channelStates = ChannelDetector.getChannelOrDeviceStates(\n            objects,\n            id,\n            _keysOptional || [],\n            detectParent,\n            detectOnlyChannel,\n        );\n\n        // We have no ID for that object and also no objects below, so skip it\n        if (!objects[id]?.common && !channelStates.length) {\n            return null;\n        }\n        options._checkedPatterns ??= [];\n\n        if (!_patternList) {\n            const allPatterns: PatternName[] = Object.keys(patterns).filter(pattern =>\n                ChannelDetector.patternIsAllowed(patterns[pattern as PatternName], allowedTypes, excludedTypes),\n            ) as PatternName[];\n            _patternList = prioritizedTypes ? this.sortTypes(allPatterns, prioritizedTypes) : allPatterns;\n            options._patternList = _patternList;\n        }\n\n        const context: DetectorContext = {\n            objects,\n            channelStates,\n            usedIds,\n            ignoreIndicators: ignoreIndicators || [],\n            pattern: 'unknown',\n            usedInCurrentDevice: [],\n            state: {} as InternalDetectorState,\n            ignoreEnums: !!options.ignoreEnums,\n            sortedKeys: _keysOptional!,\n            favorId: options.detectParent ? undefined : id,\n            detectAllPossibleDevices,\n        };\n\n        const currentType = objects[id]?.type;\n        for (const pattern of _patternList) {\n            if (options._checkedPatterns.includes(pattern)) {\n                continue;\n            }\n            options._checkedPatterns.push(pattern);\n\n            // reset the result\n            delete context.result;\n\n            context.pattern = pattern;\n            context.usedInCurrentDevice = [];\n            for (const state of patterns[pattern].states) {\n                let found = false;\n\n                // one of the following\n                context.state = state;\n                if (this._testOneState(context)) {\n                    found = true;\n                }\n                if (state.required && !found) {\n                    delete context.result;\n                    break;\n                }\n            }\n\n            if (!ChannelDetector.allRequiredStatesFound(context)) {\n                continue;\n            }\n\n            // Store all used IDs in the array\n            context.usedInCurrentDevice.forEach(id => usedIds.push(id));\n\n            let deviceStates: string[];\n\n            // looking for indicators and special states\n            if (currentType !== 'device') {\n                // get device name\n                const deviceId = ChannelDetector.findParentChannelOrDevice(objects, id) ?? id;\n                if (\n                    objects[deviceId] &&\n                    (objects[deviceId].type === 'channel' || objects[deviceId].type === 'device')\n                ) {\n                    deviceStates = getObjectsBelowId(_keysOptional!, deviceId);\n                    for (const _id of deviceStates) {\n                        context.result.states.forEach((state, i) => {\n                            if (!state.id && (state.indicator || state.searchInParent) && !state.noDeviceDetection) {\n                                if (\n                                    this._applyPattern(\n                                        objects,\n                                        _id,\n                                        state.original as InternalDetectorState,\n                                        !!options.ignoreEnums,\n                                        context.sortedKeys,\n                                    ) &&\n                                    context.result\n                                ) {\n                                    context.result.states[i].id = _id;\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n\n            context.result.states.forEach((state: DetectorState) => ChannelDetector.cleanState(state, context.objects));\n\n            // Check if the detected type should be limited to a set of types and also declare the others as checked\n            if (options.limitTypesToOneOf) {\n                for (const types of options.limitTypesToOneOf) {\n                    if (types.includes(pattern)) {\n                        for (const type of types) {\n                            if (type === pattern || options._checkedPatterns.includes(type)) {\n                                continue;\n                            }\n                            options._checkedPatterns.push(type);\n                        }\n                    }\n                }\n            }\n\n            return context.result;\n        }\n\n        return null;\n    }\n\n    /**\n     * Detect devices in some given path. Path can show to state, channel or device.\n     *\n     * @param options - parameters with following fields\n     *                  objects - Object, that has all objects in form {'id1': {obj1params...}, 'id2': {obj2params...}}\n     *                  id - Root ID from which the detection must start\n     *                  _keysOptional - Array with (sorted) keys from `options.objects` for optimization\n     *                  _keysOptionalSorted - indicates if `_keysOptional` is sorted (for optimization)\n     *                  _usedIdsOptional - Array with yet detected devices to do not similar device under different types\n     *                  ignoreIndicators - If simple indicators like \"low battery\", \"not reachable\" must be detected as device or only as a part of other device.\n     *                  allowedTypes - array with names of device types that can be detected. Not listed device types will be ignored.\n     *                  excludedTypes - array with names of device types that must be ignored. The listed device types will be ignored.\n     *                  prioritizedTypes - List of Types to prioritize before the others.\n     */\n    public detect(options: DetectOptions): PatternControl[] | null {\n        const { objects, id, ignoreCache, detectAllPossibleDevices } = options;\n        let { _keysOptional, _usedIdsOptional } = options;\n\n        if (!ignoreCache && this.cache[id]) {\n            // We validate if the cache matches the requirements and if not skip the cache\n            const { allowedTypes = [], excludedTypes = [] } = options;\n            if (!allowedTypes.length && !excludedTypes.length) {\n                return this.cache[id];\n            }\n            const result = this.cache[id].filter(\n                ({ type }) => allowedTypes.includes(type) && !excludedTypes.includes(type),\n            );\n            if (result.length) {\n                return result;\n            }\n        }\n\n        if (!_keysOptional) {\n            _keysOptional = Object.keys(objects);\n            _keysOptional.sort();\n            options._keysOptional = _keysOptional;\n        } else if (!options._keysOptionalSorted) {\n            _keysOptional.sort();\n        }\n\n        // We reset the already used IDs normally for better detection but not when we used parent to detect\n        // because then we have already checked a whole \"subtree\" for the best matching results and so can exclude the\n        // matched ids\n        if (_usedIdsOptional && !options.detectParent) {\n            _usedIdsOptional = [];\n            options._usedIdsOptional = _usedIdsOptional;\n        }\n\n        // When we do want to detect a special device type, we can ignore enums\n        if (options.ignoreEnums === undefined && options.allowedTypes?.length === 1) {\n            options.ignoreEnums = true;\n        }\n        if (detectAllPossibleDevices) {\n            options.excludedTypes ||= [];\n            if (!options.excludedTypes.includes(Types.info)) {\n                options.excludedTypes.push(Types.info);\n            }\n        }\n        options._checkedPatterns = [];\n\n        const result: PatternControl[] = [];\n        let detected;\n\n        while ((detected = this._detectNext(options))) {\n            result.push(detected);\n            if (options.detectAllPossibleDevices) {\n                options._usedIdsOptional = [];\n            }\n        }\n\n        // We must place the devices which have initial ID on required place on the first places\n        // Then the controls with maximal amount of matched states\n        result.sort((a, b) => {\n            // place info on tha last place\n            if (a.type === Types.info && b.type !== Types.info) {\n                return 1;\n            }\n            if (b.type === Types.info && a.type !== Types.info) {\n                return -1;\n            }\n\n            const aHasRequiredId = a.states.find(s => s.id === id && s.required) ? 1 : 0;\n            const bHasRequiredId = b.states.find(s => s.id === id && s.required) ? 1 : 0;\n            if (aHasRequiredId !== bHasRequiredId) {\n                return bHasRequiredId - aHasRequiredId;\n            }\n            if (!aHasRequiredId) {\n                const aHasId = a.states.find(s => s.id === id) ? 1 : 0;\n                const bHasId = b.states.find(s => s.id === id) ? 1 : 0;\n                if (aHasId !== bHasId) {\n                    return bHasId - aHasId;\n                }\n            }\n\n            const aCount = a.states.filter(s => s.id).length;\n            const bCount = b.states.filter(s => s.id).length;\n            return bCount - aCount;\n        });\n\n        this.cache[id] = result.length ? result : null;\n\n        return this.cache[id];\n    }\n\n    /**\n     * Returns all the known by type-detector type patterns\n     */\n    public static getPatterns(): { [type: string]: ExternalPatternControl } {\n        const copyPatterns: { [type: string]: ExternalPatternControl } = {};\n\n        Object.keys(patterns).forEach(type => {\n            const item: ExternalPatternControl = JSON.parse(JSON.stringify(patterns[type]));\n            item.states.forEach((_state: ExternalDetectorState | ExternalDetectorState[], i: number) => {\n                const oldState = patterns[type].states[i];\n                if (oldState.role) {\n                    item.states[i].role = oldState.role.toString();\n                }\n\n                if (oldState.enums) {\n                    item.states[i].enums = true;\n                }\n            });\n\n            copyPatterns[type] = item;\n        });\n\n        return copyPatterns;\n    }\n}\n"]}